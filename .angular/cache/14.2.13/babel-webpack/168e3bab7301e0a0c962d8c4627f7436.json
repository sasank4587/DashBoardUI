{"ast":null,"code":"/* \r\n CanvasJS Chart - v3.9.0 GA - https://canvasjs.com/ \r\n Copyright 2024 fenopix\r\n\r\n --------------------- License Information --------------------\r\n CanvasJS Chart is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.\r\n https://canvasjs.com/license/\r\n\r\n\r\n ---------------------Free for Non-Commercial Use--------------------\r\n \r\n For non-commercial purposes you can use the software for free under Creative Commons Attribution-NonCommercial 3.0 License.\r\n A credit Link is added to the chart which should be preserved. Refer to the following link for further details on the same.\r\n https://creativecommons.org/licenses/by-nc/3.0/deed.en_US\r\n */\n\n/*tslint:disable*/\n\n/*eslint-disable*/\n\n/*jshint ignore:start*/\n(function () {\n  function pa(d, m) {\n    d.prototype = eb(m.prototype);\n    d.prototype.constructor = d;\n    d.base = m.prototype;\n  }\n\n  function eb(d) {\n    function m() {}\n\n    m.prototype = d;\n    return new m();\n  }\n\n  function Ya(d, m, S) {\n    \"millisecond\" === S ? d.setMilliseconds(d.getMilliseconds() + 1 * m) : \"second\" === S ? d.setSeconds(d.getSeconds() + 1 * m) : \"minute\" === S ? d.setMinutes(d.getMinutes() + 1 * m) : \"hour\" === S ? d.setHours(d.getHours() + 1 * m) : \"day\" === S ? d.setDate(d.getDate() + 1 * m) : \"week\" === S ? d.setDate(d.getDate() + 7 * m) : \"month\" === S ? d.setMonth(d.getMonth() + 1 * m) : \"year\" === S && d.setFullYear(d.getFullYear() + 1 * m);\n    return d;\n  }\n\n  function da(d, m) {\n    var S = !1;\n    0 > d && (S = !0, d *= -1);\n    d = \"\" + d;\n\n    for (m = m ? m : 1; d.length < m;) d = \"0\" + d;\n\n    return S ? \"-\" + d : d;\n  }\n\n  function Ga(d) {\n    if (!d) return d;\n    d = d.replace(/^\\s\\s*/, \"\");\n\n    for (var m = /\\s/, S = d.length; m.test(d.charAt(--S)););\n\n    return d.slice(0, S + 1);\n  }\n\n  function za(d) {\n    d.roundRect = function (d, S, n, v, ra, C, t, A) {\n      t && (this.fillStyle = t);\n      A && (this.strokeStyle = A);\n      \"undefined\" === typeof ra && (ra = 5);\n      this.lineWidth = C;\n      this.beginPath();\n      this.moveTo(d + ra, S);\n      this.lineTo(d + n - ra, S);\n      this.quadraticCurveTo(d + n, S, d + n, S + ra);\n      this.lineTo(d + n, S + v - ra);\n      this.quadraticCurveTo(d + n, S + v, d + n - ra, S + v);\n      this.lineTo(d + ra, S + v);\n      this.quadraticCurveTo(d, S + v, d, S + v - ra);\n      this.lineTo(d, S + ra);\n      this.quadraticCurveTo(d, S, d + ra, S);\n      this.closePath();\n      t && this.fill();\n      A && 0 < C && this.stroke();\n    };\n  }\n\n  function Sa(d, m) {\n    return d - m;\n  }\n\n  function W(d) {\n    var m = ((d & 16711680) >> 16).toString(16),\n        n = ((d & 65280) >> 8).toString(16);\n    d = ((d & 255) >> 0).toString(16);\n    m = 2 > m.length ? \"0\" + m : m;\n    n = 2 > n.length ? \"0\" + n : n;\n    d = 2 > d.length ? \"0\" + d : d;\n    return \"#\" + m + n + d;\n  }\n\n  function fb(d, m) {\n    var n = this.length >>> 0,\n        v = Number(m) || 0,\n        v = 0 > v ? Math.ceil(v) : Math.floor(v);\n\n    for (0 > v && (v += n); v < n; v++) if (v in this && this[v] === d) return v;\n\n    return -1;\n  }\n\n  function n(d) {\n    return null === d || \"undefined\" === typeof d;\n  }\n\n  function Da(d) {\n    d.indexOf || (d.indexOf = fb);\n    return d;\n  }\n\n  function gb(d) {\n    if (va.fSDec) d[ia(\"`eeDwdouMhrudods\")](ia(\"e`u`@ohl`uhnoHuds`uhnoDoe\"), function () {\n      va._fTWm && va._fTWm(d);\n    });\n  }\n\n  function Za(d, m, n) {\n    n = n || \"normal\";\n    var v = d + \"_\" + m + \"_\" + n,\n        Y = $a[v];\n\n    if (isNaN(Y)) {\n      try {\n        if (!xa) {\n          var ra = document.body;\n          xa = document.createElement(\"span\");\n          xa.innerHTML = \"\";\n          var C = document.createTextNode(\"Mpgyi\");\n          xa.appendChild(C);\n          ra.appendChild(xa);\n        }\n\n        xa.style.display = \"\";\n        O(xa, {\n          position: \"absolute\",\n          left: \"0px\",\n          top: \"-20000px\",\n          padding: \"0px\",\n          margin: \"0px\",\n          border: \"none\",\n          whiteSpace: \"pre\",\n          lineHeight: \"normal\",\n          fontFamily: d,\n          fontSize: m + \"px\",\n          fontWeight: n\n        });\n        Y = Math.round(xa.offsetHeight);\n        xa.style.display = \"none\";\n      } catch (t) {\n        Y = Math.ceil(1.1 * m);\n      }\n\n      Y = Math.max(Y, m);\n      $a[v] = Y;\n    }\n\n    return Y;\n  }\n\n  function G(d, m) {\n    var n = [];\n    if (n = {\n      solid: [],\n      shortDash: [3, 1],\n      shortDot: [1, 1],\n      shortDashDot: [3, 1, 1, 1],\n      shortDashDotDot: [3, 1, 1, 1, 1, 1],\n      dot: [1, 2],\n      dash: [4, 2],\n      dashDot: [4, 2, 1, 2],\n      longDash: [8, 2],\n      longDashDot: [8, 2, 1, 2],\n      longDashDotDot: [8, 2, 1, 2, 1, 2]\n    }[d || \"solid\"]) for (var v = 0; v < n.length; v++) n[v] *= m;else n = [];\n    return n;\n  }\n\n  function H(d, m, S, v, Y) {\n    v = v || [];\n    Y = n(Y) ? hb ? {\n      passive: !1,\n      capture: !1\n    } : !1 : Y;\n    v.push([d, m, S, Y]);\n    return d.addEventListener ? (d.addEventListener(m, S, Y), S) : d.attachEvent ? (v = function (m) {\n      m = m || window.event;\n\n      m.preventDefault = m.preventDefault || function () {\n        m.returnValue = !1;\n      };\n\n      m.stopPropagation = m.stopPropagation || function () {\n        m.cancelBubble = !0;\n      };\n\n      S.call(d, m);\n    }, d.attachEvent(\"on\" + m, v), v) : !1;\n  }\n\n  function ib(d) {\n    if (d._menuButton) d.exportEnabled ? (O(d._menuButton, {\n      backgroundColor: d.toolbar.itemBackgroundColor,\n      color: d.toolbar.fontColor\n    }), La(d._menuButton), sa(d, d._menuButton, \"menu\"), 0 >= navigator.userAgent.search(\"MSIE\") && d._menuButton.childNodes[0] && O(d._menuButton.childNodes[0], {\n      WebkitFilter: \"invert(0%)\",\n      filter: \"invert(0%)\"\n    })) : wa(d._menuButton);else if (d.exportEnabled && v) {\n      var m = !1;\n      d._menuButton = document.createElement(\"button\");\n      sa(d, d._menuButton, \"menu\");\n\n      d._toolBar.appendChild(d._menuButton);\n\n      H(d._menuButton, \"touchstart\", function (d) {\n        m = !0;\n      }, d.allDOMEventHandlers);\n      H(d._menuButton, \"click\", function () {\n        \"none\" !== d._dropdownMenu.style.display || d._dropDownCloseTime && 500 >= new Date().getTime() - d._dropDownCloseTime.getTime() || (d._dropdownMenu.style.display = \"block\", d._menuButton.blur(), d._dropdownMenu.focus());\n      }, d.allDOMEventHandlers, !0);\n      H(d._menuButton, \"mousemove\", function () {\n        m || (O(d._menuButton, {\n          backgroundColor: d.toolbar.itemBackgroundColorOnHover,\n          color: d.toolbar.fontColorOnHover\n        }), 0 >= navigator.userAgent.search(\"MSIE\") && O(d._menuButton.childNodes[0], {\n          WebkitFilter: \"invert(100%)\",\n          filter: \"invert(100%)\"\n        }));\n      }, d.allDOMEventHandlers, !0);\n      H(d._menuButton, \"mouseout\", function () {\n        m || (O(d._menuButton, {\n          backgroundColor: d.toolbar.itemBackgroundColor,\n          color: d.toolbar.fontColor\n        }), 0 >= navigator.userAgent.search(\"MSIE\") && O(d._menuButton.childNodes[0], {\n          WebkitFilter: \"invert(0%)\",\n          filter: \"invert(0%)\"\n        }));\n      }, d.allDOMEventHandlers, !0);\n    }\n\n    if (d.exportEnabled && d._dropdownMenu) {\n      var n = d.theme && -1 !== d.theme.indexOf(\"dark\") ? \"black\" : \"#888888\";\n      O(d._dropdownMenu, {\n        backgroundColor: d.toolbar.itemBackgroundColor,\n        color: d.toolbar.fontColor,\n        boxShadow: \"2px 2px 10px \" + n\n      });\n\n      for (var n = d._dropdownMenu.childNodes, N = [d._cultureInfo.printText, d._cultureInfo.saveJPGText, d._cultureInfo.savePNGText], Y = 0; Y < N.length; Y++) O(n[Y], {\n        backgroundColor: d.toolbar.itemBackgroundColor,\n        color: d.toolbar.fontColor\n      }), n[Y].innerHTML = N[Y];\n    } else !d._dropdownMenu && d.exportEnabled && v && (m = !1, d._dropdownMenu = document.createElement(\"div\"), d._dropdownMenu.setAttribute(\"tabindex\", -1), n = d.theme && -1 !== d.theme.indexOf(\"dark\") ? \"black\" : \"#888888\", O(d._dropdownMenu, {\n      position: \"absolute\",\n      zIndex: 1,\n      userSelect: \"none\",\n      MozUserSeelct: \"none\",\n      WebkitUserSelect: \"none\",\n      msUserSelect: \"none\",\n      cursor: \"pointer\",\n      right: \"0px\",\n      top: \"25px\",\n      minWidth: \"120px\",\n      outline: 0,\n      fontSize: \"14px\",\n      fontFamily: \"Arial, Helvetica, sans-serif\",\n      padding: \"5px 0px 5px 0px\",\n      textAlign: \"left\",\n      lineHeight: \"10px\",\n      backgroundColor: d.toolbar.itemBackgroundColor,\n      boxShadow: \"2px 2px 10px \" + n\n    }), d._dropdownMenu.style.display = \"none\", d._toolBar.appendChild(d._dropdownMenu), H(d._dropdownMenu, \"blur\", function () {\n      wa(d._dropdownMenu);\n      d._dropDownCloseTime = new Date();\n    }, d.allDOMEventHandlers, !0), n = document.createElement(\"div\"), O(n, {\n      padding: \"12px 8px 12px 8px\"\n    }), n.innerHTML = d._cultureInfo.printText, n.style.backgroundColor = d.toolbar.itemBackgroundColor, n.style.color = d.toolbar.fontColor, d._dropdownMenu.appendChild(n), H(n, \"touchstart\", function (d) {\n      m = !0;\n    }, d.allDOMEventHandlers), H(n, \"mousemove\", function () {\n      m || (this.style.backgroundColor = d.toolbar.itemBackgroundColorOnHover, this.style.color = d.toolbar.fontColorOnHover);\n    }, d.allDOMEventHandlers, !0), H(n, \"mouseout\", function () {\n      m || (this.style.backgroundColor = d.toolbar.itemBackgroundColor, this.style.color = d.toolbar.fontColor);\n    }, d.allDOMEventHandlers, !0), H(n, \"click\", function () {\n      d.print();\n      wa(d._dropdownMenu);\n    }, d.allDOMEventHandlers, !0), n = document.createElement(\"div\"), O(n, {\n      padding: \"12px 8px 12px 8px\"\n    }), n.innerHTML = d._cultureInfo.saveJPGText, n.style.backgroundColor = d.toolbar.itemBackgroundColor, n.style.color = d.toolbar.fontColor, d._dropdownMenu.appendChild(n), H(n, \"touchstart\", function (d) {\n      m = !0;\n    }, d.allDOMEventHandlers), H(n, \"mousemove\", function () {\n      m || (this.style.backgroundColor = d.toolbar.itemBackgroundColorOnHover, this.style.color = d.toolbar.fontColorOnHover);\n    }, d.allDOMEventHandlers, !0), H(n, \"mouseout\", function () {\n      m || (this.style.backgroundColor = d.toolbar.itemBackgroundColor, this.style.color = d.toolbar.fontColor);\n    }, d.allDOMEventHandlers, !0), H(n, \"click\", function () {\n      d.exportChart({\n        format: \"jpeg\",\n        fileName: d.exportFileName\n      });\n      wa(d._dropdownMenu);\n    }, d.allDOMEventHandlers, !0), n = document.createElement(\"div\"), O(n, {\n      padding: \"12px 8px 12px 8px\"\n    }), n.innerHTML = d._cultureInfo.savePNGText, n.style.backgroundColor = d.toolbar.itemBackgroundColor, n.style.color = d.toolbar.fontColor, d._dropdownMenu.appendChild(n), H(n, \"touchstart\", function (d) {\n      m = !0;\n    }, d.allDOMEventHandlers), H(n, \"mousemove\", function () {\n      m || (this.style.backgroundColor = d.toolbar.itemBackgroundColorOnHover, this.style.color = d.toolbar.fontColorOnHover);\n    }, d.allDOMEventHandlers, !0), H(n, \"mouseout\", function () {\n      m || (this.style.backgroundColor = d.toolbar.itemBackgroundColor, this.style.color = d.toolbar.fontColor);\n    }, d.allDOMEventHandlers, !0), H(n, \"click\", function () {\n      d.exportChart({\n        format: \"png\",\n        fileName: d.exportFileName\n      });\n      wa(d._dropdownMenu);\n    }, d.allDOMEventHandlers, !0));\n  }\n\n  function ab(d, m, n) {\n    d *= la;\n    m *= la;\n    d = n.getImageData(d, m, 2, 2).data;\n    m = !0;\n\n    for (n = 0; 4 > n; n++) if (d[n] !== d[n + 4] | d[n] !== d[n + 8] | d[n] !== d[n + 12]) {\n      m = !1;\n      break;\n    }\n\n    return m ? d[0] << 16 | d[1] << 8 | d[2] : 0;\n  }\n\n  function ma(d, m, n) {\n    return d in m ? m[d] : n[d];\n  }\n\n  function Ma(d, m, S, N) {\n    v && bb ? (N = !n(N) && N ? d.getContext(\"2d\", {\n      willReadFrequently: !0\n    }) : d.getContext(\"2d\"), Na = N.webkitBackingStorePixelRatio || N.mozBackingStorePixelRatio || N.msBackingStorePixelRatio || N.oBackingStorePixelRatio || N.backingStorePixelRatio || 1, la = Ta / Na, d.width = m * la, d.height = S * la, Ta !== Na && (d.style.width = m + \"px\", d.style.height = S + \"px\", N.scale(la, la))) : (d.width = m, d.height = S);\n  }\n\n  function jb(d) {\n    if (!kb) {\n      var m = !1,\n          n = !1;\n      \"undefined\" === typeof qa.Chart.creditHref ? (d.creditHref = ia(\"iuuqr;..b`ow`rkr/bnl.\"), d.creditText = ia(\"B`ow`rKR/bnl\")) : (m = d.updateOption(\"creditText\"), n = d.updateOption(\"creditHref\"));\n\n      if (d.creditHref && d.creditText) {\n        d._creditLink || (d._creditLink = document.createElement(\"a\"), d._creditLink.setAttribute(\"class\", \"canvasjs-chart-credit\"), d._creditLink.setAttribute(\"title\", \"JavaScript Charts\"), O(d._creditLink, {\n          outline: \"none\",\n          margin: \"0px\",\n          position: \"absolute\",\n          right: \"2px\",\n          top: d.height - 14 + \"px\",\n          color: \"dimgrey\",\n          textDecoration: \"none\",\n          fontSize: \"11px\",\n          fontFamily: \"Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif\"\n        }), d._creditLink.setAttribute(\"tabIndex\", -1), d._creditLink.setAttribute(\"target\", \"_blank\"));\n        if (0 === d.renderCount || m || n) d._creditLink.setAttribute(\"href\", d.creditHref), d._creditLink.innerHTML = d.creditText;\n        d._creditLink && d.creditHref && d.creditText ? (d._creditLink.parentElement || d._canvasJSContainer.appendChild(d._creditLink), d._creditLink.style.top = d.height - 14 + \"px\") : d._creditLink.parentElement && d._canvasJSContainer.removeChild(d._creditLink);\n      }\n    }\n  }\n\n  function ua(d, m, n) {\n    Ha && (this.canvasCount |= 0, window.console.log(++this.canvasCount));\n    var N = document.createElement(\"canvas\");\n    N.setAttribute(\"class\", \"canvasjs-chart-canvas\");\n    Ma(N, d, m, n);\n    v || \"undefined\" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(N);\n    return N;\n  }\n\n  function O(d, m) {\n    for (var n in m) d.style[n] = m[n];\n  }\n\n  function sa(d, m, n) {\n    m.getAttribute(\"state\") || (m.style.backgroundColor = d.toolbar.itemBackgroundColor, m.style.color = d.toolbar.fontColor, m.style.border = \"none\", O(m, {\n      WebkitUserSelect: \"none\",\n      MozUserSelect: \"none\",\n      msUserSelect: \"none\",\n      userSelect: \"none\"\n    }));\n    m.getAttribute(\"state\") !== n && (m.setAttribute(\"state\", n), m.setAttribute(\"type\", \"button\"), O(m, {\n      padding: \"5px 12px\",\n      cursor: \"pointer\",\n      \"float\": \"left\",\n      width: \"40px\",\n      height: \"25px\",\n      outline: \"0px\",\n      verticalAlign: \"baseline\",\n      lineHeight: \"0\"\n    }), m.innerHTML = \"<img src='\" + lb[n].image + \"' alt='\" + d._cultureInfo[n + \"Text\"] + \"' />\", O(m.childNodes[0], {\n      height: \"95%\",\n      pointerEvents: \"none\"\n    }));\n    m.setAttribute(\"title\", d._cultureInfo[n + \"Text\"]);\n  }\n\n  function La() {\n    for (var d = null, m = 0; m < arguments.length; m++) d = arguments[m], d.style && (d.style.display = \"inline\");\n  }\n\n  function wa() {\n    for (var d = null, m = 0; m < arguments.length; m++) (d = arguments[m]) && d.style && (d.style.display = \"none\");\n  }\n\n  function Ua(d, m, n, v, Y) {\n    if (null === d || \"undefined\" === typeof d) return \"undefined\" === typeof n ? m : n;\n    d = parseFloat(d.toString()) * (0 <= d.toString().indexOf(\"%\") ? m / 100 : 1);\n    \"undefined\" !== typeof v && (d = Math.min(v, d), \"undefined\" !== typeof Y && (d = Math.max(Y, d)));\n    return !isNaN(d) && d <= m && 0 <= d ? d : \"undefined\" === typeof n ? m : n;\n  }\n\n  function X(d, m, v, N, Y) {\n    this._defaultsKey = d;\n    this._themeOptionsKey = m;\n    this._index = N;\n    this.parent = Y;\n    this._eventListeners = [];\n    d = {};\n    this.theme && n(this.parent) && n(m) && n(N) ? d = n(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[m] && (null === N ? d = this.parent.themeOptions[m] : 0 < this.parent.themeOptions[m].length && (N = Math.min(this.parent.themeOptions[m].length - 1, N), d = this.parent.themeOptions[m][N]));\n    this.themeOptions = d;\n    this.options = v ? v : {\n      _isPlaceholder: !0\n    };\n    this.setOptions(this.options, d);\n  }\n\n  function Ea(d, m, n, v, Y) {\n    \"undefined\" === typeof Y && (Y = 0);\n    this._padding = Y;\n    this._x1 = d;\n    this._y1 = m;\n    this._x2 = n;\n    this._y2 = v;\n    this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;\n  }\n\n  function ja(d, m) {\n    ja.base.constructor.call(this, \"TextBlock\", null, m, null, null);\n    this.ctx = d;\n    this._isDirty = !0;\n    this._wrappedText = null;\n\n    this._initialize();\n  }\n\n  function Va(d, m) {\n    Va.base.constructor.call(this, \"Toolbar\", \"toolbar\", m, null, d);\n    this.chart = d;\n    this.canvas = d.canvas;\n    this.ctx = this.chart.ctx;\n    this.optionsName = \"toolbar\";\n  }\n\n  function Aa(d, m) {\n    Aa.base.constructor.call(this, \"Title\", \"title\", m, null, d);\n    this.chart = d;\n    this.canvas = d.canvas;\n    this.ctx = this.chart.ctx;\n    this.optionsName = \"title\";\n    if (n(this.options.margin) && d.options.subtitles) for (var v = d.options.subtitles, N = 0; N < v.length; N++) if ((n(v[N].horizontalAlign) && \"center\" === this.horizontalAlign || v[N].horizontalAlign === this.horizontalAlign) && (n(v[N].verticalAlign) && \"top\" === this.verticalAlign || v[N].verticalAlign === this.verticalAlign) && !v[N].dockInsidePlotArea === !this.dockInsidePlotArea) {\n      this.margin = 0;\n      break;\n    }\n    \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n    this.height = this.width = null;\n    this.bounds = {\n      x1: null,\n      y1: null,\n      x2: null,\n      y2: null\n    };\n  }\n\n  function Ia(d, m, n) {\n    Ia.base.constructor.call(this, \"Subtitle\", \"subtitles\", m, n, d);\n    this.chart = d;\n    this.canvas = d.canvas;\n    this.ctx = this.chart.ctx;\n    this.optionsName = \"subtitles\";\n    this.isOptionsInArray = !0;\n    \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n    this.height = this.width = null;\n    this.bounds = {\n      x1: null,\n      y1: null,\n      x2: null,\n      y2: null\n    };\n  }\n\n  function Wa() {\n    this.pool = [];\n  }\n\n  function Ja(d) {\n    var m;\n    d && Ka[d] && (m = Ka[d]);\n    Ja.base.constructor.call(this, \"CultureInfo\", null, m, null, null);\n  }\n\n  var Ha = !1,\n      va = {},\n      v = !!document.createElement(\"canvas\").getContext,\n      qa = {\n    Chart: {\n      width: 500,\n      height: 400,\n      zoomEnabled: !1,\n      zoomType: \"x\",\n      backgroundColor: \"white\",\n      theme: \"light1\",\n      animationEnabled: !1,\n      animationDuration: 1200,\n      dataPointWidth: null,\n      dataPointMinWidth: null,\n      dataPointMaxWidth: null,\n      colorSet: \"colorSet1\",\n      culture: \"en\",\n      creditText: \"CanvasJS\",\n      interactivityEnabled: !0,\n      exportEnabled: !1,\n      exportFileName: \"Chart\",\n      rangeChanging: null,\n      rangeChanged: null,\n      publicProperties: {\n        title: \"readWrite\",\n        subtitles: \"readWrite\",\n        toolbar: \"readWrite\",\n        toolTip: \"readWrite\",\n        legend: \"readWrite\",\n        axisX: \"readWrite\",\n        axisY: \"readWrite\",\n        axisX2: \"readWrite\",\n        axisY2: \"readWrite\",\n        data: \"readWrite\",\n        options: \"readWrite\",\n        bounds: \"readOnly\",\n        container: \"readOnly\",\n        selectedColorSet: \"readOnly\"\n      }\n    },\n    Title: {\n      padding: 0,\n      text: null,\n      verticalAlign: \"top\",\n      horizontalAlign: \"center\",\n      fontSize: 20,\n      fontFamily: \"Calibri\",\n      fontWeight: \"normal\",\n      fontColor: \"black\",\n      fontStyle: \"normal\",\n      borderThickness: 0,\n      borderColor: \"black\",\n      cornerRadius: 0,\n      backgroundColor: v ? \"transparent\" : null,\n      margin: 5,\n      wrap: !0,\n      maxWidth: null,\n      textAlign: \"center\",\n      dockInsidePlotArea: !1,\n      publicProperties: {\n        options: \"readWrite\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    Subtitle: {\n      padding: 0,\n      text: null,\n      verticalAlign: \"top\",\n      horizontalAlign: \"center\",\n      fontSize: 14,\n      fontFamily: \"Calibri\",\n      fontWeight: \"normal\",\n      fontColor: \"black\",\n      fontStyle: \"normal\",\n      borderThickness: 0,\n      borderColor: \"black\",\n      cornerRadius: 0,\n      backgroundColor: null,\n      margin: 2,\n      wrap: !0,\n      maxWidth: null,\n      textAlign: \"center\",\n      dockInsidePlotArea: !1,\n      publicProperties: {\n        options: \"readWrite\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    Toolbar: {\n      itemBackgroundColor: \"white\",\n      itemBackgroundColorOnHover: \"#2196f3\",\n      buttonBorderColor: \"#2196f3\",\n      buttonBorderThickness: 1,\n      fontColor: \"black\",\n      fontColorOnHover: \"white\",\n      publicProperties: {\n        options: \"readWrite\",\n        chart: \"readOnly\"\n      }\n    },\n    Legend: {\n      name: null,\n      verticalAlign: \"center\",\n      horizontalAlign: \"right\",\n      fontSize: 14,\n      fontFamily: \"calibri\",\n      fontWeight: \"normal\",\n      fontColor: \"black\",\n      fontStyle: \"normal\",\n      cursor: null,\n      itemmouseover: null,\n      itemmouseout: null,\n      itemmousemove: null,\n      itemclick: null,\n      dockInsidePlotArea: !1,\n      reversed: !1,\n      backgroundColor: v ? \"transparent\" : null,\n      borderColor: v ? \"transparent\" : null,\n      borderThickness: 0,\n      cornerRadius: 0,\n      maxWidth: null,\n      maxHeight: null,\n      markerMargin: null,\n      itemMaxWidth: null,\n      itemWidth: null,\n      itemWrap: !0,\n      itemTextFormatter: null,\n      publicProperties: {\n        options: \"readWrite\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    ToolTip: {\n      enabled: !0,\n      shared: !1,\n      animationEnabled: !0,\n      content: null,\n      contentFormatter: null,\n      reversed: !1,\n      backgroundColor: v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\",\n      borderColor: null,\n      borderThickness: 2,\n      cornerRadius: 5,\n      fontSize: 14,\n      fontColor: \"black\",\n      fontFamily: \"Calibri, Arial, Georgia, serif;\",\n      fontWeight: \"normal\",\n      fontStyle: \"italic\",\n      updated: null,\n      hidden: null,\n      publicProperties: {\n        options: \"readWrite\",\n        chart: \"readOnly\"\n      }\n    },\n    Axis: {\n      minimum: null,\n      maximum: null,\n      viewportMinimum: null,\n      viewportMaximum: null,\n      interval: null,\n      intervalType: null,\n      reversed: !1,\n      logarithmic: !1,\n      logarithmBase: 10,\n      title: null,\n      titleFontColor: \"black\",\n      titleFontSize: 20,\n      titleFontFamily: \"arial\",\n      titleFontWeight: \"normal\",\n      titleFontStyle: \"normal\",\n      titleWrap: !0,\n      titleMaxWidth: null,\n      titleBackgroundColor: v ? \"transparent\" : null,\n      titleBorderColor: v ? \"transparent\" : null,\n      titleBorderThickness: 0,\n      titleCornerRadius: 0,\n      titleTextAlign: \"left\",\n      labelAngle: 0,\n      labelFontFamily: \"arial\",\n      labelFontColor: \"black\",\n      labelFontSize: 12,\n      labelFontWeight: \"normal\",\n      labelFontStyle: \"normal\",\n      labelAutoFit: !0,\n      labelWrap: !0,\n      labelMaxWidth: null,\n      labelFormatter: null,\n      labelBackgroundColor: v ? \"transparent\" : null,\n      labelBorderColor: v ? \"transparent\" : null,\n      labelBorderThickness: 0,\n      labelCornerRadius: 0,\n      labelPlacement: \"outside\",\n      labelTextAlign: \"left\",\n      prefix: \"\",\n      suffix: \"\",\n      includeZero: !1,\n      tickLength: 5,\n      tickColor: \"black\",\n      tickThickness: 1,\n      tickPlacement: \"outside\",\n      lineColor: \"black\",\n      lineThickness: 1,\n      lineDashType: \"solid\",\n      gridColor: \"#A0A0A0\",\n      gridThickness: 0,\n      gridDashType: \"solid\",\n      interlacedColor: v ? \"transparent\" : null,\n      valueFormatString: null,\n      margin: 2,\n      publicProperties: {\n        options: \"readWrite\",\n        stripLines: \"readWrite\",\n        scaleBreaks: \"readWrite\",\n        crosshair: \"readWrite\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    StripLine: {\n      value: null,\n      startValue: null,\n      endValue: null,\n      color: \"orange\",\n      opacity: null,\n      thickness: 2,\n      lineDashType: \"solid\",\n      label: \"\",\n      labelPlacement: \"inside\",\n      labelAlign: \"far\",\n      labelWrap: !0,\n      labelMaxWidth: null,\n      labelBackgroundColor: null,\n      labelBorderColor: v ? \"transparent\" : null,\n      labelBorderThickness: 0,\n      labelCornerRadius: 0,\n      labelFontFamily: \"arial\",\n      labelFontColor: \"orange\",\n      labelFontSize: 12,\n      labelFontWeight: \"normal\",\n      labelFontStyle: \"normal\",\n      labelFormatter: null,\n      labelTextAlign: \"left\",\n      showOnTop: !1,\n      publicProperties: {\n        options: \"readWrite\",\n        axis: \"readOnly\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    ScaleBreaks: {\n      autoCalculate: !1,\n      collapsibleThreshold: \"25%\",\n      maxNumberOfAutoBreaks: 2,\n      spacing: 8,\n      type: \"straight\",\n      color: \"#FFFFFF\",\n      fillOpacity: 0.9,\n      lineThickness: 2,\n      lineColor: \"#E16E6E\",\n      lineDashType: \"solid\",\n      publicProperties: {\n        options: \"readWrite\",\n        customBreaks: \"readWrite\",\n        axis: \"readOnly\",\n        autoBreaks: \"readOnly\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    Break: {\n      startValue: null,\n      endValue: null,\n      spacing: 8,\n      type: \"straight\",\n      color: \"#FFFFFF\",\n      fillOpacity: 0.9,\n      lineThickness: 2,\n      lineColor: \"#E16E6E\",\n      lineDashType: \"solid\",\n      publicProperties: {\n        options: \"readWrite\",\n        scaleBreaks: \"readOnly\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    Crosshair: {\n      enabled: !1,\n      snapToDataPoint: !1,\n      color: \"grey\",\n      opacity: null,\n      thickness: 2,\n      lineDashType: \"solid\",\n      label: \"\",\n      labelWrap: !0,\n      labelMaxWidth: null,\n      labelTextAlign: \"left\",\n      labelBackgroundColor: v ? \"grey\" : null,\n      labelBorderColor: v ? \"grey\" : null,\n      labelBorderThickness: 0,\n      labelCornerRadius: 0,\n      labelFontFamily: v ? \"Calibri, Optima, Candara, Verdana, Geneva, sans-serif\" : \"calibri\",\n      labelFontSize: 12,\n      labelFontColor: \"#fff\",\n      labelFontWeight: \"normal\",\n      labelFontStyle: \"normal\",\n      labelFormatter: null,\n      valueFormatString: null,\n      updated: null,\n      hidden: null,\n      publicProperties: {\n        options: \"readWrite\",\n        axis: \"readOnly\",\n        bounds: \"readOnly\",\n        chart: \"readOnly\"\n      }\n    },\n    DataSeries: {\n      name: null,\n      dataPoints: null,\n      label: \"\",\n      bevelEnabled: !1,\n      highlightEnabled: !0,\n      cursor: \"default\",\n      indexLabel: \"\",\n      indexLabelPlacement: \"auto\",\n      indexLabelOrientation: \"horizontal\",\n      indexLabelTextAlign: \"left\",\n      indexLabelFontColor: \"black\",\n      indexLabelFontSize: 12,\n      indexLabelFontStyle: \"normal\",\n      indexLabelFontFamily: \"Arial\",\n      indexLabelFontWeight: \"normal\",\n      indexLabelBackgroundColor: null,\n      indexLabelLineColor: \"gray\",\n      indexLabelLineThickness: 1,\n      indexLabelLineDashType: \"solid\",\n      indexLabelMaxWidth: null,\n      indexLabelWrap: !0,\n      indexLabelFormatter: null,\n      lineThickness: 2,\n      lineDashType: \"solid\",\n      connectNullData: !1,\n      nullDataLineDashType: \"dash\",\n      color: null,\n      lineColor: null,\n      risingColor: \"white\",\n      fallingColor: \"red\",\n      fillOpacity: null,\n      startAngle: 0,\n      radius: null,\n      innerRadius: null,\n      explodeOnClick: !0,\n      neckHeight: null,\n      neckWidth: null,\n      reversed: !1,\n      valueRepresents: null,\n      linkedDataSeriesIndex: null,\n      whiskerThickness: 2,\n      whiskerDashType: \"solid\",\n      whiskerColor: null,\n      whiskerLength: null,\n      stemThickness: 2,\n      stemColor: null,\n      stemDashType: \"solid\",\n      upperBoxColor: \"white\",\n      lowerBoxColor: \"white\",\n      type: \"column\",\n      xValueType: \"number\",\n      axisXType: \"primary\",\n      axisYType: \"primary\",\n      axisXIndex: 0,\n      axisYIndex: 0,\n      xValueFormatString: null,\n      yValueFormatString: null,\n      zValueFormatString: null,\n      percentFormatString: null,\n      showInLegend: !1,\n      legendMarkerType: null,\n      legendMarkerColor: null,\n      legendText: null,\n      legendMarkerBorderColor: v ? \"transparent\" : null,\n      legendMarkerBorderThickness: 0,\n      markerType: \"circle\",\n      markerColor: null,\n      markerSize: null,\n      markerBorderColor: v ? \"transparent\" : null,\n      markerBorderThickness: 0,\n      mouseover: null,\n      mouseout: null,\n      mousemove: null,\n      click: null,\n      toolTipContent: null,\n      visible: !0,\n      publicProperties: {\n        options: \"readWrite\",\n        axisX: \"readWrite\",\n        axisY: \"readWrite\",\n        chart: \"readOnly\"\n      }\n    },\n    TextBlock: {\n      x: 0,\n      y: 0,\n      width: null,\n      height: null,\n      maxWidth: null,\n      maxHeight: null,\n      padding: 0,\n      angle: 0,\n      text: \"\",\n      horizontalAlign: \"center\",\n      textAlign: \"left\",\n      fontSize: 12,\n      fontFamily: \"calibri\",\n      fontWeight: \"normal\",\n      fontColor: \"black\",\n      fontStyle: \"normal\",\n      borderThickness: 0,\n      borderColor: \"black\",\n      cornerRadius: 0,\n      backgroundColor: null,\n      textBaseline: \"top\"\n    },\n    CultureInfo: {\n      decimalSeparator: \".\",\n      digitGroupSeparator: \",\",\n      zoomText: \"Zoom\",\n      panText: \"Pan\",\n      resetText: \"Reset\",\n      menuText: \"More Options\",\n      saveJPGText: \"Save as JPEG\",\n      savePNGText: \"Save as PNG\",\n      printText: \"Print\",\n      days: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n      shortDays: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),\n      months: \"January February March April May June July August September October November December\".split(\" \"),\n      shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \")\n    }\n  },\n      Ka = {\n    en: {}\n  },\n      t = v ? \"Trebuchet MS, Helvetica, sans-serif\" : \"Arial\",\n      Fa = v ? \"Impact, Charcoal, sans-serif\" : \"Arial\",\n      Ba = {\n    colorSet1: \"#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566\".split(\" \"),\n    colorSet2: \"#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C\".split(\" \"),\n    colorSet3: \"#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970\".split(\" \")\n  },\n      P,\n      ca,\n      U,\n      ha,\n      $;\n  ca = \"#333333\";\n  U = \"#000000\";\n  P = \"#666666\";\n  $ = ha = \"#000000\";\n  var ea = 20,\n      A = 14,\n      Xa = {\n    colorSet: \"colorSet1\",\n    backgroundColor: \"#FFFFFF\",\n    title: {\n      fontFamily: Fa,\n      fontSize: 32,\n      fontColor: ca,\n      fontWeight: \"normal\",\n      verticalAlign: \"top\",\n      margin: 5\n    },\n    subtitles: [{\n      fontFamily: Fa,\n      fontSize: A,\n      fontColor: ca,\n      fontWeight: \"normal\",\n      verticalAlign: \"top\",\n      margin: 5\n    }],\n    data: [{\n      indexLabelFontFamily: t,\n      indexLabelFontSize: A,\n      indexLabelFontColor: ca,\n      indexLabelFontWeight: \"normal\",\n      indexLabelLineThickness: 1\n    }],\n    axisX: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: ca,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 0,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    axisX2: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: ca,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 0,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    axisY: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: ca,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 1,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    axisY2: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: ca,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 1,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    legend: {\n      fontFamily: t,\n      fontSize: 14,\n      fontColor: ca,\n      fontWeight: \"bold\",\n      verticalAlign: \"bottom\",\n      horizontalAlign: \"center\"\n    },\n    toolTip: {\n      fontFamily: t,\n      fontSize: 14,\n      fontStyle: \"normal\",\n      cornerRadius: 0,\n      borderThickness: 1\n    },\n    toolbar: {\n      itemBackgroundColor: \"white\",\n      itemBackgroundColorOnHover: \"#2196f3\",\n      buttonBorderColor: \"#2196f3\",\n      buttonBorderThickness: 1,\n      fontColor: \"black\",\n      fontColorOnHover: \"white\"\n    }\n  };\n  U = ca = \"#F5F5F5\";\n  P = \"#FFFFFF\";\n  ha = \"#40BAF1\";\n  $ = \"#F5F5F5\";\n  var ea = 20,\n      A = 14,\n      cb = {\n    colorSet: \"colorSet2\",\n    title: {\n      fontFamily: t,\n      fontSize: 33,\n      fontColor: \"#3A3A3A\",\n      fontWeight: \"bold\",\n      verticalAlign: \"top\",\n      margin: 5\n    },\n    subtitles: [{\n      fontFamily: t,\n      fontSize: A,\n      fontColor: \"#3A3A3A\",\n      fontWeight: \"normal\",\n      verticalAlign: \"top\",\n      margin: 5\n    }],\n    data: [{\n      indexLabelFontFamily: t,\n      indexLabelFontSize: A,\n      indexLabelFontColor: \"#666666\",\n      indexLabelFontWeight: \"normal\",\n      indexLabelLineThickness: 1\n    }],\n    axisX: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: \"#666666\",\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: \"#666666\",\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: \"#BBBBBB\",\n      tickThickness: 1,\n      tickColor: \"#BBBBBB\",\n      gridThickness: 1,\n      gridColor: \"#BBBBBB\",\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FFA500\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FFA500\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: \"black\",\n        color: \"black\",\n        thickness: 1,\n        lineDashType: \"dot\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    axisX2: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: \"#666666\",\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: \"#666666\",\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: \"#BBBBBB\",\n      tickColor: \"#BBBBBB\",\n      tickThickness: 1,\n      gridThickness: 1,\n      gridColor: \"#BBBBBB\",\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FFA500\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FFA500\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: \"black\",\n        color: \"black\",\n        thickness: 1,\n        lineDashType: \"dot\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    axisY: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: \"#666666\",\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: \"#666666\",\n      labelFontWeight: \"normal\",\n      lineThickness: 0,\n      lineColor: \"#BBBBBB\",\n      tickColor: \"#BBBBBB\",\n      tickThickness: 1,\n      gridThickness: 1,\n      gridColor: \"#BBBBBB\",\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FFA500\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FFA500\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: \"black\",\n        color: \"black\",\n        thickness: 1,\n        lineDashType: \"dot\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    axisY2: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: \"#666666\",\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: \"#666666\",\n      labelFontWeight: \"normal\",\n      lineThickness: 0,\n      lineColor: \"#BBBBBB\",\n      tickColor: \"#BBBBBB\",\n      tickThickness: 1,\n      gridThickness: 1,\n      gridColor: \"#BBBBBB\",\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FFA500\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FFA500\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#EEEEEE\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: \"black\",\n        color: \"black\",\n        thickness: 1,\n        lineDashType: \"dot\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#BBBBBB\",\n        lineThickness: 1,\n        lineDashType: \"solid\"\n      }\n    }],\n    legend: {\n      fontFamily: t,\n      fontSize: 14,\n      fontColor: \"#3A3A3A\",\n      fontWeight: \"bold\",\n      verticalAlign: \"bottom\",\n      horizontalAlign: \"center\"\n    },\n    toolTip: {\n      fontFamily: t,\n      fontSize: 14,\n      fontStyle: \"normal\",\n      cornerRadius: 0,\n      borderThickness: 1\n    },\n    toolbar: {\n      itemBackgroundColor: \"white\",\n      itemBackgroundColorOnHover: \"#2196f3\",\n      buttonBorderColor: \"#2196f3\",\n      buttonBorderThickness: 1,\n      fontColor: \"black\",\n      fontColorOnHover: \"white\"\n    }\n  };\n  U = ca = \"#F5F5F5\";\n  P = \"#FFFFFF\";\n  ha = \"#40BAF1\";\n  $ = \"#F5F5F5\";\n  ea = 20;\n  A = 14;\n  Fa = {\n    colorSet: \"colorSet1\",\n    backgroundColor: \"#2A2A2A\",\n    title: {\n      fontFamily: Fa,\n      fontSize: 32,\n      fontColor: ca,\n      fontWeight: \"normal\",\n      verticalAlign: \"top\",\n      margin: 5\n    },\n    subtitles: [{\n      fontFamily: Fa,\n      fontSize: A,\n      fontColor: ca,\n      fontWeight: \"normal\",\n      verticalAlign: \"top\",\n      margin: 5\n    }],\n    toolbar: {\n      itemBackgroundColor: \"#666666\",\n      itemBackgroundColorOnHover: \"#FF7372\",\n      buttonBorderColor: \"#FF7372\",\n      buttonBorderThickness: 1,\n      fontColor: \"#F5F5F5\",\n      fontColorOnHover: \"#F5F5F5\"\n    },\n    data: [{\n      indexLabelFontFamily: t,\n      indexLabelFontSize: A,\n      indexLabelFontColor: U,\n      indexLabelFontWeight: \"normal\",\n      indexLabelLineThickness: 1\n    }],\n    axisX: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: U,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 0,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#000000\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#777777\",\n        lineThickness: 1,\n        lineDashType: \"solid\",\n        color: \"#111111\"\n      }\n    }],\n    axisX2: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: U,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 0,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#000000\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#777777\",\n        lineThickness: 1,\n        lineDashType: \"solid\",\n        color: \"#111111\"\n      }\n    }],\n    axisY: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: U,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 1,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#000000\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#777777\",\n        lineThickness: 1,\n        lineDashType: \"solid\",\n        color: \"#111111\"\n      }\n    }],\n    axisY2: [{\n      titleFontFamily: t,\n      titleFontSize: ea,\n      titleFontColor: U,\n      titleFontWeight: \"normal\",\n      labelFontFamily: t,\n      labelFontSize: A,\n      labelFontColor: U,\n      labelFontWeight: \"normal\",\n      lineThickness: 1,\n      lineColor: P,\n      tickThickness: 1,\n      tickColor: P,\n      gridThickness: 1,\n      gridColor: P,\n      stripLines: [{\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#FF7300\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: null,\n        color: \"#FF7300\",\n        thickness: 1\n      }],\n      crosshair: {\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: \"#000000\",\n        labelFontWeight: \"normal\",\n        labelBackgroundColor: $,\n        color: ha,\n        thickness: 1,\n        lineDashType: \"dash\"\n      },\n      scaleBreaks: {\n        type: \"zigzag\",\n        spacing: \"2%\",\n        lineColor: \"#777777\",\n        lineThickness: 1,\n        lineDashType: \"solid\",\n        color: \"#111111\"\n      }\n    }],\n    legend: {\n      fontFamily: t,\n      fontSize: 14,\n      fontColor: ca,\n      fontWeight: \"bold\",\n      verticalAlign: \"bottom\",\n      horizontalAlign: \"center\"\n    },\n    toolTip: {\n      fontFamily: t,\n      fontSize: 14,\n      fontStyle: \"normal\",\n      cornerRadius: 0,\n      borderThickness: 1,\n      fontColor: U,\n      backgroundColor: \"rgba(0, 0, 0, .7)\"\n    }\n  };\n  P = \"#FFFFFF\";\n  U = ca = \"#FAFAFA\";\n  ha = \"#40BAF1\";\n  $ = \"#F5F5F5\";\n  var ea = 20,\n      A = 14,\n      Oa = {\n    light1: Xa,\n    light2: cb,\n    dark1: Fa,\n    dark2: {\n      colorSet: \"colorSet2\",\n      backgroundColor: \"#32373A\",\n      title: {\n        fontFamily: t,\n        fontSize: 32,\n        fontColor: ca,\n        fontWeight: \"normal\",\n        verticalAlign: \"top\",\n        margin: 5\n      },\n      subtitles: [{\n        fontFamily: t,\n        fontSize: A,\n        fontColor: ca,\n        fontWeight: \"normal\",\n        verticalAlign: \"top\",\n        margin: 5\n      }],\n      toolbar: {\n        itemBackgroundColor: \"#666666\",\n        itemBackgroundColorOnHover: \"#FF7372\",\n        buttonBorderColor: \"#FF7372\",\n        buttonBorderThickness: 1,\n        fontColor: \"#F5F5F5\",\n        fontColorOnHover: \"#F5F5F5\"\n      },\n      data: [{\n        indexLabelFontFamily: t,\n        indexLabelFontSize: A,\n        indexLabelFontColor: U,\n        indexLabelFontWeight: \"normal\",\n        indexLabelLineThickness: 1\n      }],\n      axisX: [{\n        titleFontFamily: t,\n        titleFontSize: ea,\n        titleFontColor: U,\n        titleFontWeight: \"normal\",\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: U,\n        labelFontWeight: \"normal\",\n        lineThickness: 1,\n        lineColor: P,\n        tickThickness: 1,\n        tickColor: P,\n        gridThickness: 0,\n        gridColor: P,\n        stripLines: [{\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#FF7300\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: null,\n          color: \"#FF7300\",\n          thickness: 1\n        }],\n        crosshair: {\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#000000\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: $,\n          color: ha,\n          thickness: 1,\n          lineDashType: \"dash\"\n        },\n        scaleBreaks: {\n          type: \"zigzag\",\n          spacing: \"2%\",\n          lineColor: \"#777777\",\n          lineThickness: 1,\n          lineDashType: \"solid\",\n          color: \"#111111\"\n        }\n      }],\n      axisX2: [{\n        titleFontFamily: t,\n        titleFontSize: ea,\n        titleFontColor: U,\n        titleFontWeight: \"normal\",\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: U,\n        labelFontWeight: \"normal\",\n        lineThickness: 1,\n        lineColor: P,\n        tickThickness: 1,\n        tickColor: P,\n        gridThickness: 0,\n        gridColor: P,\n        stripLines: [{\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#FF7300\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: null,\n          color: \"#FF7300\",\n          thickness: 1\n        }],\n        crosshair: {\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#000000\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: $,\n          color: ha,\n          thickness: 1,\n          lineDashType: \"dash\"\n        },\n        scaleBreaks: {\n          type: \"zigzag\",\n          spacing: \"2%\",\n          lineColor: \"#777777\",\n          lineThickness: 1,\n          lineDashType: \"solid\",\n          color: \"#111111\"\n        }\n      }],\n      axisY: [{\n        titleFontFamily: t,\n        titleFontSize: ea,\n        titleFontColor: U,\n        titleFontWeight: \"normal\",\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: U,\n        labelFontWeight: \"normal\",\n        lineThickness: 0,\n        lineColor: P,\n        tickThickness: 1,\n        tickColor: P,\n        gridThickness: 1,\n        gridColor: P,\n        stripLines: [{\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#FF7300\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: null,\n          color: \"#FF7300\",\n          thickness: 1\n        }],\n        crosshair: {\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#000000\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: $,\n          color: ha,\n          thickness: 1,\n          lineDashType: \"dash\"\n        },\n        scaleBreaks: {\n          type: \"zigzag\",\n          spacing: \"2%\",\n          lineColor: \"#777777\",\n          lineThickness: 1,\n          lineDashType: \"solid\",\n          color: \"#111111\"\n        }\n      }],\n      axisY2: [{\n        titleFontFamily: t,\n        titleFontSize: ea,\n        titleFontColor: U,\n        titleFontWeight: \"normal\",\n        labelFontFamily: t,\n        labelFontSize: A,\n        labelFontColor: U,\n        labelFontWeight: \"normal\",\n        lineThickness: 0,\n        lineColor: P,\n        tickThickness: 1,\n        tickColor: P,\n        gridThickness: 1,\n        gridColor: P,\n        stripLines: [{\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#FF7300\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: null,\n          color: \"#FF7300\",\n          thickness: 1\n        }],\n        crosshair: {\n          labelFontFamily: t,\n          labelFontSize: A,\n          labelFontColor: \"#000000\",\n          labelFontWeight: \"normal\",\n          labelBackgroundColor: $,\n          color: ha,\n          thickness: 1,\n          lineDashType: \"dash\"\n        },\n        scaleBreaks: {\n          type: \"zigzag\",\n          spacing: \"2%\",\n          lineColor: \"#777777\",\n          lineThickness: 1,\n          lineDashType: \"solid\",\n          color: \"#111111\"\n        }\n      }],\n      legend: {\n        fontFamily: t,\n        fontSize: 14,\n        fontColor: ca,\n        fontWeight: \"bold\",\n        verticalAlign: \"bottom\",\n        horizontalAlign: \"center\"\n      },\n      toolTip: {\n        fontFamily: t,\n        fontSize: 14,\n        fontStyle: \"normal\",\n        cornerRadius: 0,\n        borderThickness: 1,\n        fontColor: U,\n        backgroundColor: \"rgba(0, 0, 0, .7)\"\n      }\n    },\n    theme1: Xa,\n    theme2: cb,\n    theme3: Xa\n  },\n      L = {\n    numberDuration: 1,\n    yearDuration: 314496E5,\n    monthDuration: 2592E6,\n    weekDuration: 6048E5,\n    dayDuration: 864E5,\n    hourDuration: 36E5,\n    minuteDuration: 6E4,\n    secondDuration: 1E3,\n    millisecondDuration: 1,\n    dayOfWeekFromInt: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \")\n  };\n\n  (function () {\n    va.fSDec = function (d) {\n      for (var m = \"\", n = 0; n < d.length; n++) m += String.fromCharCode(Math.ceil(d.length / 57 / 5) ^ d.charCodeAt(n));\n\n      return m;\n    };\n\n    delete qa[va.fSDec(\"Bi`su\")][va.fSDec(\"bsdehuIsdg\")];\n    va.pro = {\n      sCH: qa[va.fSDec(\"Bi`su\")][va.fSDec(\"bsdehuIsdg\")]\n    };\n  })();\n\n  var hb = function () {\n    var d = !1;\n\n    try {\n      var m = Object.defineProperty && Object.defineProperty({}, \"passive\", {\n        get: function () {\n          d = !0;\n          return !1;\n        }\n      });\n      window.addEventListener && (window.addEventListener(\"test\", null, m), window.removeEventListener(\"test\", null, m));\n    } catch (n) {\n      d = !1;\n    }\n\n    return d;\n  }(),\n      $a = {},\n      xa = null,\n      mb = function () {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n    this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));\n  },\n      ya = function (d) {\n    d.width = 1;\n    d.height = 1;\n    d.getContext(\"2d\") && d.getContext(\"2d\").clearRect(0, 0, 1, 1);\n  },\n      nb = function (d, m, n) {\n    m = Math.min(this.width, this.height);\n    return Math.max(\"theme4\" === this.theme ? 0 : 300 <= m ? 12 : 11, Math.round(m * (d / 400)));\n  },\n      Ca = function () {\n    var d = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|\"[^\"]*\"|'[^']*'/g,\n        m = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        n = \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),\n        v = \"January February March April May June July August September October November December\".split(\" \"),\n        Y = \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        t = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n        C = /[^-+\\dA-Z]/g;\n    return function (A, G, Q) {\n      var P = Q ? Q.days : m,\n          W = Q ? Q.months : v,\n          H = Q ? Q.shortDays : n,\n          L = Q ? Q.shortMonths : Y;\n      Q = \"\";\n      var O = !1;\n      A = A && A.getTime ? A : A ? new Date(A) : new Date();\n      if (isNaN(A)) throw SyntaxError(\"invalid date\");\n      \"UTC:\" === G.slice(0, 4) && (G = G.slice(4), O = !0);\n      Q = O ? \"getUTC\" : \"get\";\n      var X = A[Q + \"Date\"](),\n          K = A[Q + \"Day\"](),\n          V = A[Q + \"Month\"](),\n          a = A[Q + \"FullYear\"](),\n          e = A[Q + \"Hours\"](),\n          c = A[Q + \"Minutes\"](),\n          b = A[Q + \"Seconds\"](),\n          f = A[Q + \"Milliseconds\"](),\n          h = O ? 0 : A.getTimezoneOffset();\n      return Q = G.replace(d, function (r) {\n        switch (r) {\n          case \"D\":\n            return X;\n\n          case \"DD\":\n            return da(X, 2);\n\n          case \"DDD\":\n            return H[K];\n\n          case \"DDDD\":\n            return P[K];\n\n          case \"M\":\n            return V + 1;\n\n          case \"MM\":\n            return da(V + 1, 2);\n\n          case \"MMM\":\n            return L[V];\n\n          case \"MMMM\":\n            return W[V];\n\n          case \"Y\":\n            return parseInt(String(a).slice(-2));\n\n          case \"YY\":\n            return da(String(a).slice(-2), 2);\n\n          case \"YYY\":\n            return da(String(a).slice(-3), 3);\n\n          case \"YYYY\":\n            return da(a, 4);\n\n          case \"h\":\n            return e % 12 || 12;\n\n          case \"hh\":\n            return da(e % 12 || 12, 2);\n\n          case \"H\":\n            return e;\n\n          case \"HH\":\n            return da(e, 2);\n\n          case \"m\":\n            return c;\n\n          case \"mm\":\n            return da(c, 2);\n\n          case \"s\":\n            return b;\n\n          case \"ss\":\n            return da(b, 2);\n\n          case \"f\":\n            return da(String(f), 3).slice(0, 1);\n\n          case \"ff\":\n            return da(String(f), 3).slice(0, 2);\n\n          case \"fff\":\n            return da(String(f), 3).slice(0, 3);\n\n          case \"t\":\n            return 12 > e ? \"a\" : \"p\";\n\n          case \"tt\":\n            return 12 > e ? \"am\" : \"pm\";\n\n          case \"T\":\n            return 12 > e ? \"A\" : \"P\";\n\n          case \"TT\":\n            return 12 > e ? \"AM\" : \"PM\";\n\n          case \"K\":\n            return O ? \"UTC\" : (String(A).match(t) || [\"\"]).pop().replace(C, \"\");\n\n          case \"z\":\n            return (0 < h ? \"-\" : \"+\") + Math.floor(Math.abs(h) / 60);\n\n          case \"zz\":\n            return (0 < h ? \"-\" : \"+\") + da(Math.floor(Math.abs(h) / 60), 2);\n\n          case \"zzz\":\n            return (0 < h ? \"-\" : \"+\") + da(Math.floor(Math.abs(h) / 60), 2) + da(Math.abs(h) % 60, 2);\n\n          default:\n            return r.slice(1, r.length - 1);\n        }\n      });\n    };\n  }(),\n      ob = function (d) {\n    var m = 0 > d;\n\n    if (1 > Math.abs(d)) {\n      var n = parseInt(d.toString().split(\"e-\")[1]);\n      n && (d = (m ? -1 * d : d) * Math.pow(10, n - 1), d = \"0.\" + Array(n).join(\"0\") + d.toString().substring(2), d = m ? \"-\" + d : d);\n    } else n = parseInt(d.toString().split(\"+\")[1]), 20 < n && (n -= 20, d /= Math.pow(10, n), d = d.toString() + Array(n + 1).join(\"0\"));\n\n    return String(d);\n  },\n      fa = function (d, m, n) {\n    if (null === d) return \"\";\n    if (!isFinite(d)) return d;\n    d = Number(d);\n    var v = 0 > d ? !0 : !1;\n    v && (d *= -1);\n    var Y = n ? n.decimalSeparator : \".\",\n        t = n ? n.digitGroupSeparator : \",\",\n        C = \"\";\n    m = String(m);\n    var C = 1,\n        A = n = \"\",\n        G = -1,\n        Q = [],\n        P = [],\n        W = 0,\n        O = 0,\n        H = 0,\n        L = !1,\n        X = 0,\n        A = m.match(/\"[^\"]*\"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\\u2030|./g);\n    m = null;\n\n    for (var K = 0; A && K < A.length; K++) if (m = A[K], \".\" === m && 0 > G) G = K;else {\n      if (\"%\" === m) C *= 100;else if (\"\\u2030\" === m) {\n        C *= 1E3;\n        continue;\n      } else if (\",\" === m[0] && \".\" === m[m.length - 1]) {\n        C /= Math.pow(1E3, m.length - 1);\n        G = K + m.length - 1;\n        continue;\n      } else \"E\" !== m[0] && \"e\" !== m[0] || \"0\" !== m[m.length - 1] || (L = !0);\n      0 > G ? (Q.push(m), \"#\" === m || \"0\" === m ? W++ : \",\" === m && H++) : (P.push(m), \"#\" !== m && \"0\" !== m || O++);\n    }\n\n    L && (m = Math.floor(d), A = -Math.floor(Math.log(d) / Math.LN10 + 1), X = 0 === d ? 0 : 0 === m ? -(W + A) : ob(m).length - W, C /= Math.pow(10, X));\n    0 > G && (G = K);\n    C = (d * C).toFixed(O);\n    m = C.split(\".\");\n    C = (m[0] + \"\").split(\"\");\n    d = (m[1] + \"\").split(\"\");\n    C && \"0\" === C[0] && C.shift();\n\n    for (L = A = K = O = G = 0; 0 < Q.length;) if (m = Q.pop(), \"#\" === m || \"0\" === m) {\n      if (G++, G === W) {\n        var V = C,\n            C = [];\n        if (\"0\" === m) for (m = W - O - (V ? V.length : 0); 0 < m;) V.unshift(\"0\"), m--;\n\n        for (; 0 < V.length;) n = V.pop() + n, L++, 0 === L % A && K === H && 0 < V.length && (n = t + n);\n      } else 0 < C.length ? (n = C.pop() + n, O++, L++) : \"0\" === m && (n = \"0\" + n, O++, L++), 0 === L % A && K === H && 0 < C.length && (n = t + n);\n    } else \"E\" !== m[0] && \"e\" !== m[0] || \"0\" !== m[m.length - 1] || !/[eE][+-]*[0]+/.test(m) ? \",\" === m ? (K++, A = L, L = 0, 0 < C.length && (n = t + n)) : n = 1 < m.length && ('\"' === m[0] && '\"' === m[m.length - 1] || \"'\" === m[0] && \"'\" === m[m.length - 1]) ? m.slice(1, m.length - 1) + n : m + n : (m = 0 > X ? m.replace(\"+\", \"\").replace(\"-\", \"\") : m.replace(\"-\", \"\"), n += m.replace(/[0]+/, function (a) {\n      return da(X, a.length);\n    }));\n\n    t = \"\";\n\n    for (Q = !1; 0 < P.length;) m = P.shift(), \"#\" === m || \"0\" === m ? 0 < d.length && 0 !== Number(d.join(\"\")) ? (t += d.shift(), Q = !0) : \"0\" === m && (t += \"0\", Q = !0) : 1 < m.length && ('\"' === m[0] && '\"' === m[m.length - 1] || \"'\" === m[0] && \"'\" === m[m.length - 1]) ? t += m.slice(1, m.length - 1) : \"E\" !== m[0] && \"e\" !== m[0] || \"0\" !== m[m.length - 1] || !/[eE][+-]*[0]+/.test(m) ? t += m : (m = 0 > X ? m.replace(\"+\", \"\").replace(\"-\", \"\") : m.replace(\"-\", \"\"), t += m.replace(/[0]+/, function (a) {\n      return da(X, a.length);\n    }));\n\n    n += (Q ? Y : \"\") + t;\n    return v ? \"-\" + n : n;\n  },\n      Pa = function (d) {\n    var m = 0,\n        n = 0;\n    d = d || window.event;\n    d.offsetX || 0 === d.offsetX ? (m = d.offsetX, n = d.offsetY) : d.layerX || 0 == d.layerX ? (m = d.layerX, n = d.layerY) : (m = d.pageX - d.target.offsetLeft, n = d.pageY - d.target.offsetTop);\n    return {\n      x: m,\n      y: n\n    };\n  },\n      bb = !0,\n      Ta = window.devicePixelRatio || 1,\n      Na = 1,\n      la = bb ? Ta / Na : 1,\n      aa = function (d, n, v, N, t, A, C, G, L, Q, W, P, O) {\n    \"undefined\" === typeof O && (O = 1);\n    C = C || 0;\n    G = G || \"black\";\n    var H = 15 < N - n && 15 < t - v ? 8 : 0.35 * Math.min(N - n, t - v);\n    d.beginPath();\n    d.moveTo(n, v);\n    d.save();\n    d.fillStyle = A;\n    d.globalAlpha = O;\n    d.fillRect(n, v, N - n, t - v);\n    d.globalAlpha = 1;\n    0 < C && (O = 0 === C % 2 ? 0 : 0.5, d.beginPath(), d.lineWidth = C, d.strokeStyle = G, d.moveTo(n, v), d.rect(n - O, v - O, N - n + 2 * O, t - v + 2 * O), d.stroke());\n    d.restore();\n    !0 === L && (d.save(), d.beginPath(), d.moveTo(n, v), d.lineTo(n + H, v + H), d.lineTo(N - H, v + H), d.lineTo(N, v), d.closePath(), C = d.createLinearGradient((N + n) / 2, v + H, (N + n) / 2, v), C.addColorStop(0, A), C.addColorStop(1, \"rgba(255, 255, 255, .4)\"), d.fillStyle = C, d.fill(), d.restore());\n    !0 === Q && (d.save(), d.beginPath(), d.moveTo(n, t), d.lineTo(n + H, t - H), d.lineTo(N - H, t - H), d.lineTo(N, t), d.closePath(), C = d.createLinearGradient((N + n) / 2, t - H, (N + n) / 2, t), C.addColorStop(0, A), C.addColorStop(1, \"rgba(255, 255, 255, .4)\"), d.fillStyle = C, d.fill(), d.restore());\n    !0 === W && (d.save(), d.beginPath(), d.moveTo(n, v), d.lineTo(n + H, v + H), d.lineTo(n + H, t - H), d.lineTo(n, t), d.closePath(), C = d.createLinearGradient(n + H, (t + v) / 2, n, (t + v) / 2), C.addColorStop(0, A), C.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), d.fillStyle = C, d.fill(), d.restore());\n    !0 === P && (d.save(), d.beginPath(), d.moveTo(N, v), d.lineTo(N - H, v + H), d.lineTo(N - H, t - H), d.lineTo(N, t), C = d.createLinearGradient(N - H, (t + v) / 2, N, (t + v) / 2), C.addColorStop(0, A), C.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), d.fillStyle = C, C.addColorStop(0, A), C.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), d.fillStyle = C, d.fill(), d.closePath(), d.restore());\n  },\n      ia = function (d) {\n    for (var n = \"\", v = 0; v < d.length; v++) n += String.fromCharCode(Math.ceil(d.length / 57 / 5) ^ d.charCodeAt(v));\n\n    return n;\n  },\n      kb = window && window[ia(\"mnb`uhno\")] && window[ia(\"mnb`uhno\")].href && window[ia(\"mnb`uhno\")].href.indexOf && (-1 !== window[ia(\"mnb`uhno\")].href.indexOf(ia(\"b`ow`rkr/bnl\")) || -1 !== window[ia(\"mnb`uhno\")].href.indexOf(ia(\"gdonqhy/bnl\")) || -1 !== window[ia(\"mnb`uhno\")].href.indexOf(ia(\"gheemd\"))) && -1 === window[ia(\"mnb`uhno\")].href.indexOf(ia(\"gheemd\")),\n      lb = {\n    reset: {\n      image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==\"\n    },\n    pan: {\n      image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC\"\n    },\n    zoom: {\n      image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=\"\n    },\n    menu: {\n      image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC\"\n    }\n  };\n\n  X.prototype.setOptions = function (d, n) {\n    if (qa[this._defaultsKey]) {\n      var v = qa[this._defaultsKey],\n          t;\n\n      for (t in v) \"publicProperties\" !== t && v.hasOwnProperty(t) && (this[t] = d && t in d ? d[t] : n && t in n ? n[t] : v[t]);\n    } else Ha && window.console && console.log(\"defaults not set\");\n  };\n\n  X.prototype.get = function (d) {\n    var n = qa[this._defaultsKey];\n    if (\"options\" === d) return this.options && this.options._isPlaceholder ? null : this.options;\n    if (n.hasOwnProperty(d) || n.publicProperties && n.publicProperties.hasOwnProperty(d)) return this[d];\n    window.console && window.console.log('Property \"' + d + \"\\\" doesn't exist. Please check for typo.\");\n  };\n\n  X.prototype.set = function (d, n, v) {\n    v = \"undefined\" === typeof v ? !0 : v;\n    var t = qa[this._defaultsKey];\n    if (\"options\" === d) this.createUserOptions(n);else if (t.hasOwnProperty(d) || t.publicProperties && t.publicProperties.hasOwnProperty(d) && \"readWrite\" === t.publicProperties[d]) this.options._isPlaceholder && this.createUserOptions(), this.options[d] = n;else {\n      window.console && (t.publicProperties && t.publicProperties.hasOwnProperty(d) && \"readOnly\" === t.publicProperties[d] ? window.console.log('Property \"' + d + '\" is read-only.') : window.console.log('Property \"' + d + \"\\\" doesn't exist. Please check for typo.\"));\n      return;\n    }\n    v && (this.stockChart || this.chart || this).render();\n  };\n\n  X.prototype.addTo = function (d, n, v, t) {\n    t = \"undefined\" === typeof t ? !0 : t;\n    var A = qa[this._defaultsKey];\n    A.hasOwnProperty(d) || A.publicProperties && A.publicProperties.hasOwnProperty(d) && \"readWrite\" === A.publicProperties[d] ? (this.options._isPlaceholder && this.createUserOptions(), \"undefined\" === typeof this.options[d] && (this.options[d] = []), d = this.options[d], v = \"undefined\" === typeof v || null === v ? d.length : v, d.splice(v, 0, n), t && (this.stockChart || this.chart || this).render()) : window.console && (A.publicProperties && A.publicProperties.hasOwnProperty(d) && \"readOnly\" === A.publicProperties[d] ? window.console.log('Property \"' + d + '\" is read-only.') : window.console.log('Property \"' + d + \"\\\" doesn't exist. Please check for typo.\"));\n  };\n\n  X.prototype.createUserOptions = function (d) {\n    if (\"undefined\" !== typeof d || this.options._isPlaceholder) if (this.parent && this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {\n      this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);\n      var n = this.parent.options[this.optionsName],\n          v = n.length;\n      this.options._isPlaceholder || (Da(n), v = n.indexOf(this.options));\n      this.options = \"undefined\" === typeof d ? {} : d;\n      n[v] = this.options;\n    } else this.options = \"undefined\" === typeof d ? {} : d, this.parent && (d = this.parent.options, this.optionsName ? n = this.optionsName : (n = this._defaultsKey) && 0 !== n.length ? (v = n.charAt(0).toLowerCase(), 1 < n.length && (v = v.concat(n.slice(1))), n = v) : n = void 0, d[n] = this.options);\n  };\n\n  X.prototype.remove = function (d) {\n    d = \"undefined\" === typeof d ? !0 : d;\n\n    if (this.isOptionsInArray) {\n      var n = this.parent.options[this.optionsName];\n      Da(n);\n      var v = n.indexOf(this.options);\n      0 <= v && n.splice(v, 1);\n    } else delete this.parent.options[this.optionsName];\n\n    d && (this.stockChart || this.chart || this).render();\n  };\n\n  X.prototype.updateOption = function (d) {\n    !qa[this._defaultsKey] && Ha && window.console && console.log(\"defaults not set\");\n    var m = qa[this._defaultsKey],\n        v = {},\n        t = this[d],\n        A = this._themeOptionsKey,\n        G = this._index;\n    this.theme && n(this.parent) && n(A) && n(G) ? v = n(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && this.parent.themeOptions && (this.options.theme && Oa[this.options.theme] ? v = Oa[this.options.theme] : this.parent.themeOptions[A] && (null === G ? v = this.parent.themeOptions[A] : 0 < this.parent.themeOptions[A].length && (v = Math.min(this.parent.themeOptions[A].length - 1, G), v = this.parent.themeOptions[A][v])));\n    this.themeOptions = v;\n    d in m && (t = d in this.options ? this.options[d] : v && d in v ? v[d] : m[d]);\n    if (t === this[d]) return !1;\n    this[d] = t;\n    return !0;\n  };\n\n  X.prototype.trackChanges = function (d) {\n    if (!this.sessionVariables) throw \"Session Variable Store not set\";\n    this.sessionVariables[d] = this.options[d];\n  };\n\n  X.prototype.isBeingTracked = function (d) {\n    this.options._oldOptions || (this.options._oldOptions = {});\n    return this.options._oldOptions[d] ? !0 : !1;\n  };\n\n  X.prototype.hasOptionChanged = function (d) {\n    if (!this.sessionVariables) throw \"Session Variable Store not set\";\n    return this.sessionVariables[d] !== this.options[d];\n  };\n\n  X.prototype.addEventListener = function (d, n, v) {\n    d && n && (this._eventListeners[d] = this._eventListeners[d] || [], this._eventListeners[d].push({\n      context: v || this,\n      eventHandler: n\n    }));\n  };\n\n  X.prototype.removeEventListener = function (d, n) {\n    if (d && n && this._eventListeners[d]) for (var v = this._eventListeners[d], t = 0; t < v.length; t++) if (v[t].eventHandler === n) {\n      v[t].splice(t, 1);\n      break;\n    }\n  };\n\n  X.prototype.removeAllEventListeners = function () {\n    this._eventListeners = [];\n  };\n\n  X.prototype.dispatchEvent = function (d, n, v) {\n    if (d && this._eventListeners[d]) {\n      n = n || {};\n\n      for (var t = this._eventListeners[d], A = 0; A < t.length; A++) t[A].eventHandler.call(t[A].context, n);\n    }\n\n    \"function\" === typeof this[d] && this[d].call(v || this.chart, n);\n  };\n\n  Ea.prototype.registerSpace = function (d, n) {\n    \"top\" === d ? this._topOccupied += n.height : \"bottom\" === d ? this._bottomOccupied += n.height : \"left\" === d ? this._leftOccupied += n.width : \"right\" === d && (this._rightOccupied += n.width);\n  };\n\n  Ea.prototype.unRegisterSpace = function (d, n) {\n    \"top\" === d ? this._topOccupied -= n.height : \"bottom\" === d ? this._bottomOccupied -= n.height : \"left\" === d ? this._leftOccupied -= n.width : \"right\" === d && (this._rightOccupied -= n.width);\n  };\n\n  Ea.prototype.getFreeSpace = function () {\n    return {\n      x1: this._x1 + this._leftOccupied,\n      y1: this._y1 + this._topOccupied,\n      x2: this._x2 - this._rightOccupied,\n      y2: this._y2 - this._bottomOccupied,\n      width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,\n      height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied\n    };\n  };\n\n  Ea.prototype.reset = function () {\n    this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;\n  };\n\n  pa(ja, X);\n\n  ja.prototype._initialize = function () {\n    n(this.padding) || \"object\" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = n(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = n(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = n(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = n(this.padding.left) ? 0 : Number(this.padding.left) | 0);\n  };\n\n  ja.prototype.render = function (d) {\n    if (0 !== this.fontSize) {\n      d && this.ctx.save();\n      var n = this.ctx.font;\n      this.ctx.textBaseline = this.textBaseline;\n      var v = 0;\n      this._isDirty && this.measureText(this.ctx);\n      this.ctx.translate(this.x, this.y + v);\n      \"middle\" === this.textBaseline && (v = -this._lineHeight / 2);\n      this.ctx.font = this._getFontString();\n      this.ctx.rotate(Math.PI / 180 * this.angle);\n      var t = 0,\n          A = this.topPadding,\n          G = null;\n      this.ctx.roundRect || za(this.ctx);\n      (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, v, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);\n      this.ctx.fillStyle = this.fontColor;\n\n      for (v = 0; v < this._wrappedText.lines.length; v++) G = this._wrappedText.lines[v], \"right\" === this.textAlign ? t = this.width - G.width - this.rightPadding : \"left\" === this.textAlign ? t = this.leftPadding : \"center\" === this.textAlign && (t = (this.width - (this.leftPadding + this.rightPadding)) / 2 - G.width / 2 + this.leftPadding), this.ctx.fillText(G.text, t, A), A += G.height;\n\n      this.ctx.font = n;\n      d && this.ctx.restore();\n    }\n  };\n\n  ja.prototype.setText = function (d) {\n    this.text = d;\n    this._isDirty = !0;\n    this._wrappedText = null;\n  };\n\n  ja.prototype.measureText = function () {\n    this._lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);\n    if (null === this.maxWidth) throw \"Please set maxWidth and height for TextBlock\";\n\n    this._wrapText(this.ctx);\n\n    this._isDirty = !1;\n    return {\n      width: this.width,\n      height: this.height\n    };\n  };\n\n  ja.prototype._getLineWithWidth = function (d, n, v) {\n    d = String(d);\n    if (!d) return {\n      text: \"\",\n      width: 0\n    };\n    var t = v = 0,\n        A = d.length - 1,\n        G = Infinity;\n\n    for (this.ctx.font = this._getFontString(); t <= A;) {\n      var G = Math.floor((t + A) / 2),\n          C = d.substr(0, G + 1);\n      v = this.ctx.measureText(C).width;\n      if (v < n) t = G + 1;else if (v > n) A = G - 1;else break;\n    }\n\n    v > n && 1 < C.length && (C = C.substr(0, C.length - 1), v = this.ctx.measureText(C).width);\n    n = !0;\n    if (C.length === d.length || \" \" === d[C.length]) n = !1;\n    n && (d = C.split(\" \"), 1 < d.length && d.pop(), C = d.join(\" \"), v = this.ctx.measureText(C).width);\n    return {\n      text: C,\n      width: v\n    };\n  };\n\n  ja.prototype._wrapText = function () {\n    var d = new String(Ga(String(this.text))),\n        n = [],\n        v = this.ctx.font,\n        t = 0,\n        A = 0;\n    this.ctx.font = this._getFontString();\n    if (0 === this.frontSize) A = t = 0;else for (; 0 < d.length;) {\n      var G = this.maxHeight - (this.topPadding + this.bottomPadding),\n          C = this._getLineWithWidth(d, this.maxWidth - (this.leftPadding + this.rightPadding), !1);\n\n      C.height = this._lineHeight;\n      n.push(C);\n      var H = A,\n          A = Math.max(A, C.width),\n          t = t + C.height,\n          d = Ga(d.slice(C.text.length, d.length));\n      G && t > G && (C = n.pop(), t -= C.height, A = H);\n    }\n    this._wrappedText = {\n      lines: n,\n      width: A,\n      height: t\n    };\n    this.width = A + (this.leftPadding + this.rightPadding);\n    this.height = t + (this.topPadding + this.bottomPadding);\n    this.ctx.font = v;\n  };\n\n  ja.prototype._getFontString = function () {\n    var d;\n    d = \"\" + (this.fontStyle ? this.fontStyle + \" \" : \"\");\n    d += this.fontWeight ? this.fontWeight + \" \" : \"\";\n    d += this.fontSize ? this.fontSize + \"px \" : \"\";\n    var n = this.fontFamily ? this.fontFamily + \"\" : \"\";\n    !v && n && (n = n.split(\",\")[0], \"'\" !== n[0] && '\"' !== n[0] && (n = \"'\" + n + \"'\"));\n    return d += n;\n  };\n\n  pa(Va, X);\n  pa(Aa, X);\n\n  Aa.prototype.setLayout = function () {\n    if (this.text) {\n      var d = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,\n          v = d.layoutManager.getFreeSpace(),\n          t = v.x1,\n          A = v.y1,\n          G = 0,\n          H = 0,\n          C = this.chart._menuButton && this.chart.exportEnabled && \"top\" === this.verticalAlign ? 40 : 0,\n          O,\n          L;\n      this.textAlign = n(this.options.textAlign) ? this.horizontalAlign : this.textAlign;\n      \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = v.width - 4 - C * (\"center\" === this.horizontalAlign ? 2 : 1)), H = 0.5 * v.height - this.margin - 2, G = 0) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign || \"right\" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = v.height - 4), H = 0.5 * v.width - this.margin - 2) : \"center\" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = v.width - 4), H = 0.5 * v.height - 4));\n      var Q;\n      n(this.padding) || \"number\" !== typeof this.padding ? n(this.padding) || \"object\" !== typeof this.padding || (Q = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, Q += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : Q = 2 * this.padding;\n      this.wrap || (H = Math.min(H, 1.5 * this.fontSize + Q));\n      H = new ja(this.ctx, {\n        fontSize: this.fontSize,\n        fontFamily: this.fontFamily,\n        fontColor: this.fontColor,\n        fontStyle: this.fontStyle,\n        fontWeight: this.fontWeight,\n        textAlign: this.textAlign,\n        verticalAlign: this.verticalAlign,\n        borderColor: this.borderColor,\n        borderThickness: this.borderThickness,\n        backgroundColor: this.backgroundColor,\n        maxWidth: this.maxWidth,\n        maxHeight: H,\n        cornerRadius: this.cornerRadius,\n        text: this.text,\n        padding: this.padding,\n        textBaseline: \"middle\"\n      });\n      Q = H.measureText();\n      \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (\"top\" === this.verticalAlign ? (A = v.y1 + 2 + this.fontSize / 2 + 4, L = \"top\") : \"bottom\" === this.verticalAlign && (A = v.y2 - 2 - Q.height + this.fontSize / 2 + 4, L = \"bottom\"), \"left\" === this.horizontalAlign ? t = v.x1 + 2 : \"center\" === this.horizontalAlign ? t = v.x1 + v.width / 2 - Q.width / 2 : \"right\" === this.horizontalAlign && (t = v.x2 - 2 - Q.width - C), O = this.horizontalAlign, this.width = Q.width, this.height = Q.height) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign ? (t = v.x1 + 2 + (this.fontSize / 2 + 4), A = v.y2 - 2 - (this.maxWidth / 2 - Q.width / 2), G = -90, L = \"left\", this.width = Q.height, this.height = Q.width) : \"right\" === this.horizontalAlign ? (t = v.x2 - 2 - (this.fontSize / 2 + 4), A = v.y1 + 2 + (this.maxWidth / 2 - Q.width / 2), G = 90, L = \"right\", this.width = Q.height, this.height = Q.width) : \"center\" === this.horizontalAlign && (A = d.y1 + (d.height / 2 - Q.height / 2) + this.fontSize / 2 + 4, t = d.x1 + (d.width / 2 - Q.width / 2), L = \"center\", this.width = Q.width, this.height = Q.height), O = \"center\");\n      H.x = t;\n      H.y = A;\n      H.angle = G;\n      H.horizontalAlign = O;\n      this._textBlock = H;\n      d.layoutManager.registerSpace(L, {\n        width: this.width + (\"left\" === L || \"right\" === L ? this.margin + 2 : 0),\n        height: this.height + (\"top\" === L || \"bottom\" === L ? this.margin + 2 : 0)\n      });\n      this.bounds = {\n        x1: t,\n        y1: A,\n        x2: t + this.width,\n        y2: A + this.height\n      };\n      this.ctx.textBaseline = \"top\";\n    }\n  };\n\n  Aa.prototype.render = function () {\n    this._textBlock && this._textBlock.render(!0);\n  };\n\n  pa(Ia, X);\n  Ia.prototype.setLayout = Aa.prototype.setLayout;\n  Ia.prototype.render = Aa.prototype.render;\n\n  Wa.prototype.get = function (d, n) {\n    var v = null;\n    0 < this.pool.length ? (v = this.pool.pop(), Ma(v, d, n)) : v = ua(d, n);\n    return v;\n  };\n\n  Wa.prototype.release = function (d) {\n    this.pool.push(d);\n  };\n\n  pa(Ja, X);\n  var Qa = {\n    addTheme: function (d, n) {\n      Oa[d] = n;\n    },\n    addColorSet: function (d, n) {\n      Ba[d] = n;\n    },\n    addCultureInfo: function (d, n) {\n      Ka[d] = n;\n    },\n    formatNumber: function (d, n, v) {\n      v = v || \"en\";\n      if (Ka[v]) return fa(d, n || \"#,##0.##\", new Ja(v));\n      throw \"Unknown Culture Name\";\n    },\n    formatDate: function (d, n, v) {\n      v = v || \"en\";\n      if (Ka[v]) return Ca(d, n || \"DD MMM YYYY\", new Ja(v));\n      throw \"Unknown Culture Name\";\n    }\n  };\n  \"undefined\" !== typeof module && \"undefined\" !== typeof module.exports ? module.exports = Qa : \"function\" === typeof define && define.amd ? define([], function () {\n    return Qa;\n  }) : (window.CanvasJS && window.console && window.console.log(\"CanvasJS namespace already exists. If you are loading both chart and stockchart scripts, just load stockchart alone as it includes all chart features.\"), window.CanvasJS = window.CanvasJS ? window.CanvasJS : Qa);\n\n  t = Qa.Chart = function () {\n    function d(a, e) {\n      return a.x - e.x;\n    }\n\n    function m(a, e, c) {\n      e = e || {};\n      n(c) ? (this.predefinedThemes = Oa, this.optionsName = this.parent = this.index = null) : (this.parent = c.parent, this.index = c.index, this.predefinedThemes = c.predefinedThemes, this.optionsName = c.optionsName, this.stockChart = c.stockChart, this.panel = a, this.isOptionsInArray = c.isOptionsInArray);\n      this.theme = n(e.theme) || n(this.predefinedThemes[e.theme]) ? \"light1\" : e.theme;\n      m.base.constructor.call(this, \"Chart\", this.optionsName, e, this.index, this.parent);\n      var b = this;\n      this._containerId = a;\n      this._objectsInitialized = !1;\n      this.overlaidCanvasCtx = this.ctx = null;\n      this._indexLabels = [];\n      this._panTimerId = 0;\n      this._lastTouchEventType = \"\";\n      this._lastTouchData = null;\n      this.isAnimating = !1;\n      this.renderCount = 0;\n      this.disableToolTip = this.animatedRender = !1;\n      this.canvasPool = new Wa();\n      this.allDOMEventHandlers = [];\n      this.panEnabled = !1;\n      this._defaultCursor = \"default\";\n      this.plotArea = {\n        canvas: null,\n        ctx: null,\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: 0,\n        width: 0,\n        height: 0\n      };\n      this._dataInRenderedOrder = [];\n      (this.container = \"string\" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = \"\", e = a = 0, a = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, e = c && c.height ? c.height : this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.width = a, this.height = e, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this.selectedColorSet = \"undefined\" !== typeof Ba[this.colorSet] ? Ba[this.colorSet] : Ba.colorSet1, this._canvasJSContainer = document.createElement(\"div\"), this._canvasJSContainer.setAttribute(\"class\", \"canvasjs-chart-container\"), this._canvasJSContainer.style.position = \"relative\", this._canvasJSContainer.style.textAlign = \"left\", this._canvasJSContainer.style.cursor = \"auto\", this._canvasJSContainer.style.direction = \"ltr\", v || (this._canvasJSContainer.style.height = \"0px\"), this.container.appendChild(this._canvasJSContainer), this.canvas = ua(a, e), this._preRenderCanvas = ua(a, e), this.canvas.style.position = \"absolute\", this.canvas.style.WebkitUserSelect = \"none\", this.canvas.style.MozUserSelect = \"none\", this.canvas.style.msUserSelect = \"none\", this.canvas.style.userSelect = \"none\", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext(\"2d\"), this.ctx.textBaseline = \"top\", za(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\"), this._preRenderCtx.textBaseline = \"top\", za(this._preRenderCtx), v ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ua(a, e), this.plotArea.canvas.style.position = \"absolute\", this.plotArea.canvas.setAttribute(\"class\", \"plotAreaCanvas\"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext(\"2d\")), this.overlaidCanvas = ua(a, e), this.overlaidCanvas.style.position = \"absolute\", this.overlaidCanvas.style.webkitTapHighlightColor = \"transparent\", this.overlaidCanvas.style.WebkitUserSelect = \"none\", this.overlaidCanvas.style.MozUserSelect = \"none\", this.overlaidCanvas.style.msUserSelect = \"none\", this.overlaidCanvas.style.userSelect = \"none\", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext(\"2d\"), this.overlaidCanvasCtx.textBaseline = \"top\", za(this.overlaidCanvasCtx)), this._eventManager = new ha(this), this.windowResizeHandler = H(window, \"resize\", function () {\n        b._updateSize() && b.render();\n      }, this.allDOMEventHandlers), this._toolBar = document.createElement(\"div\"), this._toolBar.setAttribute(\"class\", \"canvasjs-chart-toolbar\"), O(this._toolBar, {\n        position: \"absolute\",\n        right: \"1px\",\n        top: \"1px\"\n      }), this._canvasJSContainer.appendChild(this._toolBar), this.bounds = {\n        x1: 0,\n        y1: 0,\n        x2: this.width,\n        y2: this.height\n      }, H(this.overlaidCanvas, \"click\", function (a) {\n        b._mouseEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, \"mousemove\", function (a) {\n        b._mouseEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, \"mouseup\", function (a) {\n        b._mouseEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, \"mousedown\", function (a) {\n        b._mouseEventHandler(a);\n\n        wa(b._dropdownMenu);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, \"mouseout\", function (a) {\n        b._mouseEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerDown\" : \"touchstart\", function (a) {\n        b._touchEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerMove\" : \"touchmove\", function (a) {\n        b._touchEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerUp\" : \"touchend\", function (a) {\n        b._touchEventHandler(a);\n      }, this.allDOMEventHandlers), H(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerCancel\" : \"touchcancel\", function (a) {\n        b._touchEventHandler(a);\n      }, this.allDOMEventHandlers), this.toolTip = new na(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = {\n        axisX: [],\n        axisX2: [],\n        axisY: [],\n        axisY2: []\n      })) : window.console && window.console.log('CanvasJS Error: Chart Container with id \"' + this._containerId + '\" was not found');\n    }\n\n    function t(a, e) {\n      for (var c = [], b, f = 0; f < a.length; f++) if (0 == f) c.push(a[0]);else {\n        var h, r, y;\n        y = f - 1;\n        h = 0 === y ? 0 : y - 1;\n        r = y === a.length - 1 ? y : y + 1;\n        b = Math.abs((a[r].x - a[h].x) / (0 === a[r].x - a[y].x ? 0.01 : a[r].x - a[y].x)) * (e - 1) / 2 + 1;\n        var I = (a[r].x - a[h].x) / b;\n        b = (a[r].y - a[h].y) / b;\n        c[c.length] = a[y].x > a[h].x && 0 < I || a[y].x < a[h].x && 0 > I ? {\n          x: a[y].x + I / 3,\n          y: a[y].y + b / 3\n        } : {\n          x: a[y].x,\n          y: a[y].y + (1 === c.length ? 0 : b / 9)\n        };\n        y = f;\n        h = 0 === y ? 0 : y - 1;\n        r = y === a.length - 1 ? y : y + 1;\n        b = Math.abs((a[r].x - a[h].x) / (0 === a[y].x - a[h].x ? 0.01 : a[y].x - a[h].x)) * (e - 1) / 2 + 1;\n        I = (a[r].x - a[h].x) / b;\n        b = (a[r].y - a[h].y) / b;\n        c[c.length] = a[y].x > a[h].x && 0 < I || a[y].x < a[h].x && 0 > I ? {\n          x: a[y].x - I / 3,\n          y: a[y].y - b / 3\n        } : {\n          x: a[y].x,\n          y: a[y].y - b / 9\n        };\n        c[c.length] = a[f];\n      }\n\n      return c;\n    }\n\n    function A(a, e, c, b, f, h, r, y, I, k) {\n      var l = 0;\n      k ? (r.color = h, y.color = h) : k = 1;\n      l = I ? Math.abs(f - c) : Math.abs(b - e);\n      l = 0 < r.trimLength ? Math.abs(l * r.trimLength / 100) : Math.abs(l - r.length);\n      I ? (c += l / 2, f -= l / 2) : (e += l / 2, b -= l / 2);\n      var l = 1 === Math.round(r.thickness) % 2 ? 0.5 : 0,\n          p = 1 === Math.round(y.thickness) % 2 ? 0.5 : 0;\n      a.save();\n      a.globalAlpha = k;\n      a.strokeStyle = y.color || h;\n      a.lineWidth = y.thickness || 2;\n      a.setLineDash && a.setLineDash(G(y.dashType, y.thickness));\n      a.beginPath();\n      I && 0 < y.thickness ? (a.moveTo(b - r.thickness / 2, Math.round((c + f) / 2) - p), a.lineTo(e + r.thickness / 2, Math.round((c + f) / 2) - p)) : 0 < y.thickness && (a.moveTo(Math.round((e + b) / 2) - p, c + r.thickness / 2), a.lineTo(Math.round((e + b) / 2) - p, f - r.thickness / 2));\n      a.stroke();\n      a.strokeStyle = r.color || h;\n      a.lineWidth = r.thickness || 2;\n      a.setLineDash && a.setLineDash(G(r.dashType, r.thickness));\n      a.beginPath();\n      I && 0 < r.thickness ? (a.moveTo(b - l, c), a.lineTo(b - l, f), a.moveTo(e + l, c), a.lineTo(e + l, f)) : 0 < r.thickness && (a.moveTo(e, c + l), a.lineTo(b, c + l), a.moveTo(e, f - l), a.lineTo(b, f - l));\n      a.stroke();\n      a.restore();\n    }\n\n    function P(a, e) {\n      P.base.constructor.call(this, \"Legend\", \"legend\", e, null, a);\n      this.chart = a;\n      this.canvas = a.canvas;\n      this.ctx = this.chart.ctx;\n      this.ghostCtx = this.chart._eventManager.ghostCtx;\n      this.items = [];\n      this.optionsName = \"legend\";\n      this.height = this.width = 0;\n      this.orientation = null;\n      this.dataSeries = [];\n      this.bounds = {\n        x1: null,\n        y1: null,\n        x2: null,\n        y2: null\n      };\n      \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n      this.lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);\n      this.horizontalSpacing = this.fontSize;\n    }\n\n    function U(a, e, c, b) {\n      U.base.constructor.call(this, \"DataSeries\", \"data\", e, c, a);\n      this.chart = a;\n      this.canvas = a.canvas;\n      this._ctx = a.canvas.ctx;\n      this.index = c;\n      this.noDataPointsInPlotArea = 0;\n      this.id = b;\n      this.chart._eventManager.objectMap[b] = {\n        id: b,\n        objectType: \"dataSeries\",\n        dataSeriesIndex: c\n      };\n      a = e.dataPoints ? e.dataPoints.length : 0;\n      this.dataPointEOs = [];\n\n      for (e = 0; e < a; e++) this.dataPointEOs[e] = {};\n\n      this.dataPointIds = [];\n      this.plotUnit = [];\n      this.axisY = this.axisX = null;\n      this.optionsName = \"data\";\n      this.isOptionsInArray = !0;\n      null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);\n      this.axisPlacement = this.getDefaultAxisPlacement();\n      \"undefined\" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));\n    }\n\n    function C(a, e, c, b, f, h) {\n      C.base.constructor.call(this, \"Axis\", e, c, b, a);\n      this.chart = a;\n      this.canvas = a.canvas;\n      this.ctx = a.ctx;\n      this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;\n      this.labels = [];\n      this.dataSeries = [];\n      this._stripLineLabels = this._ticks = this._labels = null;\n      this.dataInfo = {\n        min: Infinity,\n        max: -Infinity,\n        viewPortMin: Infinity,\n        viewPortMax: -Infinity,\n        minDiff: Infinity\n      };\n      this.isOptionsInArray = !0;\n      \"axisX\" === f ? (\"left\" === h || \"bottom\" === h ? (this.optionsName = \"axisX\", n(this.chart.sessionVariables.axisX[b]) && (this.chart.sessionVariables.axisX[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[b]) : (this.optionsName = \"axisX2\", n(this.chart.sessionVariables.axisX2[b]) && (this.chart.sessionVariables.axisX2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[b]), this.options.interval || (this.intervalType = null)) : \"left\" === h || \"bottom\" === h ? (this.optionsName = \"axisY\", n(this.chart.sessionVariables.axisY[b]) && (this.chart.sessionVariables.axisY[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[b]) : (this.optionsName = \"axisY2\", n(this.chart.sessionVariables.axisY2[b]) && (this.chart.sessionVariables.axisY2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[b]);\n      \"undefined\" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));\n      \"undefined\" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));\n      this.type = f;\n      \"axisX\" !== f || c && \"undefined\" !== typeof c.gridThickness || (this.gridThickness = 0);\n      this._position = h;\n      this.lineCoordinates = {\n        x1: null,\n        y1: null,\n        x2: null,\n        y2: null,\n        width: null\n      };\n      this.labelAngle = (this.labelAngle % 360 + 360) % 360;\n      90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);\n      this.options.scaleBreaks && (this.scaleBreaks = new ea(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));\n      this.stripLines = [];\n      if (this.options.stripLines && 0 < this.options.stripLines.length) for (a = 0; a < this.options.stripLines.length; a++) this.stripLines.push(new Q(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));\n      this.options.crosshair && (this.crosshair = new da(this.chart, this.options.crosshair, this));\n      this._titleTextBlock = null;\n      this.hasOptionChanged(\"viewportMinimum\") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);\n      this.hasOptionChanged(\"viewportMinimum\") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;\n      this.hasOptionChanged(\"viewportMaximum\") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);\n      this.hasOptionChanged(\"viewportMaximum\") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;\n      null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));\n      null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\n      this.trackChanges(\"viewportMinimum\");\n      this.trackChanges(\"viewportMaximum\");\n    }\n\n    function ea(a, e, c, b) {\n      ea.base.constructor.call(this, \"ScaleBreaks\", \"scaleBreaks\", e, null, b);\n      this.id = c;\n      this.chart = a;\n      this.ctx = this.chart.ctx;\n      this.axis = b;\n      this.optionsName = \"scaleBreaks\";\n      this.isOptionsInArray = !1;\n      this._appliedBreaks = [];\n      this.customBreaks = [];\n      this.autoBreaks = [];\n      \"string\" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.spacing && (this.spacing = 8);\n      this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));\n\n      if (this.options.customBreaks && 0 < this.options.customBreaks.length) {\n        for (a = 0; a < this.options.customBreaks.length; a++) this.customBreaks.push(new ca(this.chart, \"customBreaks\", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), \"number\" === typeof this.customBreaks[a].startValue && \"number\" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue && this._appliedBreaks.push(this.customBreaks[a]);\n\n        this._appliedBreaks.sort(function (a, b) {\n          return a.startValue - b.startValue;\n        });\n\n        for (a = 0; a < this._appliedBreaks.length - 1; a++) this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log(\"CanvasJS Error: Breaks \" + a + \" and \" + (a + 1) + \" are overlapping.\"), this._appliedBreaks.splice(a, 2), a--);\n      }\n    }\n\n    function ca(a, e, c, b, f, h) {\n      ca.base.constructor.call(this, \"Break\", e, c, b, h);\n      this.id = f;\n      this.chart = a;\n      this.ctx = this.chart.ctx;\n      this.scaleBreaks = h;\n      this.optionsName = e;\n      this.isOptionsInArray = !0;\n      this.type = c.type ? this.type : h.type;\n      this.fillOpacity = n(c.fillOpacity) ? h.fillOpacity : this.fillOpacity;\n      this.lineThickness = n(c.lineThickness) ? h.lineThickness : this.lineThickness;\n      this.color = c.color ? this.color : h.color;\n      this.lineColor = c.lineColor ? this.lineColor : h.lineColor;\n      this.lineDashType = c.lineDashType ? this.lineDashType : h.lineDashType;\n      !n(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());\n      !n(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());\n      \"number\" === typeof this.startValue && \"number\" === typeof this.endValue && this.endValue < this.startValue && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);\n      this.spacing = \"undefined\" === typeof c.spacing ? h.spacing : c.spacing;\n      \"string\" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.options.spacing && (this.spacing = h.spacing);\n      this.size = h.parent.logarithmic ? 1 : 0;\n    }\n\n    function Q(a, e, c, b, f) {\n      Q.base.constructor.call(this, \"StripLine\", \"stripLines\", e, c, f);\n      this.id = b;\n      this.chart = a;\n      this.ctx = this.chart.ctx;\n      this.label = this.label;\n      this.axis = f;\n      this.optionsName = \"stripLines\";\n      this.isOptionsInArray = !0;\n      this._thicknessType = \"pixel\";\n      null !== this.startValue && null !== this.endValue && (this.value = f.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);\n    }\n\n    function da(a, e, c) {\n      da.base.constructor.call(this, \"Crosshair\", \"crosshair\", e, null, c);\n      this.chart = a;\n      this.ctx = this.chart.ctx;\n      this.axis = c;\n      this.optionsName = \"crosshair\";\n      this._thicknessType = \"pixel\";\n    }\n\n    function na(a, e) {\n      na.base.constructor.call(this, \"ToolTip\", \"toolTip\", e, null, a);\n      this.chart = a;\n      this.canvas = a.canvas;\n      this.ctx = this.chart.ctx;\n      this.currentDataPointIndex = this.currentSeriesIndex = -1;\n      this._prevY = this._prevX = NaN;\n      this.containerTransitionDuration = 0.1;\n      this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);\n      this.optionsName = \"toolTip\";\n\n      this._initialize();\n    }\n\n    function ha(a) {\n      this.chart = a;\n      this.lastObjectId = 0;\n      this.objectMap = [];\n      this.rectangularRegionEventSubscriptions = [];\n      this.previousDataPointEventObject = null;\n      this.ghostCanvas = ua(this.chart.width, this.chart.height, !0);\n      this.ghostCtx = this.ghostCanvas.getContext(\"2d\");\n      this.mouseoveredObjectMaps = [];\n    }\n\n    function $(a) {\n      this.chart = a;\n      this.ctx = this.chart.plotArea.ctx;\n      this.animations = [];\n      this.animationRequestId = null;\n    }\n\n    pa(m, X);\n\n    m.prototype.destroy = function () {\n      var a = this.allDOMEventHandlers;\n      this._animator && this._animator.cancelAllAnimations();\n      this._panTimerId && clearTimeout(this._panTimerId);\n\n      for (var e = 0; e < a.length; e++) {\n        var c = a[e][0],\n            b = a[e][1],\n            f = a[e][2],\n            h = a[e][3],\n            h = h || !1;\n        c.removeEventListener ? c.removeEventListener(b, f, h) : c.detachEvent && c.detachEvent(\"on\" + b, f);\n      }\n\n      this.allDOMEventHandlers = [];\n\n      for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();) this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);\n\n      for (; this.container && this.container.hasChildNodes();) this.container.removeChild(this.container.lastChild);\n\n      for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes();) this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);\n\n      this.container = this._canvasJSContainer = null;\n      this.toolTip.container = null;\n      this.canvas && ya(this.canvas);\n      this.overlaidCanvas && ya(this.overlaidCanvas);\n      this._preRenderCanvas && ya(this._preRenderCanvas);\n      this._breaksCanvas && ya(this._breaksCanvas);\n      this._eventManager && this._eventManager.ghostCanvas && ya(this._eventManager.ghostCanvas);\n      this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = null;\n    };\n\n    m.prototype._updateOptions = function () {\n      var a = this;\n      this.updateOption(\"width\");\n      this.updateOption(\"height\");\n      this.updateOption(\"dataPointWidth\");\n      this.updateOption(\"dataPointMinWidth\");\n      this.updateOption(\"dataPointMaxWidth\");\n      this.updateOption(\"interactivityEnabled\");\n      this.updateOption(\"theme\");\n      this.stockChart && this.stockChart.options && \"undefined\" !== typeof this.stockChart.options.theme && n(this.options.theme) && (this.theme = this.stockChart.theme);\n      this.updateOption(\"colorSet\") && (this.selectedColorSet = \"undefined\" !== typeof Ba[this.colorSet] ? Ba[this.colorSet] : Ba.colorSet1);\n      this.updateOption(\"backgroundColor\");\n      this.stockChart && this.stockChart.options && \"undefined\" !== typeof this.stockChart.options.backgroundColor && n(this.options.backgroundColor) && (this.backgroundColor = this.stockChart.backgroundColor);\n      this.backgroundColor || (this.backgroundColor = \"rgba(0,0,0,0)\");\n      this.updateOption(\"culture\");\n      this.stockChart && n(this.options.culture) && (this.culture = this.stockChart.culture);\n      this._cultureInfo = new Ja(this.culture);\n      this.updateOption(\"animationEnabled\");\n      this.animationEnabled = this.animationEnabled && v;\n      this.updateOption(\"animationDuration\");\n      this.updateOption(\"rangeChanging\");\n      this.updateOption(\"rangeChanged\");\n      this.updateOption(\"exportEnabled\");\n      this.updateOption(\"exportFileName\");\n      this.updateOption(\"zoomType\");\n      this.toolbar = new Va(this, this.options.toolbar);\n      if (this.stockChart && this.stockChart.options && this.stockChart.options.toolbar && !this.options.toolbar) for (var e in this.stockChart.options.toolbar) this.toolbar[e] = this.stockChart.options.toolbar[e];\n\n      if (this.options.zoomEnabled || this.panEnabled) {\n        if (this._zoomButton) O(this._zoomButton, {\n          borderRight: this.toolbar.buttonBorderThickness + \"px solid \" + this.toolbar.buttonBorderColor,\n          backgroundColor: a.toolbar.itemBackgroundColor,\n          color: a.toolbar.fontColor\n        }), sa(this, this._zoomButton, \"zoom\"), 0 >= navigator.userAgent.search(\"MSIE\") && this._zoomButton.childNodes[0] && O(this._zoomButton.childNodes[0], {\n          WebkitFilter: \"invert(0%)\",\n          filter: \"invert(0%)\"\n        });else {\n          var c = !1;\n          wa(this._zoomButton = document.createElement(\"button\"));\n          sa(this, this._zoomButton, \"pan\");\n\n          this._toolBar.appendChild(this._zoomButton);\n\n          this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + \"px solid \" + this.toolbar.buttonBorderColor;\n          H(this._zoomButton, \"touchstart\", function (a) {\n            c = !0;\n          }, this.allDOMEventHandlers);\n          H(this._zoomButton, \"click\", function () {\n            a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, sa(a, a._zoomButton, \"zoom\")) : (a.zoomEnabled = !0, a.panEnabled = !1, sa(a, a._zoomButton, \"pan\"));\n            a.render();\n          }, this.allDOMEventHandlers);\n          H(this._zoomButton, \"mousemove\", function () {\n            c ? c = !1 : (O(a._zoomButton, {\n              backgroundColor: a.toolbar.itemBackgroundColorOnHover,\n              color: a.toolbar.fontColorOnHover,\n              transition: \"0.4s\",\n              WebkitTransition: \"0.4s\"\n            }), 0 >= navigator.userAgent.search(\"MSIE\") && O(a._zoomButton.childNodes[0], {\n              WebkitFilter: \"invert(100%)\",\n              filter: \"invert(100%)\"\n            }));\n          }, this.allDOMEventHandlers);\n          H(this._zoomButton, \"mouseout\", function () {\n            c || (O(a._zoomButton, {\n              backgroundColor: a.toolbar.itemBackgroundColor,\n              color: a.toolbar.fontColor,\n              transition: \"0.4s\",\n              WebkitTransition: \"0.4s\"\n            }), 0 >= navigator.userAgent.search(\"MSIE\") && O(a._zoomButton.childNodes[0], {\n              WebkitFilter: \"invert(0%)\",\n              filter: \"invert(0%)\"\n            }));\n          }, this.allDOMEventHandlers);\n        }\n        this._resetButton ? (O(this._resetButton, {\n          borderRight: this.toolbar.buttonBorderThickness + \"px solid \" + this.toolbar.buttonBorderColor,\n          backgroundColor: a.toolbar.itemBackgroundColor,\n          color: a.toolbar.fontColor\n        }), 0 >= navigator.userAgent.search(\"MSIE\") && this._resetButton.childNodes[0] && O(this._resetButton.childNodes[0], {\n          WebkitFilter: \"invert(0%)\",\n          filter: \"invert(0%)\"\n        }), this._resetButton.title = this._cultureInfo.resetText) : (c = !1, wa(this._resetButton = document.createElement(\"button\")), sa(this, this._resetButton, \"reset\"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + \"px solid \" + this.toolbar.buttonBorderColor, this._toolBar.appendChild(this._resetButton), H(this._resetButton, \"touchstart\", function (a) {\n          c = !0;\n        }, this.allDOMEventHandlers), H(this._resetButton, \"click\", function () {\n          a.toolTip.hide();\n          a.toolTip && a.toolTip.enabled && a.toolTip.dispatchEvent(\"hidden\", {\n            chart: a,\n            toolTip: a.toolTip\n          }, a.toolTip);\n          a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, sa(a, a._zoomButton, \"pan\"), a._defaultCursor = \"default\", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1);\n          if (a.sessionVariables.axisX) for (var b = 0; b < a.sessionVariables.axisX.length; b++) a.sessionVariables.axisX[b].newViewportMinimum = null, a.sessionVariables.axisX[b].newViewportMaximum = null;\n          if (a.sessionVariables.axisX2) for (b = 0; b < a.sessionVariables.axisX2.length; b++) a.sessionVariables.axisX2[b].newViewportMinimum = null, a.sessionVariables.axisX2[b].newViewportMaximum = null;\n          if (a.sessionVariables.axisY) for (b = 0; b < a.sessionVariables.axisY.length; b++) a.sessionVariables.axisY[b].newViewportMinimum = null, a.sessionVariables.axisY[b].newViewportMaximum = null;\n          if (a.sessionVariables.axisY2) for (b = 0; b < a.sessionVariables.axisY2.length; b++) a.sessionVariables.axisY2[b].newViewportMinimum = null, a.sessionVariables.axisY2[b].newViewportMaximum = null;\n          a.resetOverlayedCanvas();\n          0 >= navigator.userAgent.search(\"MSIE\") && O(a._resetButton.childNodes[0], {\n            WebkitFilter: \"invert(0%)\",\n            filter: \"invert(0%)\"\n          });\n          wa(a._zoomButton, a._resetButton);\n          a.stockChart && (a.stockChart._rangeEventParameter = {\n            stockChart: a.stockChart,\n            source: \"chart\",\n            index: a.stockChart.charts.indexOf(a),\n            minimum: null,\n            maximum: null\n          });\n\n          a._dispatchRangeEvent(\"rangeChanging\", \"reset\");\n\n          a.stockChart && (a.stockChart._rangeEventParameter.type = \"rangeChanging\", a.stockChart.dispatchEvent(\"rangeChanging\", a.stockChart._rangeEventParameter, a.stockChart));\n          a.render();\n          a.syncCharts && a.stockChart && (a.stockChart.rangeUpdatedBy = !a.stockChart.navigator.slider || n(a.stockChart.navigator.slider.options.minimum) && n(a.stockChart.navigator.slider.options.maximum) ? !a.stockChart.rangeSelector.enabled || !a.stockChart.rangeSelector.inputFields.enabled || n(a.stockChart.rangeSelector.inputFields.options.startValue) && n(a.stockChart.rangeSelector.inputFields.options.endValue) ? null : \"inputFields\" : \"navigator\", n(a.stockChart._selectedRangeButtonIndex) || (a.stockChart.rangeUpdatedBy = \"rangeButton\"), a.syncCharts(null, null), \"rangeButton\" === a.stockChart.rangeUpdatedBy && a.stockChart.rangeSelector.selectedRangeButtonIndex < a.stockChart.rangeSelector.buttons.length && (b = a.stockChart.rangeSelector.buttons[a.stockChart.rangeSelector.selectedRangeButtonIndex], b.state = \"on\", b.textBlock.fontWeight = \"bold\", b.textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover, b.textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColorOnSelect, b.render()));\n\n          a._dispatchRangeEvent(\"rangeChanged\", \"reset\");\n\n          a.stockChart && (a.stockChart._rangeEventParameter.type = \"rangeChanged\", a.stockChart.dispatchEvent(\"rangeChanged\", a.stockChart._rangeEventParameter, a.stockChart));\n        }, this.allDOMEventHandlers), H(this._resetButton, \"mousemove\", function () {\n          c || (O(a._resetButton, {\n            backgroundColor: a.toolbar.itemBackgroundColorOnHover,\n            color: a.toolbar.fontColorOnHover,\n            transition: \"0.4s\",\n            WebkitTransition: \"0.4s\"\n          }), 0 >= navigator.userAgent.search(\"MSIE\") && O(a._resetButton.childNodes[0], {\n            WebkitFilter: \"invert(100%)\",\n            filter: \"invert(100%)\"\n          }));\n        }, this.allDOMEventHandlers), H(this._resetButton, \"mouseout\", function () {\n          c || (O(a._resetButton, {\n            backgroundColor: a.toolbar.itemBackgroundColor,\n            color: a.toolbar.fontColor,\n            transition: \"0.4s\",\n            WebkitTransition: \"0.4s\"\n          }), 0 >= navigator.userAgent.search(\"MSIE\") && O(a._resetButton.childNodes[0], {\n            WebkitFilter: \"invert(0%)\",\n            filter: \"invert(0%)\"\n          }));\n        }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor);\n        this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute(\"state\") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), La(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1));\n      } else this.panEnabled = this.zoomEnabled = !1;\n\n      ib(this);\n      \"none\" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? sa(a, a._zoomButton, \"zoom\") : sa(a, a._zoomButton, \"pan\"), a._resetButton.getAttribute(\"state\") !== a._cultureInfo.resetText && sa(a, a._resetButton, \"reset\"));\n      this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);\n\n      for (e in this.toolTip.options) this.toolTip.options.hasOwnProperty(e) && this.toolTip.updateOption(e);\n    };\n\n    m.prototype._updateSize = function () {\n      var a;\n      a = [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas];\n      var e = 0,\n          c = 0;\n      this.options.width ? e = this.width : this.width = e = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;\n      n(this.stockChart) || n(this.index) ? this.options.height ? c = this.height : this.height = c = 0 < this.container.clientHeight ? this.container.clientHeight : this.height : c = this.height = this.stockChart._chartsHeight[this.index];\n\n      if (this.canvas.width !== e * la || this.canvas.height !== c * la) {\n        for (var b = 0; b < a.length; b++) Ma(a[b], e, c);\n\n        this.bounds = {\n          x1: 0,\n          y1: 0,\n          x2: this.width,\n          y2: this.height,\n          width: this.width,\n          height: this.height\n        };\n        a = !0;\n      } else a = !1;\n\n      return a;\n    };\n\n    m.prototype._initialize = function () {\n      this.isNavigator = n(this.parent) || n(this.parent._defaultsKey) || \"Navigator\" !== this.parent._defaultsKey ? !1 : !0;\n      this._animator ? this._animator.cancelAllAnimations() : this._animator = new $(this);\n      this.removeAllEventListeners();\n      this.disableToolTip = !1;\n      this._axes = [];\n      this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;\n\n      this._updateOptions();\n\n      this.animatedRender = v && this.animationEnabled && 0 === this.renderCount;\n\n      this._updateSize();\n\n      this.clearCanvas();\n      this.ctx.beginPath();\n      this.axisX = [];\n      this.axisX2 = [];\n      this.axisY = [];\n      this.axisY2 = [];\n      this._indexLabels = [];\n      this._dataInRenderedOrder = [];\n      this._events = [];\n      this._eventManager && this._eventManager.reset();\n      this.plotInfo = {\n        axisPlacement: null,\n        plotTypes: []\n      };\n      this.layoutManager = new Ea(0, 0, this.width, this.height, this.isNavigator ? 0 : 2);\n      this.plotArea.layoutManager && this.plotArea.layoutManager.reset();\n      this.data = [];\n      this.title = null;\n      this.subtitles = [];\n      var a = 0,\n          e = null;\n\n      if (this.options.data) {\n        for (var c = 0; c < this.options.data.length; c++) if (a++, !this.options.data[c].type || 0 <= m._supportedChartTypes.indexOf(this.options.data[c].type)) {\n          var b = new U(this, this.options.data[c], a - 1, ++this._eventManager.lastObjectId);\n          if (!n(b) && b.dataPoints) for (var f = 0; f < b.dataPoints.length; f++) if (b.dataPoints[f].x && b.dataPoints[f].x.getTime) {\n            b.xValueType = \"dateTime\";\n            break;\n          }\n          \"error\" === b.type && (b.linkedDataSeriesIndex = n(this.options.data[c].linkedDataSeriesIndex) ? c - 1 : this.options.data[c].linkedDataSeriesIndex, 0 > b.linkedDataSeriesIndex || b.linkedDataSeriesIndex >= this.options.data.length || \"number\" !== typeof b.linkedDataSeriesIndex || \"error\" === this.options.data[b.linkedDataSeriesIndex].type) && (b.linkedDataSeriesIndex = null);\n          null === b.name && (b.name = \"DataSeries \" + a);\n          null === b.color ? 1 < this.options.data.length ? (b._colorSet = [this.selectedColorSet[b.index % this.selectedColorSet.length]], b.color = this.selectedColorSet[b.index % this.selectedColorSet.length]) : b._colorSet = \"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"candlestick\" === b.type || \"ohlc\" === b.type || \"waterfall\" === b.type || \"boxAndWhisker\" === b.type ? [this.selectedColorSet[0]] : this.selectedColorSet : b._colorSet = [b.color];\n          null === b.markerSize && ((\"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || 0 <= b.type.toLowerCase().indexOf(\"area\")) && b.dataPoints && b.dataPoints.length < this.width / 16 || \"scatter\" === b.type) && (b.markerSize = 8);\n          \"bubble\" !== b.type && \"scatter\" !== b.type || !b.dataPoints || (b.dataPoints.some ? b.dataPoints.some(function (a) {\n            return a.x;\n          }) && b.dataPoints.sort(d) : b.dataPoints.sort(d));\n          this.data.push(b);\n          var f = b.axisPlacement,\n              e = e || f,\n              h;\n          \"normal\" === f ? \"xySwapped\" === this.plotInfo.axisPlacement ? h = 'You cannot combine \"' + b.type + '\" with bar chart' : \"none\" === this.plotInfo.axisPlacement ? h = 'You cannot combine \"' + b.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"normal\") : \"xySwapped\" === f ? \"normal\" === this.plotInfo.axisPlacement ? h = 'You cannot combine \"' + b.type + '\" with line, area, column or pie chart' : \"none\" === this.plotInfo.axisPlacement ? h = 'You cannot combine \"' + b.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"xySwapped\") : \"none\" === f ? \"normal\" === this.plotInfo.axisPlacement ? h = 'You cannot combine \"' + b.type + '\" with line, area, column or bar chart' : \"xySwapped\" === this.plotInfo.axisPlacement ? h = 'You cannot combine \"' + b.type + '\" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"none\") : null === f && \"none\" === this.plotInfo.axisPlacement && (h = 'You cannot combine \"' + b.type + '\" with pie chart');\n\n          if (h && window.console) {\n            window.console.log(h);\n            return;\n          }\n        }\n\n        for (c = 0; c < this.data.length; c++) {\n          if (\"none\" == e && \"error\" === this.data[c].type && window.console) {\n            window.console.log('You cannot combine \"' + b.type + '\" with error chart');\n            return;\n          }\n\n          \"error\" === this.data[c].type && (this.data[c].axisPlacement = this.plotInfo.axisPlacement = e || \"normal\", this.data[c]._linkedSeries = null === this.data[c].linkedDataSeriesIndex ? null : this.data[this.data[c].linkedDataSeriesIndex]);\n        }\n      }\n\n      this._objectsInitialized = !0;\n      this._plotAreaElements = [];\n    };\n\n    m._supportedChartTypes = Da(\"line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall\".split(\" \"));\n\n    m.prototype.setLayout = function () {\n      for (var a = this._plotAreaElements, e = 0; e < this.data.length; e++) if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) {\n        if (!this.data[e].axisYType || \"primary\" === this.data[e].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) {\n          if (!this.axisY.length) for (var c = 0; c < this.options.axisY.length; c++) \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[c] = new C(this, \"axisY\", this.options.axisY[c], c, \"axisY\", \"left\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[c] = new C(this, \"axisY\", this.options.axisY[c], c, \"axisY\", \"bottom\"));\n          this.data[e].axisY = this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0];\n          this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]);\n        } else this.axisY.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new C(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"left\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new C(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"bottom\"))), this.data[e].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[e]);\n        if (\"secondary\" === this.data[e].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) {\n          if (!this.axisY2.length) for (c = 0; c < this.options.axisY2.length; c++) \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[c] = new C(this, \"axisY2\", this.options.axisY2[c], c, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[c] = new C(this, \"axisY2\", this.options.axisY2[c], c, \"axisY\", \"top\"));\n          this.data[e].axisY = this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0];\n          this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]);\n        } else this.axisY2.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new C(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new C(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"top\"))), this.data[e].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[e]);\n        if (!this.data[e].axisXType || \"primary\" === this.data[e].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) {\n          if (!this.axisX.length) for (c = 0; c < this.options.axisX.length; c++) \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[c] = new C(this, \"axisX\", this.options.axisX[c], c, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[c] = new C(this, \"axisX\", this.options.axisX[c], c, \"axisX\", \"left\"));\n          this.data[e].axisX = this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0];\n          this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]);\n        } else this.axisX.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new C(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new C(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"left\"))), this.data[e].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[e]);\n        if (\"secondary\" === this.data[e].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) {\n          if (!this.axisX2.length) for (c = 0; c < this.options.axisX2.length; c++) \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[c] = new C(this, \"axisX2\", this.options.axisX2[c], c, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[c] = new C(this, \"axisX2\", this.options.axisX2[c], c, \"axisX\", \"right\"));\n          this.data[e].axisX = this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0];\n          this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]);\n        } else this.axisX2.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new C(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new C(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"right\"))), this.data[e].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[e]);\n      }\n\n      if (this.axisY) {\n        for (c = 1; c < this.axisY.length; c++) \"undefined\" === typeof this.axisY[c].options.gridThickness && (this.axisY[c].gridThickness = 0);\n\n        for (c = 0; c < this.axisY.length - 1; c++) \"undefined\" === typeof this.axisY[c].options.margin && (this.axisY[c].margin = 10);\n      }\n\n      if (this.axisY2) {\n        for (c = 1; c < this.axisY2.length; c++) \"undefined\" === typeof this.axisY2[c].options.gridThickness && (this.axisY2[c].gridThickness = 0);\n\n        for (c = 0; c < this.axisY2.length - 1; c++) \"undefined\" === typeof this.axisY2[c].options.margin && (this.axisY2[c].margin = 10);\n      }\n\n      this.axisY && 0 < this.axisY.length && this.axisY2 && 0 < this.axisY2.length && (0 < this.axisY[0].gridThickness && \"undefined\" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && \"undefined\" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));\n      if (this.axisX) for (c = 0; c < this.axisX.length; c++) \"undefined\" === typeof this.axisX[c].options.gridThickness && (this.axisX[c].gridThickness = 0);\n      if (this.axisX2) for (c = 0; c < this.axisX2.length; c++) \"undefined\" === typeof this.axisX2[c].options.gridThickness && (this.axisX2[c].gridThickness = 0);\n      this.axisX && 0 < this.axisX.length && this.axisX2 && 0 < this.axisX2.length && (0 < this.axisX[0].gridThickness && \"undefined\" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && \"undefined\" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));\n      c = !1;\n      if (0 < this._axes.length && this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) for (e = 0; e < this._axes.length; e++) if (!n(this._axes[e].viewportMinimum) || !n(this._axes[e].viewportMaximum)) {\n        c = !0;\n        break;\n      }\n      c ? (La(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + \"px solid \" + this.toolbar.buttonBorderColor, this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + \"px solid \" + this.toolbar.buttonBorderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + \"px solid \" + this.toolbar.buttonBorderColor) : (wa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + \"px solid transparent\", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1));\n      gb(this);\n\n      this._processData();\n\n      this.options.title && (this.title = new Aa(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout());\n      if (this.options.subtitles) for (e = 0; e < this.options.subtitles.length; e++) c = new Ia(this, this.options.subtitles[e], e), this.subtitles.push(c), c.dockInsidePlotArea ? a.push(c) : c.setLayout();\n      this.legend = new P(this, this.options.legend);\n\n      for (e = 0; e < this.data.length; e++) (this.data[e].showInLegend || \"pie\" === this.data[e].type || \"doughnut\" === this.data[e].type || \"funnel\" === this.data[e].type || \"pyramid\" === this.data[e].type) && this.legend.dataSeries.push(this.data[e]);\n\n      this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout();\n\n      for (e = 0; e < this._axes.length; e++) if (this._axes[e].scaleBreaks && this._axes[e].scaleBreaks._appliedBreaks.length) {\n        v ? (this._breaksCanvas = ua(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext(\"2d\")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);\n        break;\n      }\n\n      this._preRenderCanvas = ua(this.width, this.height);\n      this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\");\n      \"normal\" !== this.plotInfo.axisPlacement && \"xySwapped\" !== this.plotInfo.axisPlacement || C.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());\n    };\n\n    m.prototype.renderElements = function () {\n      if (this.height) {\n        var a = this._plotAreaElements;\n        this.title && !this.title.dockInsidePlotArea && this.title.render();\n\n        for (var e = 0; e < this.subtitles.length; e++) this.subtitles[e].dockInsidePlotArea || this.subtitles[e].render();\n\n        this.legend.dockInsidePlotArea || this.legend.render();\n        if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) C.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);else if (\"none\" === this.plotInfo.axisPlacement) this.preparePlotArea();else return;\n\n        for (e = 0; e < a.length; e++) a[e].setLayout(), a[e].render();\n\n        var c = [];\n\n        if (this.animatedRender) {\n          var b = ua(this.width, this.height);\n          b.getContext(\"2d\").drawImage(this.canvas, 0, 0, this.width, this.height);\n        }\n\n        jb(this);\n        var a = this.ctx.miterLimit,\n            f;\n        this.ctx.miterLimit = 3;\n        v && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = \"source-atop\", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));\n\n        for (e = 0; e < this.plotInfo.plotTypes.length; e++) for (var h = this.plotInfo.plotTypes[e], r = 0; r < h.plotUnits.length; r++) {\n          var y = h.plotUnits[r],\n              I = null;\n          y.targetCanvas && ya(y.targetCanvas);\n          y.targetCanvas = null;\n          this.animatedRender && (y.targetCanvas = ua(this.width, this.height), y.targetCanvasCtx = y.targetCanvas.getContext(\"2d\"), f = y.targetCanvasCtx.miterLimit, y.targetCanvasCtx.miterLimit = 3);\n          \"line\" === y.type ? I = this.renderLine(y) : \"stepLine\" === y.type ? I = this.renderStepLine(y) : \"spline\" === y.type ? I = this.renderSpline(y) : \"column\" === y.type ? I = this.renderColumn(y) : \"bar\" === y.type ? I = this.renderBar(y) : \"area\" === y.type ? I = this.renderArea(y) : \"stepArea\" === y.type ? I = this.renderStepArea(y) : \"splineArea\" === y.type ? I = this.renderSplineArea(y) : \"stackedColumn\" === y.type ? I = this.renderStackedColumn(y) : \"stackedColumn100\" === y.type ? I = this.renderStackedColumn100(y) : \"stackedBar\" === y.type ? I = this.renderStackedBar(y) : \"stackedBar100\" === y.type ? I = this.renderStackedBar100(y) : \"stackedArea\" === y.type ? I = this.renderStackedArea(y) : \"stackedArea100\" === y.type ? I = this.renderStackedArea100(y) : \"bubble\" === y.type ? I = I = this.renderBubble(y) : \"scatter\" === y.type ? I = this.renderScatter(y) : \"pie\" === y.type ? this.renderPie(y) : \"doughnut\" === y.type ? this.renderPie(y) : \"funnel\" === y.type ? I = this.renderFunnel(y) : \"pyramid\" === y.type ? I = this.renderFunnel(y) : \"candlestick\" === y.type ? I = this.renderCandlestick(y) : \"ohlc\" === y.type ? I = this.renderCandlestick(y) : \"rangeColumn\" === y.type ? I = this.renderRangeColumn(y) : \"error\" === y.type ? I = this.renderError(y) : \"rangeBar\" === y.type ? I = this.renderRangeBar(y) : \"rangeArea\" === y.type ? I = this.renderRangeArea(y) : \"rangeSplineArea\" === y.type ? I = this.renderRangeSplineArea(y) : \"waterfall\" === y.type ? I = this.renderWaterfall(y) : \"boxAndWhisker\" === y.type && (I = this.renderBoxAndWhisker(y));\n\n          for (var k = 0; k < y.dataSeriesIndexes.length; k++) this._dataInRenderedOrder.push(this.data[y.dataSeriesIndexes[k]]);\n\n          this.animatedRender && (y.targetCanvasCtx.miterLimit = f, I && c.push(I));\n        }\n\n        this.ctx.miterLimit = a;\n        this.animatedRender && this._breaksCanvasCtx && c.push({\n          source: this._breaksCanvasCtx,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0,\n          startTimePercent: 0.7\n        });\n        this.animatedRender && 0 < this._indexLabels.length && (f = ua(this.width, this.height).getContext(\"2d\"), za(f), c.push(this.renderIndexLabels(f)));\n        var l = this;\n        if (0 < c.length) l.disableToolTip = !0, l._animator.animate(200, l.animationDuration, function (a) {\n          l.ctx.clearRect(0, 0, l.width, l.height);\n          l.ctx.drawImage(b, 0, 0, Math.floor(l.width * la), Math.floor(l.height * la), 0, 0, l.width, l.height);\n\n          for (var f = 0; f < c.length; f++) I = c[f], 1 > a && \"undefined\" !== typeof I.startTimePercent ? a >= I.startTimePercent && I.animationCallback(I.easingFunction(a - I.startTimePercent, 0, 1, 1 - I.startTimePercent), I) : I.animationCallback(I.easingFunction(a, 0, 1, 1), I);\n\n          l.dispatchEvent(\"dataAnimationIterationEnd\", {\n            chart: l\n          });\n        }, function () {\n          c = [];\n\n          for (var a = 0; a < l.plotInfo.plotTypes.length; a++) for (var f = l.plotInfo.plotTypes[a], g = 0; g < f.plotUnits.length; g++) {\n            var e = f.plotUnits[g];\n            e.targetCanvas && ya(e.targetCanvas);\n            e.targetCanvas = null;\n          }\n\n          b = null;\n          l.disableToolTip = !1;\n          l.dispatchEvent(\"dataAnimationEnd\", {\n            chart: l\n          });\n        });else {\n          if (l._breaksCanvas) if (v) l.plotArea.ctx.drawImage(l._breaksCanvas, 0, 0, this.width, this.height);else for (k = 0; k < l._axes.length; k++) l._axes[k].createMask();\n          0 < l._indexLabels.length && l.renderIndexLabels();\n          l.dispatchEvent(\"dataAnimationIterationEnd\", {\n            chart: l\n          });\n          l.dispatchEvent(\"dataAnimationEnd\", {\n            chart: l\n          });\n        }\n        this.attachPlotAreaEventHandlers();\n        this.zoomEnabled || this.panEnabled || !this._zoomButton || \"none\" === this._zoomButton.style.display || wa(this._zoomButton, this._resetButton);\n        n(this.toolTip._xValue) || n(this.toolTip._dataSeriesIndex) || this.toolTip.showAtX(this.toolTip._xValue, this.toolTip._dataSeriesIndex);\n\n        this.toolTip._updateToolTip();\n\n        this.renderCount++;\n        Ha && (l = this, setTimeout(function () {\n          var a = document.getElementById(\"ghostCanvasCopy\");\n          a && (Ma(a, l.width, l.height), a.getContext(\"2d\").drawImage(l._eventManager.ghostCanvas, 0, 0));\n        }, 2E3));\n        this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);\n\n        for (k = 0; k < this._axes.length; k++) this._axes[k].maskCanvas && (delete this._axes[k].maskCanvas, delete this._axes[k].maskCtx);\n      }\n    };\n\n    m.prototype.render = function (a) {\n      a && (this.options = a);\n\n      this._initialize();\n\n      this.setLayout();\n      this.renderElements();\n      this._preRenderCanvas && ya(this._preRenderCanvas);\n    };\n\n    m.prototype.attachPlotAreaEventHandlers = function () {\n      this.attachEvent({\n        context: this,\n        chart: this,\n        mousedown: this._plotAreaMouseDown,\n        mouseup: this._plotAreaMouseUp,\n        mousemove: this._plotAreaMouseMove,\n        cursor: this.panEnabled ? \"move\" : \"default\",\n        capture: !0,\n        bounds: this.plotArea\n      });\n    };\n\n    m.prototype.categoriseDataSeries = function () {\n      for (var a = \"\", e = 0; e < this.data.length; e++) if (a = this.data[e], a.dataPoints && 0 !== a.dataPoints.length && a.visible && 0 <= m._supportedChartTypes.indexOf(a.type)) {\n        for (var c = null, b = !1, f = null, h = !1, r = 0; r < this.plotInfo.plotTypes.length; r++) if (this.plotInfo.plotTypes[r].type === a.type) {\n          b = !0;\n          c = this.plotInfo.plotTypes[r];\n          break;\n        }\n\n        b || (c = {\n          type: a.type,\n          totalDataSeries: 0,\n          plotUnits: []\n        }, this.plotInfo.plotTypes.push(c));\n\n        for (r = 0; r < c.plotUnits.length; r++) if (c.plotUnits[r].axisYType === a.axisYType && c.plotUnits[r].axisXType === a.axisXType && c.plotUnits[r].axisYIndex === a.axisYIndex && c.plotUnits[r].axisXIndex === a.axisXIndex) {\n          h = !0;\n          f = c.plotUnits[r];\n          break;\n        }\n\n        h || (f = {\n          type: a.type,\n          previousDataSeriesCount: 0,\n          index: c.plotUnits.length,\n          plotType: c,\n          axisXType: a.axisXType,\n          axisYType: a.axisYType,\n          axisYIndex: a.axisYIndex,\n          axisXIndex: a.axisXIndex,\n          axisY: \"primary\" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0],\n          axisX: \"primary\" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0],\n          dataSeriesIndexes: [],\n          yTotals: [],\n          yAbsTotals: []\n        }, c.plotUnits.push(f));\n        c.totalDataSeries++;\n        f.dataSeriesIndexes.push(e);\n        a.plotUnit = f;\n      }\n\n      for (e = 0; e < this.plotInfo.plotTypes.length; e++) for (c = this.plotInfo.plotTypes[e], r = a = 0; r < c.plotUnits.length; r++) c.plotUnits[r].previousDataSeriesCount = a, a += c.plotUnits[r].dataSeriesIndexes.length;\n    };\n\n    m.prototype.assignIdToDataPoints = function () {\n      for (var a = 0; a < this.data.length; a++) {\n        var e = this.data[a];\n        if (e.dataPoints) for (var c = e.dataPoints.length, b = 0; b < c; b++) e.dataPointIds[b] = ++this._eventManager.lastObjectId;\n      }\n    };\n\n    m.prototype._processData = function () {\n      this.assignIdToDataPoints();\n      this.categoriseDataSeries();\n\n      for (var a = 0; a < this.plotInfo.plotTypes.length; a++) for (var e = this.plotInfo.plotTypes[a], c = 0; c < e.plotUnits.length; c++) {\n        var b = e.plotUnits[c];\n        \"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"column\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"bar\" === b.type || \"bubble\" === b.type || \"scatter\" === b.type ? this._processMultiseriesPlotUnit(b) : \"stackedColumn\" === b.type || \"stackedBar\" === b.type || \"stackedArea\" === b.type ? this._processStackedPlotUnit(b) : \"stackedColumn100\" === b.type || \"stackedBar100\" === b.type || \"stackedArea100\" === b.type ? this._processStacked100PlotUnit(b) : \"candlestick\" === b.type || \"ohlc\" === b.type || \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type || \"boxAndWhisker\" === b.type ? this._processMultiYPlotUnit(b) : \"waterfall\" === b.type && this._processSpecificPlotUnit(b);\n      }\n\n      this.calculateAutoBreaks();\n    };\n\n    m.prototype._processMultiseriesPlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, f, h = !1, r = 0; r < a.dataSeriesIndexes.length; r++) {\n        var y = this.data[a.dataSeriesIndexes[r]],\n            I = 0,\n            k = !1,\n            l = !1,\n            p;\n        if (\"normal\" === y.axisPlacement || \"xySwapped\" === y.axisPlacement) var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity,\n            g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;\n        if (y.dataPoints[I].x && y.dataPoints[I].x.getTime || \"dateTime\" === y.xValueType) h = !0;\n\n        for (I = 0; I < y.dataPoints.length; I++) {\n          \"undefined\" === typeof y.dataPoints[I].x && (y.dataPoints[I].x = I + (a.axisX.logarithmic ? 1 : 0));\n          y.dataPoints[I].x.getTime ? (h = !0, b = y.dataPoints[I].x.getTime()) : b = y.dataPoints[I].x;\n          f = y.dataPoints[I].y;\n          b < c.min && (c.min = b);\n          b > c.max && (c.max = b);\n          f < e.min && \"number\" === typeof f && (e.min = f);\n          f > e.max && \"number\" === typeof f && (e.max = f);\n\n          if (0 < I) {\n            if (a.axisX.logarithmic) {\n              var d = b / y.dataPoints[I - 1].x;\n              1 > d && (d = 1 / d);\n              c.minDiff > d && 1 !== d && (c.minDiff = d);\n            } else d = b - y.dataPoints[I - 1].x, 0 > d && (d *= -1), c.minDiff > d && 0 !== d && (c.minDiff = d);\n\n            null !== f && null !== y.dataPoints[I - 1].y && (a.axisY.logarithmic ? (d = f / y.dataPoints[I - 1].y, 1 > d && (d = 1 / d), e.minDiff > d && 1 !== d && (e.minDiff = d)) : (d = f - y.dataPoints[I - 1].y, 0 > d && (d *= -1), e.minDiff > d && 0 !== d && (e.minDiff = d)));\n          }\n\n          if (b < q && !k) null !== f && (p = b);else {\n            if (!k && (k = !0, 0 < I)) {\n              I -= 2;\n              continue;\n            }\n\n            if (b > g && !l) l = !0;else if (b > g && l) continue;\n            y.dataPoints[I].label && (a.axisX.labels[b] = y.dataPoints[I].label);\n            b < c.viewPortMin && (c.viewPortMin = b);\n            b > c.viewPortMax && (c.viewPortMax = b);\n            null === f ? c.viewPortMin === b && p < b && (c.viewPortMin = p) : (f < e.viewPortMin && \"number\" === typeof f && (e.viewPortMin = f), f > e.viewPortMax && \"number\" === typeof f && (e.viewPortMax = f));\n          }\n        }\n\n        y.axisX.valueType = y.xValueType = h ? \"dateTime\" : \"number\";\n      }\n    };\n\n    m.prototype._processStackedPlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n        for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, f, h = !1, r = [], y = [], I = Infinity, k = -Infinity, l = {}, p = 0; p < a.dataSeriesIndexes.length; p++) {\n          var q = this.data[a.dataSeriesIndexes[p]],\n              g = 0,\n              d = !1,\n              w = !1,\n              x;\n          if (\"normal\" === q.axisPlacement || \"xySwapped\" === q.axisPlacement) var s = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -Infinity,\n              z = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;\n          if (q.dataPoints[g].x && q.dataPoints[g].x.getTime || \"dateTime\" === q.xValueType) h = !0;\n\n          for (g = 0; g < q.dataPoints.length; g++) {\n            \"undefined\" === typeof q.dataPoints[g].x && (q.dataPoints[g].x = g + (a.axisX.logarithmic ? 1 : 0));\n            q.dataPoints[g].x.getTime ? (h = !0, b = q.dataPoints[g].x.getTime()) : b = q.dataPoints[g].x;\n            f = n(q.dataPoints[g].y) ? 0 : q.dataPoints[g].y;\n            b < c.min && (c.min = b);\n            b > c.max && (c.max = b);\n\n            if (0 < g) {\n              if (a.axisX.logarithmic) {\n                var u = b / q.dataPoints[g - 1].x;\n                1 > u && (u = 1 / u);\n                c.minDiff > u && 1 !== u && (c.minDiff = u);\n              } else u = b - q.dataPoints[g - 1].x, 0 > u && (u *= -1), c.minDiff > u && 0 !== u && (c.minDiff = u);\n\n              null !== f && null !== q.dataPoints[g - 1].y && (a.axisY.logarithmic ? 0 < f && (u = f / q.dataPoints[g - 1].y, 1 > u && (u = 1 / u), e.minDiff > u && 1 !== u && (e.minDiff = u)) : (u = f - q.dataPoints[g - 1].y, 0 > u && (u *= -1), e.minDiff > u && 0 !== u && (e.minDiff = u)));\n            }\n\n            if (b < s && !d) null !== q.dataPoints[g].y && (x = b);else {\n              if (!d && (d = !0, 0 < g)) {\n                g -= 2;\n                continue;\n              }\n\n              if (b > z && !w) w = !0;else if (b > z && w) continue;\n              q.dataPoints[g].label && (a.axisX.labels[b] = q.dataPoints[g].label);\n              b < c.viewPortMin && (c.viewPortMin = b);\n              b > c.viewPortMax && (c.viewPortMax = b);\n              null === q.dataPoints[g].y ? c.viewPortMin === b && x < b && (c.viewPortMin = x) : (l[b] = (l[b] || 0) + q.dataPoints[g].y, q.dataPointEOs[g].cumulativeY = l[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + f, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(f), 0 <= f ? r[b] ? r[b] += f : (r[b] = f, I = Math.min(f, I)) : y[b] ? y[b] += f : (y[b] = f, k = Math.max(f, k)));\n            }\n          }\n\n          a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks && (e.dataPointYPositiveSums ? (e.dataPointYPositiveSums.push.apply(e.dataPointYPositiveSums, r), e.dataPointYNegativeSums.push.apply(e.dataPointYPositiveSums, y)) : (e.dataPointYPositiveSums = r, e.dataPointYNegativeSums = y));\n          q.axisX.valueType = q.xValueType = h ? \"dateTime\" : \"number\";\n        }\n\n        for (g in r) r.hasOwnProperty(g) && !isNaN(g) && (a = r[g], a < e.min && (e.min = Math.min(a, I)), a > e.max && (e.max = a), g < c.viewPortMin || g > c.viewPortMax || (a < e.viewPortMin && (e.viewPortMin = Math.min(a, I)), a > e.viewPortMax && (e.viewPortMax = a)));\n\n        for (g in y) y.hasOwnProperty(g) && !isNaN(g) && (a = y[g], a < e.min && (e.min = a), a > e.max && (e.max = Math.max(a, k)), g < c.viewPortMin || g > c.viewPortMax || (a < e.viewPortMin && (e.viewPortMin = a), a > e.viewPortMax && (e.viewPortMax = Math.max(a, k))));\n      }\n    };\n\n    m.prototype._processStacked100PlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n        for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, f, h = !1, r = !1, y = !1, I = {}, k = [], l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var p = this.data[a.dataSeriesIndexes[l]],\n              q = 0,\n              g = !1,\n              d = !1,\n              w;\n          if (\"normal\" === p.axisPlacement || \"xySwapped\" === p.axisPlacement) var x = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -Infinity,\n              s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;\n          if (p.dataPoints[q].x && p.dataPoints[q].x.getTime || \"dateTime\" === p.xValueType) h = !0;\n\n          for (q = 0; q < p.dataPoints.length; q++) {\n            \"undefined\" === typeof p.dataPoints[q].x && (p.dataPoints[q].x = q + (a.axisX.logarithmic ? 1 : 0));\n            p.dataPoints[q].x.getTime ? (h = !0, b = p.dataPoints[q].x.getTime()) : b = p.dataPoints[q].x;\n            f = n(p.dataPoints[q].y) ? null : p.dataPoints[q].y;\n            b < c.min && (c.min = b);\n            b > c.max && (c.max = b);\n\n            if (0 < q) {\n              if (a.axisX.logarithmic) {\n                var z = b / p.dataPoints[q - 1].x;\n                1 > z && (z = 1 / z);\n                c.minDiff > z && 1 !== z && (c.minDiff = z);\n              } else z = b - p.dataPoints[q - 1].x, 0 > z && (z *= -1), c.minDiff > z && 0 !== z && (c.minDiff = z);\n\n              n(f) || null === p.dataPoints[q - 1].y || (a.axisY.logarithmic ? 0 < f && (z = f / p.dataPoints[q - 1].y, 1 > z && (z = 1 / z), e.minDiff > z && 1 !== z && (e.minDiff = z)) : (z = f - p.dataPoints[q - 1].y, 0 > z && (z *= -1), e.minDiff > z && 0 !== z && (e.minDiff = z)));\n            }\n\n            if (b < x && !g) null !== f && (w = b);else {\n              if (!g && (g = !0, 0 < q)) {\n                q -= 2;\n                continue;\n              }\n\n              if (b > s && !d) d = !0;else if (b > s && d) continue;\n              p.dataPoints[q].label && (a.axisX.labels[b] = p.dataPoints[q].label);\n              b < c.viewPortMin && (c.viewPortMin = b);\n              b > c.viewPortMax && (c.viewPortMax = b);\n              null === f ? c.viewPortMin === b && w < b && (c.viewPortMin = w) : (I[b] = (I[b] || 0) + p.dataPoints[q].y, p.dataPointEOs[q].cumulativeY = I[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + f, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(f), 0 <= f ? r = !0 : 0 > f && (y = !0), k[b] = k[b] ? k[b] + Math.abs(f) : Math.abs(f));\n            }\n          }\n\n          p.axisX.valueType = p.xValueType = h ? \"dateTime\" : \"number\";\n        }\n\n        a.axisY.logarithmic ? (e.max = n(e.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(e.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), e.min = n(e.viewPortMin) ? 1 : Math.min(e.viewPortMin, 1)) : r && !y ? (e.max = n(e.viewPortMax) ? 99 : Math.max(e.viewPortMax, 99), e.min = n(e.viewPortMin) ? 1 : Math.min(e.viewPortMin, 1)) : r && y ? (e.max = n(e.viewPortMax) ? 99 : Math.max(e.viewPortMax, 99), e.min = n(e.viewPortMin) ? -99 : Math.min(e.viewPortMin, -99)) : !r && y && (e.max = n(e.viewPortMax) ? -1 : Math.max(e.viewPortMax, -1), e.min = n(e.viewPortMin) ? -99 : Math.min(e.viewPortMin, -99));\n        e.viewPortMin = e.min;\n        e.viewPortMax = e.max;\n        a.dataPointYSums = k;\n      }\n    };\n\n    m.prototype._processMultiYPlotUnit = function (a) {\n      if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, f, h, r, y = !1, I = 0; I < a.dataSeriesIndexes.length; I++) {\n        var k = this.data[a.dataSeriesIndexes[I]],\n            l = 0,\n            p = !1,\n            q = !1,\n            g,\n            d,\n            n;\n        if (\"normal\" === k.axisPlacement || \"xySwapped\" === k.axisPlacement) var x = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity,\n            s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;\n        if (k.dataPoints[l].x && k.dataPoints[l].x.getTime || \"dateTime\" === k.xValueType) y = !0;\n\n        for (l = 0; l < k.dataPoints.length; l++) {\n          \"undefined\" === typeof k.dataPoints[l].x && (k.dataPoints[l].x = l + (a.axisX.logarithmic ? 1 : 0));\n          k.dataPoints[l].x.getTime ? (y = !0, b = k.dataPoints[l].x.getTime()) : b = k.dataPoints[l].x;\n\n          if ((f = k.dataPoints[l].y) && f.length) {\n            h = Math.min.apply(null, f);\n            r = Math.max.apply(null, f);\n            d = !0;\n\n            for (var z = 0; z < f.length; z++) null === f.k && (d = !1);\n\n            d && (p || (n = g), g = b);\n          }\n\n          b < c.min && (c.min = b);\n          b > c.max && (c.max = b);\n          h < e.min && (e.min = h);\n          r > e.max && (e.max = r);\n          0 < l && (a.axisX.logarithmic ? (d = b / k.dataPoints[l - 1].x, 1 > d && (d = 1 / d), c.minDiff > d && 1 !== d && (c.minDiff = d)) : (d = b - k.dataPoints[l - 1].x, 0 > d && (d *= -1), c.minDiff > d && 0 !== d && (c.minDiff = d)), f && null !== f[0] && k.dataPoints[l - 1].y && null !== k.dataPoints[l - 1].y[0] && (a.axisY.logarithmic ? (d = f[0] / k.dataPoints[l - 1].y[0], 1 > d && (d = 1 / d), e.minDiff > d && 1 !== d && (e.minDiff = d)) : (d = f[0] - k.dataPoints[l - 1].y[0], 0 > d && (d *= -1), e.minDiff > d && 0 !== d && (e.minDiff = d))));\n\n          if (!(b < x) || p) {\n            if (!p && (p = !0, 0 < l)) {\n              l -= 2;\n              g = n;\n              continue;\n            }\n\n            if (b > s && !q) q = !0;else if (b > s && q) continue;\n            k.dataPoints[l].label && (a.axisX.labels[b] = k.dataPoints[l].label);\n            b < c.viewPortMin && (c.viewPortMin = b);\n            b > c.viewPortMax && (c.viewPortMax = b);\n            if (c.viewPortMin === b && f) for (z = 0; z < f.length; z++) if (null === f[z] && g < b) {\n              c.viewPortMin = g;\n              break;\n            }\n            null === f ? c.viewPortMin === b && g < b && (c.viewPortMin = g) : (h < e.viewPortMin && (e.viewPortMin = h), r > e.viewPortMax && (e.viewPortMax = r));\n          }\n        }\n\n        k.axisX.valueType = k.xValueType = y ? \"dateTime\" : \"number\";\n      }\n    };\n\n    m.prototype._processSpecificPlotUnit = function (a) {\n      if (\"waterfall\" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var e = a.axisY.dataInfo, c = a.axisX.dataInfo, b, f, h = !1, r = 0; r < a.dataSeriesIndexes.length; r++) {\n        var y = this.data[a.dataSeriesIndexes[r]],\n            d = 0,\n            k = !1,\n            l = !1,\n            p = b = 0;\n        if (\"normal\" === y.axisPlacement || \"xySwapped\" === y.axisPlacement) var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -Infinity,\n            g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : Infinity;\n        if (y.dataPoints[d].x && y.dataPoints[d].x.getTime || \"dateTime\" === y.xValueType) h = !0;\n\n        for (d = 0; d < y.dataPoints.length; d++) \"undefined\" !== typeof y.dataPoints[d].isCumulativeSum && !0 === y.dataPoints[d].isCumulativeSum ? (y.dataPointEOs[d].cumulativeSumYStartValue = 0, y.dataPointEOs[d].cumulativeSum = 0 === d ? 0 : y.dataPointEOs[d - 1].cumulativeSum, y.dataPoints[d].y = 0 === d ? 0 : y.dataPointEOs[d - 1].cumulativeSum) : \"undefined\" !== typeof y.dataPoints[d].isIntermediateSum && !0 === y.dataPoints[d].isIntermediateSum ? (y.dataPointEOs[d].cumulativeSumYStartValue = p, y.dataPointEOs[d].cumulativeSum = 0 === d ? 0 : y.dataPointEOs[d - 1].cumulativeSum, y.dataPoints[d].y = 0 === d ? 0 : b, p = 0 === d ? 0 : y.dataPointEOs[d - 1].cumulativeSum, b = 0) : (f = \"number\" !== typeof y.dataPoints[d].y ? 0 : y.dataPoints[d].y, y.dataPointEOs[d].cumulativeSumYStartValue = 0 === d ? 0 : y.dataPointEOs[d - 1].cumulativeSum, y.dataPointEOs[d].cumulativeSum = 0 === d ? f : y.dataPointEOs[d - 1].cumulativeSum + f, b += f);\n\n        for (d = 0; d < y.dataPoints.length; d++) if (\"undefined\" === typeof y.dataPoints[d].x && (y.dataPoints[d].x = d + (a.axisX.logarithmic ? 1 : 0)), y.dataPoints[d].x.getTime ? (h = !0, b = y.dataPoints[d].x.getTime()) : b = y.dataPoints[d].x, f = y.dataPoints[d].y, b < c.min && (c.min = b), b > c.max && (c.max = b), y.dataPointEOs[d].cumulativeSum < e.min && (e.min = y.dataPointEOs[d].cumulativeSum), y.dataPointEOs[d].cumulativeSum > e.max && (e.max = y.dataPointEOs[d].cumulativeSum), 0 < d && (a.axisX.logarithmic ? (p = b / y.dataPoints[d - 1].x, 1 > p && (p = 1 / p), c.minDiff > p && 1 !== p && (c.minDiff = p)) : (p = b - y.dataPoints[d - 1].x, 0 > p && (p *= -1), c.minDiff > p && 0 !== p && (c.minDiff = p)), null !== f && null !== y.dataPoints[d - 1].y && (a.axisY.logarithmic ? (f = y.dataPointEOs[d].cumulativeSum / y.dataPointEOs[d - 1].cumulativeSum, 1 > f && (f = 1 / f), e.minDiff > f && 1 !== f && (e.minDiff = f)) : (f = y.dataPointEOs[d].cumulativeSum - y.dataPointEOs[d - 1].cumulativeSum, 0 > f && (f *= -1), e.minDiff > f && 0 !== f && (e.minDiff = f)))), !(b < q) || k) {\n          if (!k && (k = !0, 0 < d)) {\n            d -= 2;\n            continue;\n          }\n\n          if (b > g && !l) l = !0;else if (b > g && l) continue;\n          y.dataPoints[d].label && (a.axisX.labels[b] = y.dataPoints[d].label);\n          b < c.viewPortMin && (c.viewPortMin = b);\n          b > c.viewPortMax && (c.viewPortMax = b);\n          0 < d && (y.dataPointEOs[d - 1].cumulativeSum < e.viewPortMin && (e.viewPortMin = y.dataPointEOs[d - 1].cumulativeSum), y.dataPointEOs[d - 1].cumulativeSum > e.viewPortMax && (e.viewPortMax = y.dataPointEOs[d - 1].cumulativeSum));\n          y.dataPointEOs[d].cumulativeSum < e.viewPortMin && (e.viewPortMin = y.dataPointEOs[d].cumulativeSum);\n          y.dataPointEOs[d].cumulativeSum > e.viewPortMax && (e.viewPortMax = y.dataPointEOs[d].cumulativeSum);\n        }\n\n        y.axisX.valueType = y.xValueType = h ? \"dateTime\" : \"number\";\n      }\n    };\n\n    m.prototype.calculateAutoBreaks = function () {\n      function a(a, b, c, f) {\n        if (f) return c = Math.pow(Math.min(c * a / b, b / a), 0.2), 1 >= c && (c = Math.pow(1 > a ? 1 / a : Math.min(b / a, a), 0.25)), {\n          startValue: a * c,\n          endValue: b / c\n        };\n        c = 0.2 * Math.min(c - b + a, b - a);\n        0 >= c && (c = 0.25 * Math.min(b - a, Math.abs(a)));\n        return {\n          startValue: a + c,\n          endValue: b - c\n        };\n      }\n\n      function e(a) {\n        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n          var b = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks,\n              c = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks;\n          if (b || c) for (var g = a.axisY.dataInfo, e = a.axisX.dataInfo, h, r = e.min, k = e.max, l = g.min, p = g.max, e = e._dataRanges, g = g._dataRanges, q, y = 0, d = 0; d < a.dataSeriesIndexes.length; d++) {\n            var I = f.data[a.dataSeriesIndexes[d]];\n            if (!(4 > I.dataPoints.length)) for (y = 0; y < I.dataPoints.length; y++) if (b && (q = (k + 1 - r) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, h = I.dataPoints[y].x.getTime ? I.dataPoints[y].x.getTime() : I.dataPoints[y].x, q = Math.floor((h - r) / q), h < e[q].min && (e[q].min = h), h > e[q].max && (e[q].max = h)), c) {\n              var v = (p + 1 - l) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;\n              if ((h = \"waterfall\" === a.type ? I.dataPointEOs[y].cumulativeSum : I.dataPoints[y].y) && h.length) for (var m = 0; m < h.length; m++) q = Math.floor((h[m] - l) / v), h[m] < g[q].min && (g[q].min = h[m]), h[m] > g[q].max && (g[q].max = h[m]);else n(h) || (q = Math.floor((h - l) / v), h < g[q].min && (g[q].min = h), h > g[q].max && (g[q].max = h));\n            }\n          }\n        }\n      }\n\n      function c(a) {\n        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var b = a.axisX.dataInfo, c = b.min, g = b.max, e = b._dataRanges, h, r = 0, k = 0; k < a.dataSeriesIndexes.length; k++) {\n          var l = f.data[a.dataSeriesIndexes[k]];\n          if (!(4 > l.dataPoints.length)) for (r = 0; r < l.dataPoints.length; r++) h = (g + 1 - c) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, b = l.dataPoints[r].x.getTime ? l.dataPoints[r].x.getTime() : l.dataPoints[r].x, h = Math.floor((b - c) / h), b < e[h].min && (e[h].min = b), b > e[h].max && (e[h].max = b);\n        }\n      }\n\n      for (var b, f = this, h = !1, r = 0; r < this._axes.length; r++) if (this._axes[r].scaleBreaks && this._axes[r].scaleBreaks.autoCalculate && 1 <= this._axes[r].scaleBreaks.maxNumberOfAutoBreaks) {\n        h = !0;\n        this._axes[r].dataInfo._dataRanges = [];\n\n        for (var y = 0; y < 100 / Math.max(parseFloat(this._axes[r].scaleBreaks.collapsibleThreshold) || 10, 10); y++) this._axes[r].dataInfo._dataRanges.push({\n          min: Infinity,\n          max: -Infinity\n        });\n      }\n\n      if (h) {\n        for (r = 0; r < this.plotInfo.plotTypes.length; r++) for (h = this.plotInfo.plotTypes[r], y = 0; y < h.plotUnits.length; y++) b = h.plotUnits[y], \"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"column\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"bar\" === b.type || \"bubble\" === b.type || \"scatter\" === b.type || \"candlestick\" === b.type || \"ohlc\" === b.type || \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"waterfall\" === b.type || \"error\" === b.type || \"boxAndWhisker\" === b.type ? e(b) : 0 <= b.type.indexOf(\"stacked\") && c(b);\n\n        for (r = 0; r < this._axes.length; r++) if (this._axes[r].dataInfo._dataRanges) {\n          var d = this._axes[r].dataInfo.min;\n          b = (this._axes[r].dataInfo.max + 1 - d) * Math.max(parseFloat(this._axes[r].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;\n          var k = this._axes[r].dataInfo._dataRanges,\n              l,\n              p,\n              h = [];\n\n          if (this._axes[r].dataInfo.dataPointYPositiveSums) {\n            var q = this._axes[r].dataInfo.dataPointYPositiveSums;\n            l = k;\n\n            for (y in q) if (q.hasOwnProperty(y) && !isNaN(y) && (p = q[y], !n(p))) {\n              var g = Math.floor((p - d) / b);\n              p < l[g].min && (l[g].min = p);\n              p > l[g].max && (l[g].max = p);\n            }\n\n            delete this._axes[r].dataInfo.dataPointYPositiveSums;\n          }\n\n          if (this._axes[r].dataInfo.dataPointYNegativeSums) {\n            q = this._axes[r].dataInfo.dataPointYNegativeSums;\n            l = k;\n\n            for (y in q) q.hasOwnProperty(y) && !isNaN(y) && (p = -1 * q[y], n(p) || (g = Math.floor((p - d) / b), p < l[g].min && (l[g].min = p), p > l[g].max && (l[g].max = p)));\n\n            delete this._axes[r].dataInfo.dataPointYNegativeSums;\n          }\n\n          for (y = 0; y < k.length - 1; y++) if (l = k[y].max, isFinite(l)) for (; y < k.length - 1;) if (d = k[y + 1].min, isFinite(d)) {\n            p = d - l;\n            p > b && h.push({\n              diff: p,\n              start: l,\n              end: d\n            });\n            break;\n          } else y++;\n\n          if (this._axes[r].scaleBreaks.customBreaks) for (y = 0; y < this._axes[r].scaleBreaks.customBreaks.length; y++) for (b = 0; b < h.length; b++) if (this._axes[r].scaleBreaks.customBreaks[y].startValue <= h[b].start && h[b].start <= this._axes[r].scaleBreaks.customBreaks[y].endValue || this._axes[r].scaleBreaks.customBreaks[y].startValue <= h[b].start && h[b].start <= this._axes[r].scaleBreaks.customBreaks[y].endValue || h[b].start <= this._axes[r].scaleBreaks.customBreaks[y].startValue && this._axes[r].scaleBreaks.customBreaks[y].startValue <= h[b].end || h[b].start <= this._axes[r].scaleBreaks.customBreaks[y].endValue && this._axes[r].scaleBreaks.customBreaks[y].endValue <= h[b].end) h.splice(b, 1), b--;\n          h.sort(function (a, b) {\n            return b.diff - a.diff;\n          });\n\n          for (y = 0; y < Math.min(h.length, this._axes[r].scaleBreaks.maxNumberOfAutoBreaks); y++) b = a(h[y].start, h[y].end, this._axes[r].logarithmic ? this._axes[r].dataInfo.max / this._axes[r].dataInfo.min : this._axes[r].dataInfo.max - this._axes[r].dataInfo.min, this._axes[r].logarithmic), this._axes[r].scaleBreaks.autoBreaks.push(new ca(this, \"autoBreaks\", b, y, ++this._eventManager.lastObjectId, this._axes[r].scaleBreaks)), this._axes[r].scaleBreaks._appliedBreaks.push(this._axes[r].scaleBreaks.autoBreaks[this._axes[r].scaleBreaks.autoBreaks.length - 1]);\n\n          this._axes[r].scaleBreaks._appliedBreaks.sort(function (a, b) {\n            return a.startValue - b.startValue;\n          });\n        }\n      }\n    };\n\n    m.prototype.renderCrosshairs = function (a) {\n      for (var e = 0; e < this.axisX.length; e++) this.axisX[e] != a && this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && !this.axisX[e].crosshair._hidden && this.axisX[e].showCrosshair(this.axisX[e].crosshair._updatedValue);\n\n      for (e = 0; e < this.axisX2.length; e++) this.axisX2[e] != a && this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && !this.axisX2[e].crosshair._hidden && this.axisX2[e].showCrosshair(this.axisX2[e].crosshair._updatedValue);\n\n      for (e = 0; e < this.axisY.length; e++) this.axisY[e] != a && this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && !this.axisY[e].crosshair._hidden && this.axisY[e].showCrosshair(this.axisY[e].crosshair._updatedValue);\n\n      for (e = 0; e < this.axisY2.length; e++) this.axisY2[e] != a && this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && !this.axisY2[e].crosshair._hidden && this.axisY2[e].showCrosshair(this.axisY2[e].crosshair._updatedValue);\n    };\n\n    m.prototype.getDataPointAtXY = function (a, e, c) {\n      c = c || !1;\n\n      for (var b = [], f = this._dataInRenderedOrder.length - 1; 0 <= f; f--) {\n        var h = null;\n        (h = this._dataInRenderedOrder[f].getDataPointAtXY(a, e, c)) && b.push(h);\n      }\n\n      a = null;\n      e = !1;\n\n      for (c = 0; c < b.length; c++) if (\"line\" === b[c].dataSeries.type || \"stepLine\" === b[c].dataSeries.type || \"area\" === b[c].dataSeries.type || \"stepArea\" === b[c].dataSeries.type) if (f = ma(\"markerSize\", b[c].dataPoint, b[c].dataSeries) || 8, b[c].distance <= f / 2) {\n        e = !0;\n        break;\n      }\n\n      for (c = 0; c < b.length; c++) e && \"line\" !== b[c].dataSeries.type && \"stepLine\" !== b[c].dataSeries.type && \"area\" !== b[c].dataSeries.type && \"stepArea\" !== b[c].dataSeries.type || (a ? b[c].distance <= a.distance && (a = b[c]) : a = b[c]);\n\n      return a;\n    };\n\n    m.prototype.getObjectAtXY = function (a, e, c) {\n      var b = null;\n      if (c = this.getDataPointAtXY(a, e, c || !1)) b = c.dataSeries.dataPointIds[c.dataPointIndex];else if (v) b = ab(a, e, this._eventManager.ghostCtx);else for (c = 0; c < this.legend.items.length; c++) {\n        var f = this.legend.items[c];\n        a >= f.x1 && a <= f.x2 && e >= f.y1 && e <= f.y2 && (b = f.id);\n      }\n      return b;\n    };\n\n    m.prototype.getAutoFontSize = nb;\n\n    m.prototype.resetOverlayedCanvas = function () {\n      this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);\n    };\n\n    m.prototype.clearCanvas = mb;\n\n    m.prototype.attachEvent = function (a) {\n      this._events.push(a);\n    };\n\n    m.prototype._touchEventHandler = function (a) {\n      if (a.changedTouches && this.interactivityEnabled) {\n        var e = [],\n            c = a.changedTouches,\n            b = c ? c[0] : a,\n            f = null;\n\n        switch (a.type) {\n          case \"touchstart\":\n          case \"MSPointerDown\":\n            e = [\"mousemove\", \"mousedown\"];\n            this._lastTouchData = Pa(b);\n            this._lastTouchData.time = new Date();\n            break;\n\n          case \"touchmove\":\n          case \"MSPointerMove\":\n            e = [\"mousemove\"];\n            break;\n\n          case \"touchend\":\n          case \"MSPointerUp\":\n            var h = this._lastTouchData && this._lastTouchData.time ? new Date() - this._lastTouchData.time : 0,\n                e = \"touchstart\" === this._lastTouchEventType || \"MSPointerDown\" === this._lastTouchEventType || 300 > h ? [\"mouseup\", \"click\"] : [\"mouseup\"];\n            break;\n\n          default:\n            return;\n        }\n\n        if (!(c && 1 < c.length)) {\n          f = Pa(b);\n          f.time = new Date();\n\n          try {\n            var r = f.y - this._lastTouchData.y,\n                h = f.time - this._lastTouchData.time;\n            if (1 < Math.abs(r) && this._lastTouchData.scroll || 5 < Math.abs(r) && 250 > h) this._lastTouchData.scroll = !0;\n          } catch (y) {}\n\n          this._lastTouchEventType = a.type;\n          if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1;else for (c = 0; c < e.length; c++) if (f = e[c], r = document.createEvent(\"MouseEvent\"), r.initMouseEvent(f, !0, !0, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null), b.target.dispatchEvent(r), !n(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < h || \"click\" === f) a.preventManipulation && a.preventManipulation(), a.preventDefault && a.cancelable && a.preventDefault();\n        }\n      }\n    };\n\n    m.prototype._dispatchRangeEvent = function (a, e) {\n      var c = {\n        chart: this\n      };\n      c.type = a;\n      c.trigger = e;\n      var b = [];\n      this.axisX && 0 < this.axisX.length && b.push(\"axisX\");\n      this.axisX2 && 0 < this.axisX2.length && b.push(\"axisX2\");\n      this.axisY && 0 < this.axisY.length && b.push(\"axisY\");\n      this.axisY2 && 0 < this.axisY2.length && b.push(\"axisY2\");\n\n      for (var f = 0; f < b.length; f++) if (n(c[b[f]]) && (c[b[f]] = []), \"axisY\" === b[f]) for (var h = 0; h < this.axisY.length; h++) c[b[f]].push({\n        viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,\n        viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum\n      });else if (\"axisY2\" === b[f]) for (h = 0; h < this.axisY2.length; h++) c[b[f]].push({\n        viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,\n        viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum\n      });else if (\"axisX\" === b[f]) for (h = 0; h < this.axisX.length; h++) c[b[f]].push({\n        viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,\n        viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum\n      });else if (\"axisX2\" === b[f]) for (h = 0; h < this.axisX2.length; h++) c[b[f]].push({\n        viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,\n        viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum\n      });\n\n      this.dispatchEvent(a, c, this);\n    };\n\n    m.prototype._mouseEventHandler = function (a) {\n      function e() {\n        m.capturedEventParam && (f = m.capturedEventParam, r = f.bounds, \"mouseup\" === b && (m.capturedEventParam = null, f.chart.overlaidCanvas.releaseCapture ? f.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", f.chart._mouseEventHandler, !1)), f.hasOwnProperty(b) && (\"mouseup\" !== b || f.chart.overlaidCanvas.releaseCapture ? a.target !== f.chart.overlaidCanvas && v || f[b].call(f.context, c.x, c.y) : a.target !== f.chart.overlaidCanvas && (f.chart.isDrag = !1)));\n      }\n\n      \"undefined\" === typeof a.target && a.srcElement && (a.target = a.srcElement);\n      var c = Pa(a),\n          b = a.type,\n          f,\n          h;\n      a.which ? h = 3 == a.which : a.button && (h = 2 == a.button);\n      if (this._ignoreNextEvent) e(), this._ignoreNextEvent = !1;else if (e(), this.interactivityEnabled) {\n        a.preventManipulation && a.preventManipulation();\n        a.preventDefault && a.preventDefault();\n        var r;\n        Ha && window.console && (window.console.log(b + \" --\\x3e x: \" + c.x + \"; y:\" + c.y), h && window.console.log(a.which), \"mouseup\" === b && window.console.log(\"mouseup\"));\n\n        if (!h) {\n          if (!m.capturedEventParam && this._events) {\n            for (h = 0; h < this._events.length; h++) if (this._events[h].hasOwnProperty(b)) if (f = this._events[h], r = f.bounds, c.x >= r.x1 && c.x <= r.x2 && c.y >= r.y1 && c.y <= r.y2) {\n              f[b].call(f.context, c.x, c.y);\n              \"mousedown\" === b && !0 === f.capture ? (m.capturedEventParam = f, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener(\"mouseup\", this._mouseEventHandler, !1)) : \"mouseup\" === b && (f.chart.overlaidCanvas.releaseCapture ? f.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", this._mouseEventHandler, !1));\n              break;\n            } else f = null;\n\n            a.target.style.cursor = f && f.cursor ? f.cursor : this._defaultCursor;\n          }\n\n          h = this.plotArea;\n\n          if (c.x < h.x1 || c.x > h.x2 || c.y < h.y1 || c.y > h.y2) {\n            this.toolTip && this.toolTip.enabled ? (this.toolTip.hide(), this.toolTip.dispatchEvent(\"hidden\", {\n              chart: this,\n              toolTip: this.toolTip\n            }, this.toolTip)) : this.resetOverlayedCanvas();\n\n            for (h = 0; h < this.axisX.length; h++) this.axisX[h].crosshair && this.axisX[h].crosshair.enabled && (this.axisX[h].crosshair.hide(), this.axisX[h].crosshair.dispatchEvent(\"hidden\", {\n              chart: this,\n              axis: this.axisX[h].options\n            }, this.axisX[h].crosshair));\n\n            for (h = 0; h < this.axisX2.length; h++) this.axisX2[h].crosshair && this.axisX2[h].crosshair.enabled && (this.axisX2[h].crosshair.hide(), this.axisX2[h].crosshair.dispatchEvent(\"hidden\", {\n              chart: this,\n              axis: this.axisX2[h].options\n            }, this.axisX2[h].crosshair));\n\n            for (h = 0; h < this.axisY.length; h++) this.axisY[h].crosshair && this.axisY[h].crosshair.enabled && (this.axisY[h].crosshair.hide(), this.axisY[h].crosshair.dispatchEvent(\"hidden\", {\n              chart: this,\n              axis: this.axisY[h].options\n            }, this.axisY[h].crosshair));\n\n            for (h = 0; h < this.axisY2.length; h++) this.axisY2[h].crosshair && this.axisY2[h].crosshair.enabled && (this.axisY2[h].crosshair.hide(), this.axisY2[h].crosshair.dispatchEvent(\"hidden\", {\n              chart: this,\n              axis: this.axisY2[h].options\n            }, this.axisY2[h].crosshair));\n          }\n\n          this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);\n        }\n      }\n    };\n\n    m.prototype._plotAreaMouseDown = function (a, e) {\n      this.isDrag = !0;\n      this.dragStartPoint = {\n        x: a,\n        y: e\n      };\n    };\n\n    m.prototype._plotAreaMouseUp = function (a, e) {\n      if ((\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) && this.isDrag) {\n        var c = e - this.dragStartPoint.y,\n            b = a - this.dragStartPoint.x,\n            f = 0 <= this.zoomType.indexOf(\"x\"),\n            h = 0 <= this.zoomType.indexOf(\"y\"),\n            r = !1;\n        this.resetOverlayedCanvas();\n        if (\"xySwapped\" === this.plotInfo.axisPlacement) var y = h,\n            h = f,\n            f = y;\n\n        if (this.panEnabled || this.zoomEnabled) {\n          if (this.panEnabled) for (f = h = 0; f < this._axes.length; f++) c = this._axes[f], c.logarithmic ? c.viewportMinimum < c.minimum ? (h = c.minimum / c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum * h, c.sessionVariables.newViewportMaximum = c.viewportMaximum * h, r = !0) : c.viewportMaximum > c.maximum && (h = c.viewportMaximum / c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum / h, c.sessionVariables.newViewportMaximum = c.viewportMaximum / h, r = !0) : c.viewportMinimum < c.minimum ? (h = c.minimum - c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum + h, c.sessionVariables.newViewportMaximum = c.viewportMaximum + h, r = !0) : c.viewportMaximum > c.maximum && (h = c.viewportMaximum - c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum - h, c.sessionVariables.newViewportMaximum = c.viewportMaximum - h, r = !0);else if ((!f || 2 < Math.abs(b)) && (!h || 2 < Math.abs(c)) && this.zoomEnabled) {\n            if (!this.dragStartPoint) return;\n            c = f ? this.dragStartPoint.x : this.plotArea.x1;\n            b = h ? this.dragStartPoint.y : this.plotArea.y1;\n            f = f ? a : this.plotArea.x2;\n            h = h ? e : this.plotArea.y2;\n            2 < Math.abs(c - f) && 2 < Math.abs(b - h) && this._zoomPanToSelectedRegion(c, b, f, h) && (r = !0);\n          }\n          r && (this._ignoreNextEvent = !0, this._dispatchRangeEvent(\"rangeChanging\", \"zoom\"), this.stockChart && this.stockChart.navigator && this.stockChart.navigator.enabled && (this.stockChart._rangeEventParameter || (this.stockChart._rangeEventParameter = {\n            stockChart: this.stockChart,\n            source: \"chart\",\n            index: this.stockChart.charts.indexOf(this),\n            minimum: this.stockChart.sessionVariables._axisXMin,\n            maximum: this.stockChart.sessionVariables._axisXMax\n          }), this.stockChart._rangeEventParameter.type = \"rangeChanging\", this.stockChart.dispatchEvent(\"rangeChanging\", this.stockChart._rangeEventParameter, this.stockChart)), this.render(), this._dispatchRangeEvent(\"rangeChanged\", \"zoom\"), this.stockChart && (this.stockChart.rangeUpdatedBy = \"chart\", this.stockChart.navigator && this.stockChart.navigator.enabled && (this.stockChart._rangeEventParameter.type = \"rangeChanged\", this.stockChart.dispatchEvent(\"rangeChanged\", this.stockChart._rangeEventParameter, this.stockChart))), r && this.zoomEnabled && \"none\" === this._zoomButton.style.display && (La(this._zoomButton, this._resetButton), sa(this, this._zoomButton, \"pan\"), sa(this, this._resetButton, \"reset\")));\n        }\n      }\n\n      this.isDrag = !1;\n\n      if (\"none\" !== this.plotInfo.axisPlacement) {\n        this.resetOverlayedCanvas();\n        if (this.axisX && 0 < this.axisX.length) for (r = 0; r < this.axisX.length; r++) this.axisX[r].crosshair && this.axisX[r].crosshair.enabled && this.axisX[r].renderCrosshair(a, e);\n        if (this.axisX2 && 0 < this.axisX2.length) for (r = 0; r < this.axisX2.length; r++) this.axisX2[r].crosshair && this.axisX2[r].crosshair.enabled && this.axisX2[r].renderCrosshair(a, e);\n        if (this.axisY && 0 < this.axisY.length) for (r = 0; r < this.axisY.length; r++) this.axisY[r].crosshair && this.axisY[r].crosshair.enabled && this.axisY[r].renderCrosshair(a, e);\n        if (this.axisY2 && 0 < this.axisY2.length) for (r = 0; r < this.axisY2.length; r++) this.axisY2[r].crosshair && this.axisY2[r].crosshair.enabled && this.axisY2[r].renderCrosshair(a, e);\n        if (this.axisX && 0 < this.axisX.length) for (r = 0; r < this.axisX.length; r++) this.axisX[r].crosshair && this.axisX[r].crosshair.enabled && this.axisX[r].crosshair.renderLabel();\n        if (this.axisX2 && 0 < this.axisX2.length) for (r = 0; r < this.axisX2.length; r++) this.axisX2[r].crosshair && this.axisX2[r].crosshair.enabled && this.axisX2[r].crosshair.renderLabel();\n        if (this.axisY && 0 < this.axisY.length) for (r = 0; r < this.axisY.length; r++) this.axisY[r].crosshair && this.axisY[r].crosshair.enabled && this.axisY[r].crosshair.renderLabel();\n        if (this.axisY2 && 0 < this.axisY2.length) for (r = 0; r < this.axisY2.length; r++) this.axisY2[r].crosshair && this.axisY2[r].crosshair.enabled && this.axisY2[r].crosshair.renderLabel();\n      }\n    };\n\n    m.prototype._plotAreaMouseMove = function (a, e) {\n      if (this.isDrag && \"none\" !== this.plotInfo.axisPlacement) {\n        var c = 0,\n            b = 0,\n            f = c = null,\n            f = 0 <= this.zoomType.indexOf(\"x\"),\n            h = 0 <= this.zoomType.indexOf(\"y\"),\n            r = this;\n        \"xySwapped\" === this.plotInfo.axisPlacement && (c = h, h = f, f = c);\n        c = this.dragStartPoint.x - a;\n        b = this.dragStartPoint.y - e;\n\n        if (2 < Math.abs(c) && 8 > Math.abs(c) && (this.panEnabled || this.zoomEnabled)) {\n          this.toolTip.hide();\n          this.toolTip && this.toolTip.enabled && this.toolTip.dispatchEvent(\"hidden\", {\n            chart: this,\n            toolTip: this.toolTip\n          }, this.toolTip);\n\n          for (var y = 0; y < this.axisX.length; y++) this.axisX[y].crosshair && this.axisX[y].crosshair.enabled && (this.axisX[y].crosshair.hide(), this.axisX[y].crosshair.dispatchEvent(\"hidden\", {\n            chart: this,\n            axis: this.axisX[y].options\n          }, this.axisX[y].crosshair));\n\n          for (y = 0; y < this.axisX2.length; y++) this.axisX2[y].crosshair && this.axisX2[y].crosshair.enabled && (this.axisX2[y].crosshair.hide(), this.axisX2[y].crosshair.dispatchEvent(\"hidden\", {\n            chart: this,\n            axis: this.axisX2[y].options\n          }, this.axisX2[y].crosshair));\n\n          for (y = 0; y < this.axisY.length; y++) this.axisY[y].crosshair && this.axisY[y].crosshair.enabled && (this.axisY[y].crosshair.hide(), this.axisY[y].crosshair.dispatchEvent(\"hidden\", {\n            chart: this,\n            axis: this.axisY[y].options\n          }, this.axisY[y].crosshair));\n\n          for (y = 0; y < this.axisY2.length; y++) this.axisY2[y].crosshair && this.axisY2[y].crosshair.enabled && (this.axisY2[y].crosshair.hide(), this.axisY2[y].crosshair.dispatchEvent(\"hidden\", {\n            chart: this,\n            axis: this.axisY2[y].options\n          }, this.axisY2[y].crosshair));\n        } else this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, e);\n\n        if ((!f || 2 < Math.abs(c) || !h || 2 < Math.abs(b)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) f = {\n          x1: f ? this.plotArea.x1 + c : this.plotArea.x1,\n          y1: h ? this.plotArea.y1 + b : this.plotArea.y1,\n          x2: f ? this.plotArea.x2 + c : this.plotArea.x2,\n          y2: h ? this.plotArea.y2 + b : this.plotArea.y2\n        }, clearTimeout(r._panTimerId), r._panTimerId = setTimeout(function (b, c, f, g) {\n          return function () {\n            r._zoomPanToSelectedRegion(b, c, f, g, !0) && (r._dispatchRangeEvent(\"rangeChanging\", \"pan\"), r.stockChart && r.stockChart.navigator && r.stockChart.navigator.enabled && (r.stockChart._rangeEventParameter.type = \"rangeChanging\", r.stockChart.dispatchEvent(\"rangeChanging\", r.stockChart._rangeEventParameter, r.stockChart)), r.render(), r._dispatchRangeEvent(\"rangeChanged\", \"pan\"), r.stockChart && r.stockChart.navigator && r.stockChart.navigator.enabled && (r.stockChart._rangeEventParameter.type = \"rangeChanged\", r.stockChart.dispatchEvent(\"rangeChanged\", r.stockChart._rangeEventParameter, r.stockChart)), r.dragStartPoint.x = a, r.dragStartPoint.y = e);\n          };\n        }(f.x1, f.y1, f.x2, f.y2), 0);else if (this.zoomEnabled) {\n          this.resetOverlayedCanvas();\n          c = this.overlaidCanvasCtx.globalAlpha;\n          this.overlaidCanvasCtx.fillStyle = \"#A89896\";\n          var b = f ? this.dragStartPoint.x : this.plotArea.x1,\n              y = h ? this.dragStartPoint.y : this.plotArea.y1,\n              d = f ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,\n              k = h ? e - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;\n          this.validateRegion(b, y, f ? a : this.plotArea.x2 - this.plotArea.x1, h ? e : this.plotArea.y2 - this.plotArea.y1, \"xy\" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = \"#99B2B5\");\n          this.overlaidCanvasCtx.globalAlpha = 0.7;\n          this.overlaidCanvasCtx.fillRect(b, y, d, k);\n          this.overlaidCanvasCtx.globalAlpha = c;\n        }\n      } else if (this.toolTip.mouseMoveHandler(a, e), \"none\" !== this.plotInfo.axisPlacement) {\n        if (this.axisX && 0 < this.axisX.length) for (f = 0; f < this.axisX.length; f++) this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && this.axisX[f].renderCrosshair(a, e);\n        if (this.axisX2 && 0 < this.axisX2.length) for (f = 0; f < this.axisX2.length; f++) this.axisX2[f].crosshair && this.axisX2[f].crosshair.enabled && this.axisX2[f].renderCrosshair(a, e);\n        if (this.axisY && 0 < this.axisY.length) for (f = 0; f < this.axisY.length; f++) this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && this.axisY[f].renderCrosshair(a, e);\n        if (this.axisY2 && 0 < this.axisY2.length) for (f = 0; f < this.axisY2.length; f++) this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && this.axisY2[f].renderCrosshair(a, e);\n        if (this.axisX && 0 < this.axisX.length) for (f = 0; f < this.axisX.length; f++) this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && this.axisX[f].crosshair.renderLabel();\n        if (this.axisX2 && 0 < this.axisX2.length) for (f = 0; f < this.axisX2.length; f++) this.axisX2[f].crosshair && this.axisX2[f].crosshair.enabled && this.axisX2[f].crosshair.renderLabel();\n        if (this.axisY && 0 < this.axisY.length) for (f = 0; f < this.axisY.length; f++) this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && this.axisY[f].crosshair.renderLabel();\n        if (this.axisY2 && 0 < this.axisY2.length) for (f = 0; f < this.axisY2.length; f++) this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && this.axisY2[f].crosshair.renderLabel();\n      }\n    };\n\n    m.prototype._zoomPanToSelectedRegion = function (a, e, c, b, f) {\n      a = this.validateRegion(a, e, c, b, f);\n      e = a.axesWithValidRange;\n      c = a.axesRanges;\n      if (a.isValid) for (b = 0; b < e.length; b++) f = c[b], e[b].setViewPortRange(f.val1, f.val2), this.syncCharts && \"y\" != this.zoomType && this.syncCharts(f.val1, f.val2), this.stockChart && (this.stockChart._rangeEventParameter = {\n        stockChart: this.stockChart,\n        source: \"chart\",\n        index: this.stockChart.charts.indexOf(this),\n        minimum: f.val1,\n        maximum: f.val2\n      });\n      return a.isValid;\n    };\n\n    m.prototype.validateRegion = function (a, e, c, b, f) {\n      f = f || !1;\n\n      for (var h = 0 <= this.zoomType.indexOf(\"x\"), r = 0 <= this.zoomType.indexOf(\"y\"), y = !1, d = [], k = [], l = [], p = 0; p < this._axes.length; p++) (\"axisX\" === this._axes[p].type && h || \"axisY\" === this._axes[p].type && r) && k.push(this._axes[p]);\n\n      for (r = 0; r < k.length; r++) {\n        var p = k[r],\n            h = !1,\n            q = p.convertPixelToValue({\n          x: a,\n          y: e\n        }),\n            g = p.convertPixelToValue({\n          x: c,\n          y: b\n        });\n        if (q > g) var n = g,\n            g = q,\n            q = n;\n        if (p.scaleBreaks) for (n = 0; !h && n < p.scaleBreaks._appliedBreaks.length; n++) h = p.scaleBreaks._appliedBreaks[n].startValue <= q && p.scaleBreaks._appliedBreaks[n].endValue >= g;\n        if (isFinite(p.dataInfo.minDiff)) if (n = p.getApparentDifference(q, g, null, !0), !(h || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) && (p.logarithmic && n < Math.pow(p.dataInfo.minDiff, 3) || !p.logarithmic && n < 3 * Math.abs(p.dataInfo.minDiff)) || q < p.minimum || g > p.maximum)) d.push(p), l.push({\n          val1: q,\n          val2: g\n        }), y = !0;else if (!f) {\n          y = !1;\n          break;\n        }\n      }\n\n      return {\n        isValid: y,\n        axesWithValidRange: d,\n        axesRanges: l\n      };\n    };\n\n    m.prototype.preparePlotArea = function () {\n      var a = this.plotArea;\n      !v && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);\n\n      if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {\n        var e = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;\n\n        if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {\n          var c = this.axisY[0];\n          a.x1 = e.x1 < e.x2 ? e.x1 : c.lineCoordinates.x1;\n          a.y1 = e.y1 < c.lineCoordinates.y1 ? e.y1 : c.lineCoordinates.y1;\n          a.x2 = e.x2 > c.lineCoordinates.x2 ? e.x2 : c.lineCoordinates.x2;\n          a.y2 = e.y1 > c.lineCoordinates.y2 ? e.y1 : c.lineCoordinates.y2;\n          a.width = a.x2 - a.x1;\n          a.height = a.y2 - a.y1;\n        }\n\n        this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (c = this.axisY2[0], a.x1 = e.x1 < e.x2 ? e.x1 : c.lineCoordinates.x1, a.y1 = e.y1 < c.lineCoordinates.y1 ? e.y1 : c.lineCoordinates.y1, a.x2 = e.x2 > c.lineCoordinates.x2 ? e.x2 : c.lineCoordinates.x2, a.y2 = e.y2 > c.lineCoordinates.y2 ? e.y2 : c.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);\n      } else e = this.layoutManager.getFreeSpace(), a.x1 = e.x1, a.x2 = e.x2, a.y1 = e.y1, a.y2 = e.y2, a.width = e.width, a.height = e.height;\n\n      v || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + \"px\", a.canvas.style.top = a.y1 + \"px\", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));\n      a.layoutManager = new Ea(a.x1, a.y1, a.x2, a.y2, 2);\n    };\n\n    m.prototype.renderIndexLabels = function (a) {\n      var e = a || this.plotArea.ctx,\n          c = this.plotArea,\n          b = 0,\n          f = 0,\n          h = 0,\n          r = f = h = 0,\n          y = 0,\n          d = b = 0,\n          k = 0;\n\n      for (a = 0; a < this._indexLabels.length; a++) {\n        var l = this._indexLabels[a],\n            p = l.chartType.toLowerCase(),\n            q,\n            g,\n            y = ma(\"indexLabelFontColor\", l.dataPoint, l.dataSeries),\n            Ra = ma(\"indexLabelFontSize\", l.dataPoint, l.dataSeries),\n            d = ma(\"indexLabelFontFamily\", l.dataPoint, l.dataSeries),\n            k = ma(\"indexLabelFontStyle\", l.dataPoint, l.dataSeries);\n        q = ma(\"indexLabelFontWeight\", l.dataPoint, l.dataSeries);\n        var w = ma(\"indexLabelBackgroundColor\", l.dataPoint, l.dataSeries);\n        g = ma(\"indexLabelMaxWidth\", l.dataPoint, l.dataSeries);\n        var h = ma(\"indexLabelWrap\", l.dataPoint, l.dataSeries),\n            x = ma(\"indexLabelLineDashType\", l.dataPoint, l.dataSeries),\n            s = ma(\"indexLabelLineColor\", l.dataPoint, l.dataSeries),\n            z = n(l.dataPoint.indexLabelLineThickness) ? n(l.dataSeries.options.indexLabelLineThickness) ? 0 : l.dataSeries.options.indexLabelLineThickness : l.dataPoint.indexLabelLineThickness,\n            b = 0 < z ? Math.min(10, (\"normal\" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0,\n            u = {\n          percent: null,\n          total: null\n        },\n            m = null;\n        if (0 <= l.dataSeries.type.indexOf(\"stacked\") || \"pie\" === l.dataSeries.type || \"doughnut\" === l.dataSeries.type) u = this.getPercentAndTotal(l.dataSeries, l.dataPoint);\n        if (l.dataSeries.indexLabelFormatter || l.dataPoint.indexLabelFormatter) m = {\n          chart: this,\n          dataSeries: l.dataSeries,\n          dataPoint: l.dataPoint,\n          index: l.indexKeyword,\n          total: u.total,\n          percent: u.percent\n        };\n        var B = l.dataPoint.indexLabelFormatter ? l.dataPoint.indexLabelFormatter(m) : l.dataPoint.indexLabel ? this.replaceKeywordsWithValue(l.dataPoint.indexLabel, l.dataPoint, l.dataSeries, null, l.indexKeyword) : l.dataSeries.indexLabelFormatter ? l.dataSeries.indexLabelFormatter(m) : l.dataSeries.indexLabel ? this.replaceKeywordsWithValue(l.dataSeries.indexLabel, l.dataPoint, l.dataSeries, null, l.indexKeyword) : null;\n\n        if (null !== B && \"\" !== B) {\n          var u = ma(\"indexLabelPlacement\", l.dataPoint, l.dataSeries),\n              m = ma(\"indexLabelOrientation\", l.dataPoint, l.dataSeries),\n              D = ma(\"indexLabelTextAlign\", l.dataPoint, l.dataSeries),\n              t = l.direction,\n              f = l.dataSeries.axisX,\n              r = l.dataSeries.axisY,\n              A = !1,\n              w = new ja(e, {\n            x: 0,\n            y: 0,\n            maxWidth: g ? g : 0.5 * this.width,\n            maxHeight: h ? 5 * Ra : 1.5 * Ra,\n            angle: \"horizontal\" === m ? 0 : -90,\n            text: B,\n            padding: 0,\n            backgroundColor: w,\n            textAlign: D,\n            fontSize: Ra,\n            fontFamily: d,\n            fontWeight: q,\n            fontColor: y,\n            fontStyle: k,\n            textBaseline: \"middle\"\n          });\n          w.measureText();\n          l.dataSeries.indexLabelMaxWidth = w.maxWidth;\n\n          if (\"stackedarea100\" === p) {\n            if (l.point.x < c.x1 || l.point.x > c.x2 || l.point.y < c.y1 - 1 || l.point.y > c.y2 + 1) continue;\n          } else if (\"rangearea\" === p || \"rangesplinearea\" === p) {\n            if (l.dataPoint.x < f.viewportMinimum || l.dataPoint.x > f.viewportMaximum || Math.max.apply(null, l.dataPoint.y) < r.viewportMinimum || Math.min.apply(null, l.dataPoint.y) > r.viewportMaximum) continue;\n          } else if (0 <= p.indexOf(\"line\") || 0 <= p.indexOf(\"area\") || 0 <= p.indexOf(\"bubble\") || 0 <= p.indexOf(\"scatter\")) {\n            if (l.dataPoint.x < f.viewportMinimum || l.dataPoint.x > f.viewportMaximum || l.dataPoint.y < r.viewportMinimum || l.dataPoint.y > r.viewportMaximum) continue;\n          } else if (0 <= p.indexOf(\"column\") || \"waterfall\" === p || \"error\" === p && !l.axisSwapped) {\n            if (l.dataPoint.x < f.viewportMinimum || l.dataPoint.x > f.viewportMaximum || l.bounds.y1 > c.y2 || l.bounds.y2 < c.y1) continue;\n          } else if (0 <= p.indexOf(\"bar\") || \"error\" === p) {\n            if (l.dataPoint.x < f.viewportMinimum || l.dataPoint.x > f.viewportMaximum || l.bounds.x1 > c.x2 || l.bounds.x2 < c.x1) continue;\n          } else if (\"candlestick\" === p || \"ohlc\" === p) {\n            if (l.dataPoint.x < f.viewportMinimum || l.dataPoint.x > f.viewportMaximum || Math.max.apply(null, l.dataPoint.y) < r.viewportMinimum || Math.min.apply(null, l.dataPoint.y) > r.viewportMaximum) continue;\n          } else if (l.dataPoint.x < f.viewportMinimum || l.dataPoint.x > f.viewportMaximum) continue;\n\n          r = y = 2;\n          \"horizontal\" === m ? (d = w.width, k = w.height) : (k = w.width, d = w.height);\n\n          if (\"normal\" === this.plotInfo.axisPlacement) {\n            if (0 <= p.indexOf(\"line\") || 0 <= p.indexOf(\"area\")) u = \"auto\", y = 4;else if (0 <= p.indexOf(\"stacked\")) \"auto\" === u && (u = \"inside\");else if (\"bubble\" === p || \"scatter\" === p) u = \"inside\";\n            q = l.point.x - d / 2 + (\"horizontal\" === m ? 0 : w._lineHeight / 2);\n            if (\"inside\" !== u) f = c.y1, h = c.y2, 0 < t ? (g = l.point.y + w._lineHeight / 2 - k - y - b, g < f && (g = \"auto\" === u ? Math.max(l.point.y, f) + w._lineHeight / 2 + y + b : f + w._lineHeight / 2 + y + b, A = g + (\"horizontal\" === m ? k - w._lineHeight / 2 : 0) > l.point.y, !A || 0 <= p.indexOf(\"line\") || 0 <= p.indexOf(\"area\") || (g -= b))) : (g = l.point.y + w._lineHeight / 2 + y + b, g > h - k + w._lineHeight / 2 - y && (g = \"auto\" === u ? Math.min(l.point.y, h) + w._lineHeight / 2 - k - y - b : h + w._lineHeight / 2 - k - y - b, A = g - (\"horizontal\" === m ? w._lineHeight / 2 : k) < l.point.y, !A || 0 <= p.indexOf(\"line\") || 0 <= p.indexOf(\"area\") || (g += b)));else {\n              Math.max(l.bounds.y1, c.y1);\n              h = Math.min(l.bounds.y2, c.y2) - k + w._lineHeight / 2;\n              b = 0 <= p.indexOf(\"range\") || \"error\" === p ? 0 < t ? Math.max(l.bounds.y1, c.y1) + w._lineHeight / 2 + y : Math.min(l.bounds.y2, c.y2) + w._lineHeight / 2 - k - y : (Math.max(l.bounds.y1, c.y1) + Math.min(l.bounds.y2, c.y2)) / 2 - k / 2 + w._lineHeight / 2;\n\n              if (0 < t) {\n                if (g = b, \"bubble\" === p || \"scatter\" === p) g = l.point.y - k / 2 + w._lineHeight / 2, k > l.bounds.y2 - l.bounds.y1 && (g -= k / 2 + y), 0 > g - w._lineHeight / 2 && (g += Math.abs(g - w._lineHeight / 2) <= (l.bounds.y2 - l.bounds.y1) / 2 + y ? Math.abs(g - w._lineHeight / 2) : (l.bounds.y2 - l.bounds.y1) / 2 + y);\n              } else g = Math.min(l.point.y, b), g > h - k - y && (\"bubble\" === p || \"scatter\" === p) && (g = Math.min(l.point.y + y, c.y2 - k - y));\n\n              g = Math.min(g, h);\n            }\n          } else 0 <= p.indexOf(\"line\") || 0 <= p.indexOf(\"area\") || 0 <= p.indexOf(\"scatter\") ? (u = \"auto\", r = 4) : 0 <= p.indexOf(\"stacked\") ? \"auto\" === u && (u = \"inside\") : \"bubble\" === p && (u = \"inside\"), g = l.point.y + w._lineHeight / 2 - k / 2, \"inside\" !== u ? (h = c.x1, f = c.x2, 0 > t ? (q = l.point.x - d + (\"horizontal\" === m ? 0 : w._lineHeight / 2) - r - b, (\"horizontal\" === m ? q : q - w._lineHeight / 2) < h && (q = \"auto\" === u ? Math.max(l.point.x, h) + (\"horizontal\" === m ? 0 : w._lineHeight / 2) + y + b : h + (\"horizontal\" === m ? 0 : w._lineHeight / 2) + r, (A = q + d - (\"horizontal\" === m ? 0 : w._lineHeight / 2) > l.point.x) && (q -= b))) : (q = l.point.x + (\"horizontal\" === m ? 0 : w._lineHeight / 2) + r + b, (\"horizontal\" === m ? q : q - w._lineHeight / 2) > f - d - r - b && (q = \"auto\" === u ? Math.min(l.point.x, f) - (\"horizontal\" === m ? d : d - w._lineHeight / 2) - r - b : f - d - r + (\"horizontal\" === m ? 0 : w._lineHeight / 2), (A = q - (\"horizontal\" === m ? 0 : w._lineHeight / 2) < l.point.x) && (q += b)))) : (h = Math.max(l.bounds.x1, c.x1), Math.min(l.bounds.x2, c.x2), b = 0 <= p.indexOf(\"range\") || \"error\" === p ? 0 > t ? Math.max(l.bounds.x1, c.x1) : Math.min(l.bounds.x2, c.x2) - d - r + (\"horizontal\" === m ? 0 : w._lineHeight / 2) : (Math.max(l.bounds.x1, c.x1) + Math.min(l.bounds.x2, c.x2)) / 2 - d / 2 + (\"horizontal\" === m ? 0 : w._lineHeight / 2), q = 0 > t ? b : Math.min(l.point.x, b), q = Math.max(q, h + (\"horizontal\" === m ? 0 : w._lineHeight / 2 + y)));\n\n          \"vertical\" === m && (g += k - w._lineHeight / 2, 0 <= \"ohlc candlestick boxandwhisker column rangecolumn stackedcolumn stackedcolumn100 error\".split(\" \").indexOf(p) && (A = 0 < t ? g + (\"horizontal\" === m ? k - w._lineHeight / 2 : 0) > l.point.y : g - (\"horizontal\" === m ? w._lineHeight / 2 : k) < l.point.y), \"bubble\" === p || \"scatter\" === p) && (q += w._lineHeight / 2 - Ra / 2);\n          w.x = q;\n          w.y = g;\n          w.render(!0);\n          z && \"inside\" !== u && (0 > p.indexOf(\"bar\") && (\"error\" !== p || !l.axisSwapped) && l.point.x > c.x1 && l.point.x < c.x2 || !A) && (-1 === \"ohlc candlestick boxandwhisker column rangecolumn stackedcolumn stackedcolumn100 error\".split(\" \").indexOf(p) && (\"error\" !== p || l.axisSwapped) && l.point.y > c.y1 && l.point.y < c.y2 || !A) && (e.lineWidth = z, e.strokeStyle = s ? s : \"gray\", e.setLineDash && e.setLineDash(G(x, z)), e.beginPath(), e.moveTo(l.point.x, l.point.y), 0 <= p.indexOf(\"bar\") || \"error\" === p && l.axisSwapped ? e.lineTo(q + (0 < l.direction ? 0 : d) + (\"vertical\" === m ? -w._lineHeight / 2 : 0), g + (\"vertical\" === m ? -k / 2 : k / 2 - w._lineHeight / 2)) : 0 <= p.indexOf(\"column\") || \"error\" === p && !l.axisSwapped ? e.lineTo(q + d / 2 - (\"horizontal\" === m ? 0 : w._lineHeight / 2), g + (\"vertical\" === m ? g - k < l.point.y ? 0 : -k : (g - w._lineHeight / 2 < l.point.y ? k : 0) - w._lineHeight / 2)) : 0 <= p.indexOf(\"waterfall\") ? e.lineTo(q + d / 2 - (\"horizontal\" === m ? 0 : w._lineHeight / 2), \"vertical\" === m ? 0 < t && g < l.point.y ? g : 0 > t && g - k > l.point.y ? g - k : l.point.y : 0 < t && g + k - w._lineHeight / 2 < l.point.y ? g + k - w._lineHeight / 2 : 0 > t && g - w._lineHeight / 2 > l.point.y ? g - w._lineHeight / 2 : l.point.y) : e.lineTo(q + d / 2 - (\"horizontal\" === m ? 0 : w._lineHeight / 2), g + (\"vertical\" === m ? g - k < l.point.y ? 0 : -k : (g + k - w._lineHeight / 2 < l.point.y ? k : 0) - w._lineHeight / 2)), e.stroke());\n        }\n      }\n\n      e = {\n        source: e,\n        dest: this.plotArea.ctx,\n        animationCallback: K.fadeInAnimation,\n        easingFunction: K.easing.easeInQuad,\n        animationBase: 0,\n        startTimePercent: 0.7\n      };\n\n      for (a = 0; a < this._indexLabels.length; a++) l = this._indexLabels[a], w = ma(\"indexLabelBackgroundColor\", l.dataPoint, l.dataSeries), l.dataSeries.indexLabelBackgroundColor = n(w) ? v ? \"transparent\" : null : w;\n\n      return e;\n    };\n\n    m.prototype.renderLine = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = this._eventManager.ghostCtx;\n        c.save();\n        var f = this.plotArea;\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n\n        for (var h = [], r, y = 0; y < a.dataSeriesIndexes.length; y++) {\n          var d = a.dataSeriesIndexes[y],\n              k = this.data[d];\n          c.lineWidth = k.lineThickness;\n          var l = k.dataPoints,\n              p = \"solid\";\n\n          if (c.setLineDash) {\n            var q = G(k.nullDataLineDashType, k.lineThickness),\n                p = k.lineDashType,\n                g = G(p, k.lineThickness);\n            c.setLineDash(g);\n          }\n\n          var n = k.id;\n          this._eventManager.objectMap[n] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: d\n          };\n          n = W(n);\n          b.strokeStyle = n;\n          b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;\n          var n = k._colorSet,\n              w = n = k.lineColor = k.options.lineColor ? k.options.lineColor : n[0];\n          c.strokeStyle = n;\n          var x = !0,\n              s = 0,\n              z,\n              u;\n          c.beginPath();\n\n          if (0 < l.length) {\n            for (var m = !1, s = 0; s < l.length; s++) if (z = l[s].x.getTime ? l[s].x.getTime() : l[s].x, !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !m))) if (\"number\" !== typeof l[s].y) 0 < s && !(k.connectNullData || m || x) && (c.stroke(), v && b.stroke()), m = !0;else {\n              z = a.axisX.convertValueToPixel(z);\n              u = a.axisY.convertValueToPixel(l[s].y);\n              var B = k.dataPointIds[s];\n              this._eventManager.objectMap[B] = {\n                id: B,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: d,\n                dataPointIndex: s,\n                x1: z,\n                y1: u\n              };\n              x || m ? (!x && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), c.beginPath(), c.moveTo(r.x, r.y), p = k.nullDataLineDashType, c.setLineDash(q)), c.lineTo(z, u), v && b.lineTo(z, u)) : (c.beginPath(), c.moveTo(z, u), v && (b.beginPath(), b.moveTo(z, u))), m = x = !1) : (c.lineTo(z, u), v && b.lineTo(z, u), 0 == s % 500 && (c.stroke(), c.beginPath(), c.moveTo(z, u), v && (b.stroke(), b.beginPath(), b.moveTo(z, u))));\n              r = {\n                x: z,\n                y: u\n              };\n              s < l.length - 1 && (w !== (l[s].lineColor || n) || p !== (l[s].lineDashType || k.lineDashType)) && (c.stroke(), c.beginPath(), c.moveTo(z, u), w = l[s].lineColor || n, c.strokeStyle = w, c.setLineDash && (l[s].lineDashType ? (p = l[s].lineDashType, c.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, c.setLineDash(g))));\n\n              if (0 !== l[s].markerSize && (0 < l[s].markerSize || 0 < k.markerSize)) {\n                var D = k.getMarkerProperties(s, z, u, c);\n                h.push(D);\n                B = W(B);\n                v && h.push({\n                  x: z,\n                  y: u,\n                  ctx: b,\n                  type: D.type,\n                  size: D.size,\n                  color: B,\n                  borderColor: B,\n                  borderThickness: D.borderThickness\n                });\n              }\n\n              (l[s].indexLabel || k.indexLabel || l[s].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"line\",\n                dataPoint: l[s],\n                dataSeries: k,\n                point: {\n                  x: z,\n                  y: u\n                },\n                direction: 0 > l[s].y === a.axisY.reversed ? 1 : -1,\n                color: n\n              });\n            }\n\n            c.stroke();\n            v && b.stroke();\n          }\n        }\n\n        V.drawMarkers(h);\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), b.beginPath());\n        c.restore();\n        c.beginPath();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderStepLine = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = this._eventManager.ghostCtx;\n        c.save();\n        var f = this.plotArea;\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n\n        for (var h = [], r, y = 0; y < a.dataSeriesIndexes.length; y++) {\n          var d = a.dataSeriesIndexes[y],\n              k = this.data[d];\n          c.lineWidth = k.lineThickness;\n          var l = k.dataPoints,\n              p = \"solid\";\n\n          if (c.setLineDash) {\n            var q = G(k.nullDataLineDashType, k.lineThickness),\n                p = k.lineDashType,\n                g = G(p, k.lineThickness);\n            c.setLineDash(g);\n          }\n\n          var n = k.id;\n          this._eventManager.objectMap[n] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: d\n          };\n          n = W(n);\n          b.strokeStyle = n;\n          b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;\n          var n = k._colorSet,\n              w = n = k.lineColor = k.options.lineColor ? k.options.lineColor : n[0];\n          c.strokeStyle = n;\n          var x = !0,\n              s = 0,\n              z,\n              u;\n          c.beginPath();\n\n          if (0 < l.length) {\n            for (var m = !1, s = 0; s < l.length; s++) if (z = l[s].getTime ? l[s].x.getTime() : l[s].x, !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !m))) if (\"number\" !== typeof l[s].y) 0 < s && !(k.connectNullData || m || x) && (c.stroke(), v && b.stroke()), m = !0;else {\n              var B = u;\n              z = a.axisX.convertValueToPixel(z);\n              u = a.axisY.convertValueToPixel(l[s].y);\n              var D = k.dataPointIds[s];\n              this._eventManager.objectMap[D] = {\n                id: D,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: d,\n                dataPointIndex: s,\n                x1: z,\n                y1: u\n              };\n              x || m ? (!x && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), c.beginPath(), c.moveTo(r.x, r.y), p = k.nullDataLineDashType, c.setLineDash(q)), c.lineTo(z, B), c.lineTo(z, u), v && (b.lineTo(z, B), b.lineTo(z, u))) : (c.beginPath(), c.moveTo(z, u), v && (b.beginPath(), b.moveTo(z, u))), m = x = !1) : (c.lineTo(z, B), v && b.lineTo(z, B), c.lineTo(z, u), v && b.lineTo(z, u), 0 == s % 500 && (c.stroke(), c.beginPath(), c.moveTo(z, u), v && (b.stroke(), b.beginPath(), b.moveTo(z, u))));\n              r = {\n                x: z,\n                y: u\n              };\n              s < l.length - 1 && (w !== (l[s].lineColor || n) || p !== (l[s].lineDashType || k.lineDashType)) && (c.stroke(), c.beginPath(), c.moveTo(z, u), w = l[s].lineColor || n, c.strokeStyle = w, c.setLineDash && (l[s].lineDashType ? (p = l[s].lineDashType, c.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, c.setLineDash(g))));\n              0 !== l[s].markerSize && (0 < l[s].markerSize || 0 < k.markerSize) && (B = k.getMarkerProperties(s, z, u, c), h.push(B), D = W(D), v && h.push({\n                x: z,\n                y: u,\n                ctx: b,\n                type: B.type,\n                size: B.size,\n                color: D,\n                borderColor: D,\n                borderThickness: B.borderThickness\n              }));\n              (l[s].indexLabel || k.indexLabel || l[s].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"stepLine\",\n                dataPoint: l[s],\n                dataSeries: k,\n                point: {\n                  x: z,\n                  y: u\n                },\n                direction: 0 > l[s].y === a.axisY.reversed ? 1 : -1,\n                color: n\n              });\n            }\n\n            c.stroke();\n            v && b.stroke();\n          }\n        }\n\n        V.drawMarkers(h);\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), b.beginPath());\n        c.restore();\n        c.beginPath();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderSpline = function (a) {\n      function e(a) {\n        a = t(a, 2);\n\n        if (0 < a.length) {\n          b.beginPath();\n          v && f.beginPath();\n          b.moveTo(a[0].x, a[0].y);\n          a[0].newStrokeStyle && (b.strokeStyle = a[0].newStrokeStyle);\n          a[0].newLineDashArray && b.setLineDash(a[0].newLineDashArray);\n          v && f.moveTo(a[0].x, a[0].y);\n\n          for (var c = 0; c < a.length - 3; c += 3) if (b.bezierCurveTo(a[c + 1].x, a[c + 1].y, a[c + 2].x, a[c + 2].y, a[c + 3].x, a[c + 3].y), v && f.bezierCurveTo(a[c + 1].x, a[c + 1].y, a[c + 2].x, a[c + 2].y, a[c + 3].x, a[c + 3].y), 0 < c && 0 === c % 3E3 || a[c + 3].newStrokeStyle || a[c + 3].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(a[c + 3].x, a[c + 3].y), a[c + 3].newStrokeStyle && (b.strokeStyle = a[c + 3].newStrokeStyle), a[c + 3].newLineDashArray && b.setLineDash(a[c + 3].newLineDashArray), v && (f.stroke(), f.beginPath(), f.moveTo(a[c + 3].x, a[c + 3].y));\n\n          b.stroke();\n          v && f.stroke();\n        }\n      }\n\n      var c = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : c;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = this._eventManager.ghostCtx;\n        b.save();\n        var h = this.plotArea;\n        b.beginPath();\n        b.rect(h.x1, h.y1, h.width, h.height);\n        b.clip();\n\n        for (var r = [], y = 0; y < a.dataSeriesIndexes.length; y++) {\n          var d = a.dataSeriesIndexes[y],\n              k = this.data[d];\n          b.lineWidth = k.lineThickness;\n          var l = k.dataPoints,\n              p = \"solid\";\n\n          if (b.setLineDash) {\n            var q = G(k.nullDataLineDashType, k.lineThickness),\n                p = k.lineDashType,\n                g = G(p, k.lineThickness);\n            b.setLineDash(g);\n          }\n\n          var n = k.id;\n          this._eventManager.objectMap[n] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: d\n          };\n          n = W(n);\n          f.strokeStyle = n;\n          f.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;\n          var n = k._colorSet,\n              w = n = k.lineColor = k.options.lineColor ? k.options.lineColor : n[0];\n          b.strokeStyle = n;\n          var x = 0,\n              s,\n              z,\n              u = [];\n          b.beginPath();\n          if (0 < l.length) for (z = !1, x = 0; x < l.length; x++) if (s = l[x].getTime ? l[x].x.getTime() : l[x].x, !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !z))) if (\"number\" !== typeof l[x].y) 0 < x && !z && (k.connectNullData ? b.setLineDash && 0 < u.length && (k.options.nullDataLineDashType || !l[x - 1].lineDashType) && (u[u.length - 1].newLineDashArray = q, p = k.nullDataLineDashType) : (e(u), u = [])), z = !0;else {\n            s = a.axisX.convertValueToPixel(s);\n            z = a.axisY.convertValueToPixel(l[x].y);\n            var m = k.dataPointIds[x];\n            this._eventManager.objectMap[m] = {\n              id: m,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: d,\n              dataPointIndex: x,\n              x1: s,\n              y1: z\n            };\n            u[u.length] = {\n              x: s,\n              y: z\n            };\n            x < l.length - 1 && (w !== (l[x].lineColor || n) || p !== (l[x].lineDashType || k.lineDashType)) && (w = l[x].lineColor || n, u[u.length - 1].newStrokeStyle = w, b.setLineDash && (l[x].lineDashType ? (p = l[x].lineDashType, u[u.length - 1].newLineDashArray = G(p, k.lineThickness)) : (p = k.lineDashType, u[u.length - 1].newLineDashArray = g)));\n\n            if (0 !== l[x].markerSize && (0 < l[x].markerSize || 0 < k.markerSize)) {\n              var B = k.getMarkerProperties(x, s, z, b);\n              r.push(B);\n              m = W(m);\n              v && r.push({\n                x: s,\n                y: z,\n                ctx: f,\n                type: B.type,\n                size: B.size,\n                color: m,\n                borderColor: m,\n                borderThickness: B.borderThickness\n              });\n            }\n\n            (l[x].indexLabel || k.indexLabel || l[x].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({\n              chartType: \"spline\",\n              dataPoint: l[x],\n              dataSeries: k,\n              point: {\n                x: s,\n                y: z\n              },\n              direction: 0 > l[x].y === a.axisY.reversed ? 1 : -1,\n              color: n\n            });\n            z = !1;\n          }\n          e(u);\n        }\n\n        V.drawMarkers(r);\n        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), f.beginPath());\n        b.restore();\n        b.beginPath();\n        return {\n          source: c,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderColumn = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = 0,\n            r,\n            y,\n            d,\n            k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            l = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0,\n            p = a.axisX.dataInfo.minDiff;\n        isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));\n        p = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n        this.dataPointMaxWidth && h > l && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && l < h && (l = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, h));\n        p < h && (p = h);\n        p > l && (p = l);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var q = a.dataSeriesIndexes[l],\n              g = this.data[q],\n              n = g.dataPoints;\n          if (0 < n.length) for (var w = 5 < p && g.bevelEnabled ? !0 : !1, h = 0; h < n.length; h++) if (n[h].getTime ? d = n[h].x.getTime() : d = n[h].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof n[h].y) {\n            r = a.axisX.convertValueToPixel(d);\n            y = a.axisY.convertValueToPixel(n[h].y);\n            r = a.axisX.reversed ? r + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + l) * p << 0 : r - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + l) * p << 0;\n            var x = a.axisX.reversed ? r - p << 0 : r + p << 0,\n                s;\n            0 <= n[h].y ? s = k : (s = y, y = k);\n            y > s && (b = y, y = s, s = b);\n            b = n[h].color ? n[h].color : g._colorSet[h % g._colorSet.length];\n            aa(c, a.axisX.reversed ? x : r, y, a.axisX.reversed ? r : x, s, b, 0, null, w && (a.axisY.reversed ? 0 > n[h].y : 0 <= n[h].y), (a.axisY.reversed ? 0 <= n[h].y : 0 > n[h].y) && w, !1, !1, g.fillOpacity);\n            b = g.dataPointIds[h];\n            this._eventManager.objectMap[b] = {\n              id: b,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: q,\n              dataPointIndex: h,\n              x1: r,\n              y1: y,\n              x2: x,\n              y2: s\n            };\n            b = W(b);\n            v && aa(this._eventManager.ghostCtx, a.axisX.reversed ? x : r, y, a.axisX.reversed ? r : x, s, b, 0, null, !1, !1, !1, !1);\n            (n[h].indexLabel || g.indexLabel || n[h].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({\n              chartType: \"column\",\n              dataPoint: n[h],\n              dataSeries: g,\n              point: {\n                x: r + (x - r) / 2,\n                y: 0 > n[h].y === a.axisY.reversed ? y : s\n              },\n              direction: 0 > n[h].y === a.axisY.reversed ? 1 : -1,\n              bounds: {\n                x1: r,\n                y1: Math.min(y, s),\n                x2: x,\n                y2: Math.max(y, s)\n              },\n              color: b\n            });\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.yScaleAnimation,\n          easingFunction: K.easing.easeOutQuart,\n          animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k\n        };\n      }\n    };\n\n    m.prototype.renderStackedColumn = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = [],\n            r = [],\n            y = [],\n            d = [],\n            k = 0,\n            l,\n            p,\n            q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0,\n            n = a.axisX.dataInfo.minDiff;\n        isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));\n        n = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n        this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));\n        n < k && (n = k);\n        n > g && (n = g);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (g = 0; g < a.dataSeriesIndexes.length; g++) {\n          var w = a.dataSeriesIndexes[g],\n              x = this.data[w],\n              s = x.dataPoints;\n\n          if (0 < s.length) {\n            var z = 5 < n && x.bevelEnabled ? !0 : !1;\n            c.strokeStyle = \"#4572A7 \";\n\n            for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof s[k].y) {\n              l = a.axisX.convertValueToPixel(b);\n              l = l - a.plotType.plotUnits.length * n / 2 + a.index * n << 0;\n              var u = l + n << 0,\n                  m;\n              if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) y[b] = s[k].y + (y[b] ? y[b] : 0), 0 < y[b] && (p = a.axisY.convertValueToPixel(y[b]), m = \"undefined\" !== typeof h[b] ? h[b] : q, h[b] = p);else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) d[b] = s[k].y + (d[b] ? d[b] : 0), m = a.axisY.convertValueToPixel(d[b]), p = \"undefined\" !== typeof r[b] ? r[b] : q, r[b] = m;else if (p = a.axisY.convertValueToPixel(s[k].y), 0 <= s[k].y) {\n                var B = \"undefined\" !== typeof h[b] ? h[b] : 0;\n                p -= B;\n                m = q - B;\n                h[b] = B + (m - p);\n              } else B = r[b] ? r[b] : 0, m = p + B, p = q + B, r[b] = B + (m - p);\n              b = s[k].color ? s[k].color : x._colorSet[k % x._colorSet.length];\n              aa(c, l, a.axisY.reversed ? m : p, u, a.axisY.reversed ? p : m, b, 0, null, z && (a.axisY.reversed ? 0 > s[k].y : 0 <= s[k].y), (a.axisY.reversed ? 0 <= s[k].y : 0 > s[k].y) && z, !1, !1, x.fillOpacity);\n              b = x.dataPointIds[k];\n              this._eventManager.objectMap[b] = {\n                id: b,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: w,\n                dataPointIndex: k,\n                x1: l,\n                y1: p,\n                x2: u,\n                y2: m\n              };\n              b = W(b);\n              v && aa(this._eventManager.ghostCtx, l, p, u, m, b, 0, null, !1, !1, !1, !1);\n              (s[k].indexLabel || x.indexLabel || s[k].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"stackedColumn\",\n                dataPoint: s[k],\n                dataSeries: x,\n                point: {\n                  x: l + (u - l) / 2,\n                  y: 0 <= s[k].y ? p : m\n                },\n                direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,\n                bounds: {\n                  x1: l,\n                  y1: Math.min(p, m),\n                  x2: u,\n                  y2: Math.max(p, m)\n                },\n                color: b\n              });\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.yScaleAnimation,\n          easingFunction: K.easing.easeOutQuart,\n          animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q\n        };\n      }\n    };\n\n    m.prototype.renderStackedColumn100 = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = [],\n            r = [],\n            y = [],\n            d = [],\n            k = 0,\n            l,\n            p,\n            q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0,\n            n = a.axisX.dataInfo.minDiff;\n        isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));\n        n = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n        this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));\n        n < k && (n = k);\n        n > g && (n = g);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (g = 0; g < a.dataSeriesIndexes.length; g++) {\n          var w = a.dataSeriesIndexes[g],\n              x = this.data[w],\n              s = x.dataPoints;\n          if (0 < s.length) for (var m = 5 < n && x.bevelEnabled ? !0 : !1, k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof s[k].y) {\n            l = a.axisX.convertValueToPixel(b);\n            p = 0 !== a.dataPointYSums[b] ? 100 * (s[k].y / a.dataPointYSums[b]) : 0;\n            l = l - a.plotType.plotUnits.length * n / 2 + a.index * n << 0;\n            var u = l + n << 0,\n                t;\n\n            if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) {\n              y[b] = p + (\"undefined\" !== typeof y[b] ? y[b] : 0);\n              if (0 >= y[b]) continue;\n              p = a.axisY.convertValueToPixel(y[b]);\n              t = h[b] ? h[b] : q;\n              h[b] = p;\n            } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) d[b] = p + (\"undefined\" !== typeof d[b] ? d[b] : 0), t = a.axisY.convertValueToPixel(d[b]), p = r[b] ? r[b] : q, r[b] = t;else if (p = a.axisY.convertValueToPixel(p), 0 <= s[k].y) {\n              var B = \"undefined\" !== typeof h[b] ? h[b] : 0;\n              p -= B;\n              t = q - B;\n              a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.y1 - p) && (p = f.y1);\n              h[b] = B + (t - p);\n            } else B = \"undefined\" !== typeof r[b] ? r[b] : 0, t = p + B, p = q + B, a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.y2 - t) && (t = f.y2), r[b] = B + (t - p);\n\n            b = s[k].color ? s[k].color : x._colorSet[k % x._colorSet.length];\n            aa(c, l, a.axisY.reversed ? t : p, u, a.axisY.reversed ? p : t, b, 0, null, m && (a.axisY.reversed ? 0 > s[k].y : 0 <= s[k].y), (a.axisY.reversed ? 0 <= s[k].y : 0 > s[k].y) && m, !1, !1, x.fillOpacity);\n            b = x.dataPointIds[k];\n            this._eventManager.objectMap[b] = {\n              id: b,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: w,\n              dataPointIndex: k,\n              x1: l,\n              y1: p,\n              x2: u,\n              y2: t\n            };\n            b = W(b);\n            v && aa(this._eventManager.ghostCtx, l, p, u, t, b, 0, null, !1, !1, !1, !1);\n            (s[k].indexLabel || x.indexLabel || s[k].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({\n              chartType: \"stackedColumn100\",\n              dataPoint: s[k],\n              dataSeries: x,\n              point: {\n                x: l + (u - l) / 2,\n                y: 0 <= s[k].y ? p : t\n              },\n              direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,\n              bounds: {\n                x1: l,\n                y1: Math.min(p, t),\n                x2: u,\n                y2: Math.max(p, t)\n              },\n              color: b\n            });\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.yScaleAnimation,\n          easingFunction: K.easing.easeOutQuart,\n          animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q\n        };\n      }\n    };\n\n    m.prototype.renderBar = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = 0,\n            r,\n            d,\n            n,\n            k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            l = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0,\n            p = a.axisX.dataInfo.minDiff;\n        isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));\n        p = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n        this.dataPointMaxWidth && h > l && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && l < h && (l = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, h));\n        p < h && (p = h);\n        p > l && (p = l);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var q = a.dataSeriesIndexes[l],\n              g = this.data[q],\n              m = g.dataPoints;\n\n          if (0 < m.length) {\n            var w = 5 < p && g.bevelEnabled ? !0 : !1;\n            c.strokeStyle = \"#4572A7 \";\n\n            for (h = 0; h < m.length; h++) if (m[h].getTime ? n = m[h].x.getTime() : n = m[h].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof m[h].y) {\n              d = a.axisX.convertValueToPixel(n);\n              r = a.axisY.convertValueToPixel(m[h].y);\n              d = a.axisX.reversed ? d + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + l) * p << 0 : d - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + l) * p << 0;\n              var x = a.axisX.reversed ? d - p << 0 : d + p << 0,\n                  s;\n              0 <= m[h].y ? s = k : (s = r, r = k);\n              b = m[h].color ? m[h].color : g._colorSet[h % g._colorSet.length];\n              aa(c, a.axisY.reversed ? r : s, a.axisX.reversed ? x : d, a.axisY.reversed ? s : r, a.axisX.reversed ? d : x, b, 0, null, w, !1, !1, !1, g.fillOpacity);\n              b = g.dataPointIds[h];\n              this._eventManager.objectMap[b] = {\n                id: b,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: q,\n                dataPointIndex: h,\n                x1: s,\n                y1: d,\n                x2: r,\n                y2: x\n              };\n              b = W(b);\n              v && aa(this._eventManager.ghostCtx, s, a.axisX.reversed ? x : d, r, a.axisX.reversed ? d : x, b, 0, null, !1, !1, !1, !1);\n              (m[h].indexLabel || g.indexLabel || m[h].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"bar\",\n                dataPoint: m[h],\n                dataSeries: g,\n                point: {\n                  x: 0 <= m[h].y ? r : s,\n                  y: d + (x - d) / 2\n                },\n                direction: 0 > m[h].y === a.axisY.reversed ? 1 : -1,\n                bounds: {\n                  x1: Math.min(s, r),\n                  y1: d,\n                  x2: Math.max(s, r),\n                  y2: x\n                },\n                color: b\n              });\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xScaleAnimation,\n          easingFunction: K.easing.easeOutQuart,\n          animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k\n        };\n      }\n    };\n\n    m.prototype.renderStackedBar = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = [],\n            r = [],\n            d = [],\n            n = [],\n            k = 0,\n            l,\n            p,\n            q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0,\n            m = a.axisX.dataInfo.minDiff;\n        isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));\n        m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.height * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n        this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));\n        m < k && (m = k);\n        m > g && (m = g);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (g = 0; g < a.dataSeriesIndexes.length; g++) {\n          var w = a.dataSeriesIndexes[g],\n              x = this.data[w],\n              s = x.dataPoints;\n\n          if (0 < s.length) {\n            var z = 5 < m && x.bevelEnabled ? !0 : !1;\n            c.strokeStyle = \"#4572A7 \";\n\n            for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof s[k].y) {\n              p = a.axisX.convertValueToPixel(b);\n              p = p - a.plotType.plotUnits.length * m / 2 + a.index * m << 0;\n              var u = p + m << 0,\n                  t;\n              if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) d[b] = s[k].y + (d[b] ? d[b] : 0), 0 < d[b] && (t = h[b] ? h[b] : q, h[b] = l = a.axisY.convertValueToPixel(d[b]));else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) n[b] = s[k].y + (n[b] ? n[b] : 0), l = r[b] ? r[b] : q, r[b] = t = a.axisY.convertValueToPixel(n[b]);else if (l = a.axisY.convertValueToPixel(s[k].y), 0 <= s[k].y) {\n                var B = h[b] ? h[b] : 0;\n                t = q + B;\n                l += B;\n                h[b] = B + (l - t);\n              } else B = r[b] ? r[b] : 0, t = l - B, l = q - B, r[b] = B + (l - t);\n              b = s[k].color ? s[k].color : x._colorSet[k % x._colorSet.length];\n              aa(c, a.axisY.reversed ? l : t, p, a.axisY.reversed ? t : l, u, b, 0, null, z, !1, !1, !1, x.fillOpacity);\n              b = x.dataPointIds[k];\n              this._eventManager.objectMap[b] = {\n                id: b,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: w,\n                dataPointIndex: k,\n                x1: t,\n                y1: p,\n                x2: l,\n                y2: u\n              };\n              b = W(b);\n              v && aa(this._eventManager.ghostCtx, t, p, l, u, b, 0, null, !1, !1, !1, !1);\n              (s[k].indexLabel || x.indexLabel || s[k].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"stackedBar\",\n                dataPoint: s[k],\n                dataSeries: x,\n                point: {\n                  x: 0 <= s[k].y ? l : t,\n                  y: p + (u - p) / 2\n                },\n                direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,\n                bounds: {\n                  x1: Math.min(t, l),\n                  y1: p,\n                  x2: Math.max(t, l),\n                  y2: u\n                },\n                color: b\n              });\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xScaleAnimation,\n          easingFunction: K.easing.easeOutQuart,\n          animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q\n        };\n      }\n    };\n\n    m.prototype.renderStackedBar100 = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = [],\n            r = [],\n            d = [],\n            n = [],\n            k = 0,\n            l,\n            p,\n            q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0,\n            m = a.axisX.dataInfo.minDiff;\n        isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));\n        m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.height * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n        this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));\n        m < k && (m = k);\n        m > g && (m = g);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (g = 0; g < a.dataSeriesIndexes.length; g++) {\n          var w = a.dataSeriesIndexes[g],\n              x = this.data[w],\n              s = x.dataPoints;\n\n          if (0 < s.length) {\n            var z = 5 < m && x.bevelEnabled ? !0 : !1;\n            c.strokeStyle = \"#4572A7 \";\n\n            for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof s[k].y) {\n              p = a.axisX.convertValueToPixel(b);\n              var u;\n              u = 0 !== a.dataPointYSums[b] ? 100 * (s[k].y / a.dataPointYSums[b]) : 0;\n              p = p - a.plotType.plotUnits.length * m / 2 + a.index * m << 0;\n              var t = p + m << 0;\n\n              if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) {\n                d[b] = u + (d[b] ? d[b] : 0);\n                if (0 >= d[b]) continue;\n                u = h[b] ? h[b] : q;\n                h[b] = l = a.axisY.convertValueToPixel(d[b]);\n              } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) n[b] = u + (n[b] ? n[b] : 0), l = r[b] ? r[b] : q, r[b] = u = a.axisY.convertValueToPixel(n[b]);else if (l = a.axisY.convertValueToPixel(u), 0 <= s[k].y) {\n                var B = h[b] ? h[b] : 0;\n                u = q + B;\n                l += B;\n                a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.x2 - l) && (l = f.x2);\n                h[b] = B + (l - u);\n              } else B = r[b] ? r[b] : 0, u = l - B, l = q - B, a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.x1 - u) && (u = f.x1), r[b] = B + (l - u);\n\n              b = s[k].color ? s[k].color : x._colorSet[k % x._colorSet.length];\n              aa(c, a.axisY.reversed ? l : u, p, a.axisY.reversed ? u : l, t, b, 0, null, z, !1, !1, !1, x.fillOpacity);\n              b = x.dataPointIds[k];\n              this._eventManager.objectMap[b] = {\n                id: b,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: w,\n                dataPointIndex: k,\n                x1: u,\n                y1: p,\n                x2: l,\n                y2: t\n              };\n              b = W(b);\n              v && aa(this._eventManager.ghostCtx, u, p, l, t, b, 0, null, !1, !1, !1, !1);\n              (s[k].indexLabel || x.indexLabel || s[k].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"stackedBar100\",\n                dataPoint: s[k],\n                dataSeries: x,\n                point: {\n                  x: 0 <= s[k].y ? l : u,\n                  y: p + (t - p) / 2\n                },\n                direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,\n                bounds: {\n                  x1: Math.min(u, l),\n                  y1: p,\n                  x2: Math.max(u, l),\n                  y2: t\n                },\n                color: b\n              });\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xScaleAnimation,\n          easingFunction: K.easing.easeOutQuart,\n          animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q\n        };\n      }\n    };\n\n    m.prototype.renderArea = function (a) {\n      var e, c;\n\n      function b() {\n        B && (0 < g.lineThickness && h.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t = u : 0 > a.axisY.viewportMaximum ? t = d.y1 : 0 < a.axisY.viewportMinimum && (t = u), h.lineTo(x, t), h.lineTo(B.x, t), h.closePath(), h.globalAlpha = g.fillOpacity, h.fill(), h.globalAlpha = 1, v && (r.lineTo(x, t), r.lineTo(B.x, t), r.closePath(), r.fill()), h.beginPath(), h.moveTo(x, s), r.beginPath(), r.moveTo(x, s), B = {\n          x: x,\n          y: s\n        });\n      }\n\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          h = v ? this._preRenderCtx : f;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var r = this._eventManager.ghostCtx,\n            d = a.axisY.lineCoordinates,\n            n = [],\n            k = this.plotArea,\n            l;\n        h.save();\n        v && r.save();\n        h.beginPath();\n        h.rect(k.x1, k.y1, k.width, k.height);\n        h.clip();\n        v && (r.beginPath(), r.rect(k.x1, k.y1, k.width, k.height), r.clip());\n\n        for (var p = 0; p < a.dataSeriesIndexes.length; p++) {\n          var q = a.dataSeriesIndexes[p],\n              g = this.data[q],\n              m = g.dataPoints,\n              n = g.id;\n          this._eventManager.objectMap[n] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: q\n          };\n          n = W(n);\n          r.fillStyle = n;\n          n = [];\n          e = !0;\n          var w = 0,\n              x,\n              s,\n              z,\n              u = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n              t,\n              B = null;\n\n          if (0 < m.length) {\n            var D = g._colorSet[w % g._colorSet.length],\n                A = g.lineColor = g.options.lineColor || D,\n                C = A;\n            h.fillStyle = D;\n            h.strokeStyle = A;\n            h.lineWidth = g.lineThickness;\n            c = \"solid\";\n\n            if (h.setLineDash) {\n              var J = G(g.nullDataLineDashType, g.lineThickness);\n              c = g.lineDashType;\n              var T = G(c, g.lineThickness);\n              h.setLineDash(T);\n            }\n\n            for (var ba = !0; w < m.length; w++) if (z = m[w].x.getTime ? m[w].x.getTime() : m[w].x, !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !ba))) if (\"number\" !== typeof m[w].y) g.connectNullData || ba || e || b(), ba = !0;else {\n              x = a.axisX.convertValueToPixel(z);\n              s = a.axisY.convertValueToPixel(m[w].y);\n              e || ba ? (!e && g.connectNullData ? (h.setLineDash && (g.options.nullDataLineDashType || c === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (e = x, c = s, x = l.x, s = l.y, b(), h.moveTo(l.x, l.y), x = e, s = c, B = l, c = g.nullDataLineDashType, h.setLineDash(J)), h.lineTo(x, s), v && r.lineTo(x, s)) : (h.beginPath(), h.moveTo(x, s), v && (r.beginPath(), r.moveTo(x, s)), B = {\n                x: x,\n                y: s\n              }), ba = e = !1) : (h.lineTo(x, s), v && r.lineTo(x, s), 0 == w % 250 && b());\n              l = {\n                x: x,\n                y: s\n              };\n              w < m.length - 1 && (C !== (m[w].lineColor || A) || c !== (m[w].lineDashType || g.lineDashType)) && (b(), C = m[w].lineColor || A, h.strokeStyle = C, h.setLineDash && (m[w].lineDashType ? (c = m[w].lineDashType, h.setLineDash(G(c, g.lineThickness))) : (c = g.lineDashType, h.setLineDash(T))));\n              var Z = g.dataPointIds[w];\n              this._eventManager.objectMap[Z] = {\n                id: Z,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: q,\n                dataPointIndex: w,\n                x1: x,\n                y1: s\n              };\n              0 !== m[w].markerSize && (0 < m[w].markerSize || 0 < g.markerSize) && (z = g.getMarkerProperties(w, x, s, h), n.push(z), Z = W(Z), v && n.push({\n                x: x,\n                y: s,\n                ctx: r,\n                type: z.type,\n                size: z.size,\n                color: Z,\n                borderColor: Z,\n                borderThickness: z.borderThickness\n              }));\n              (m[w].indexLabel || g.indexLabel || m[w].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"area\",\n                dataPoint: m[w],\n                dataSeries: g,\n                point: {\n                  x: x,\n                  y: s\n                },\n                direction: 0 > m[w].y === a.axisY.reversed ? 1 : -1,\n                color: D\n              });\n            }\n\n            b();\n            V.drawMarkers(n);\n          }\n        }\n\n        v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), h.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && h.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && h.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), h.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());\n        h.restore();\n        return {\n          source: f,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderSplineArea = function (a) {\n      function e() {\n        var c = t(z, 2);\n\n        if (0 < c.length) {\n          if (0 < l.lineThickness) {\n            b.beginPath();\n            b.moveTo(c[0].x, c[0].y);\n            c[0].newStrokeStyle && (b.strokeStyle = c[0].newStrokeStyle);\n            c[0].newLineDashArray && b.setLineDash(c[0].newLineDashArray);\n\n            for (var g = 0; g < c.length - 3; g += 3) if (b.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y), v && f.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y), c[g + 3].newStrokeStyle || c[g + 3].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(c[g + 3].x, c[g + 3].y), c[g + 3].newStrokeStyle && (b.strokeStyle = c[g + 3].newStrokeStyle), c[g + 3].newLineDashArray && b.setLineDash(c[g + 3].newLineDashArray);\n\n            b.stroke();\n          }\n\n          b.beginPath();\n          b.moveTo(c[0].x, c[0].y);\n          v && (f.beginPath(), f.moveTo(c[0].x, c[0].y));\n\n          for (g = 0; g < c.length - 3; g += 3) b.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y), v && f.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y);\n\n          a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? x = w : 0 > a.axisY.viewportMaximum ? x = h.y1 : 0 < a.axisY.viewportMinimum && (x = w);\n          s = {\n            x: c[0].x,\n            y: c[0].y\n          };\n          b.lineTo(c[c.length - 1].x, x);\n          b.lineTo(s.x, x);\n          b.closePath();\n          b.globalAlpha = l.fillOpacity;\n          b.fill();\n          b.globalAlpha = 1;\n          v && (f.lineTo(c[c.length - 1].x, x), f.lineTo(s.x, x), f.closePath(), f.fill());\n        }\n      }\n\n      var c = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : c;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = this._eventManager.ghostCtx,\n            h = a.axisY.lineCoordinates,\n            r = [],\n            d = this.plotArea;\n        b.save();\n        v && f.save();\n        b.beginPath();\n        b.rect(d.x1, d.y1, d.width, d.height);\n        b.clip();\n        v && (f.beginPath(), f.rect(d.x1, d.y1, d.width, d.height), f.clip());\n\n        for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\n          var k = a.dataSeriesIndexes[n],\n              l = this.data[k],\n              p = l.dataPoints,\n              r = l.id;\n          this._eventManager.objectMap[r] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: k\n          };\n          r = W(r);\n          f.fillStyle = r;\n          var r = [],\n              q = 0,\n              g,\n              m,\n              w = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n              x,\n              s = null,\n              z = [];\n\n          if (0 < p.length) {\n            var u = l._colorSet[q % l._colorSet.length],\n                A = l.lineColor = l.options.lineColor || u,\n                B = A;\n            b.fillStyle = u;\n            b.strokeStyle = A;\n            b.lineWidth = l.lineThickness;\n            var D = \"solid\";\n\n            if (b.setLineDash) {\n              var C = G(l.nullDataLineDashType, l.lineThickness),\n                  D = l.lineDashType,\n                  db = G(D, l.lineThickness);\n              b.setLineDash(db);\n            }\n\n            for (m = !1; q < p.length; q++) if (g = p[q].x.getTime ? p[q].x.getTime() : p[q].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!l.connectNullData || !m))) if (\"number\" !== typeof p[q].y) 0 < q && !m && (l.connectNullData ? b.setLineDash && 0 < z.length && (l.options.nullDataLineDashType || !p[q - 1].lineDashType) && (z[z.length - 1].newLineDashArray = C, D = l.nullDataLineDashType) : (e(), z = [])), m = !0;else {\n              g = a.axisX.convertValueToPixel(g);\n              m = a.axisY.convertValueToPixel(p[q].y);\n              var J = l.dataPointIds[q];\n              this._eventManager.objectMap[J] = {\n                id: J,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: k,\n                dataPointIndex: q,\n                x1: g,\n                y1: m\n              };\n              z[z.length] = {\n                x: g,\n                y: m\n              };\n              q < p.length - 1 && (B !== (p[q].lineColor || A) || D !== (p[q].lineDashType || l.lineDashType)) && (B = p[q].lineColor || A, z[z.length - 1].newStrokeStyle = B, b.setLineDash && (p[q].lineDashType ? (D = p[q].lineDashType, z[z.length - 1].newLineDashArray = G(D, l.lineThickness)) : (D = l.lineDashType, z[z.length - 1].newLineDashArray = db)));\n\n              if (0 !== p[q].markerSize && (0 < p[q].markerSize || 0 < l.markerSize)) {\n                var T = l.getMarkerProperties(q, g, m, b);\n                r.push(T);\n                J = W(J);\n                v && r.push({\n                  x: g,\n                  y: m,\n                  ctx: f,\n                  type: T.type,\n                  size: T.size,\n                  color: J,\n                  borderColor: J,\n                  borderThickness: T.borderThickness\n                });\n              }\n\n              (p[q].indexLabel || l.indexLabel || p[q].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"splineArea\",\n                dataPoint: p[q],\n                dataSeries: l,\n                point: {\n                  x: g,\n                  y: m\n                },\n                direction: 0 > p[q].y === a.axisY.reversed ? 1 : -1,\n                color: u\n              });\n              m = !1;\n            }\n\n            e();\n            V.drawMarkers(r);\n          }\n        }\n\n        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());\n        b.restore();\n        return {\n          source: c,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderStepArea = function (a) {\n      var e, c;\n\n      function b() {\n        B && (0 < g.lineThickness && h.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t = u : 0 > a.axisY.viewportMaximum ? t = d.y1 : 0 < a.axisY.viewportMinimum && (t = u), h.lineTo(x, t), h.lineTo(B.x, t), h.closePath(), h.globalAlpha = g.fillOpacity, h.fill(), h.globalAlpha = 1, v && (r.lineTo(x, t), r.lineTo(B.x, t), r.closePath(), r.fill()), h.beginPath(), h.moveTo(x, s), r.beginPath(), r.moveTo(x, s), B = {\n          x: x,\n          y: s\n        });\n      }\n\n      var f = a.targetCanvasCtx || this.plotArea.ctx,\n          h = v ? this._preRenderCtx : f;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var r = this._eventManager.ghostCtx,\n            d = a.axisY.lineCoordinates,\n            n = [],\n            k = this.plotArea,\n            l;\n        h.save();\n        v && r.save();\n        h.beginPath();\n        h.rect(k.x1, k.y1, k.width, k.height);\n        h.clip();\n        v && (r.beginPath(), r.rect(k.x1, k.y1, k.width, k.height), r.clip());\n\n        for (var p = 0; p < a.dataSeriesIndexes.length; p++) {\n          var q = a.dataSeriesIndexes[p],\n              g = this.data[q],\n              m = g.dataPoints,\n              n = g.id;\n          this._eventManager.objectMap[n] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: q\n          };\n          n = W(n);\n          r.fillStyle = n;\n          n = [];\n          e = !0;\n          var w = 0,\n              x,\n              s,\n              z,\n              u = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n              t,\n              B = null;\n          c = !1;\n\n          if (0 < m.length) {\n            var D = g._colorSet[w % g._colorSet.length],\n                A = g.lineColor = g.options.lineColor || D,\n                C = A;\n            h.fillStyle = D;\n            h.strokeStyle = A;\n            h.lineWidth = g.lineThickness;\n            var J = \"solid\";\n\n            if (h.setLineDash) {\n              var T = G(g.nullDataLineDashType, g.lineThickness),\n                  J = g.lineDashType,\n                  ba = G(J, g.lineThickness);\n              h.setLineDash(ba);\n            }\n\n            for (; w < m.length; w++) if (z = m[w].x.getTime ? m[w].x.getTime() : m[w].x, !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !c))) {\n              var Z = s;\n              \"number\" !== typeof m[w].y ? (g.connectNullData || c || e || b(), c = !0) : (x = a.axisX.convertValueToPixel(z), s = a.axisY.convertValueToPixel(m[w].y), e || c ? (!e && g.connectNullData ? (h.setLineDash && (g.options.nullDataLineDashType || J === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (e = x, c = s, x = l.x, s = l.y, b(), h.moveTo(l.x, l.y), x = e, s = c, B = l, J = g.nullDataLineDashType, h.setLineDash(T)), h.lineTo(x, Z), h.lineTo(x, s), v && (r.lineTo(x, Z), r.lineTo(x, s))) : (h.beginPath(), h.moveTo(x, s), v && (r.beginPath(), r.moveTo(x, s)), B = {\n                x: x,\n                y: s\n              }), c = e = !1) : (h.lineTo(x, Z), v && r.lineTo(x, Z), h.lineTo(x, s), v && r.lineTo(x, s), 0 == w % 250 && b()), l = {\n                x: x,\n                y: s\n              }, w < m.length - 1 && (C !== (m[w].lineColor || A) || J !== (m[w].lineDashType || g.lineDashType)) && (b(), C = m[w].lineColor || A, h.strokeStyle = C, h.setLineDash && (m[w].lineDashType ? (J = m[w].lineDashType, h.setLineDash(G(J, g.lineThickness))) : (J = g.lineDashType, h.setLineDash(ba)))), z = g.dataPointIds[w], this._eventManager.objectMap[z] = {\n                id: z,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: q,\n                dataPointIndex: w,\n                x1: x,\n                y1: s\n              }, 0 !== m[w].markerSize && (0 < m[w].markerSize || 0 < g.markerSize) && (Z = g.getMarkerProperties(w, x, s, h), n.push(Z), z = W(z), v && n.push({\n                x: x,\n                y: s,\n                ctx: r,\n                type: Z.type,\n                size: Z.size,\n                color: z,\n                borderColor: z,\n                borderThickness: Z.borderThickness\n              })), (m[w].indexLabel || g.indexLabel || m[w].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"stepArea\",\n                dataPoint: m[w],\n                dataSeries: g,\n                point: {\n                  x: x,\n                  y: s\n                },\n                direction: 0 > m[w].y === a.axisY.reversed ? 1 : -1,\n                color: D\n              }));\n            }\n\n            b();\n            V.drawMarkers(n);\n          }\n        }\n\n        v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), h.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && h.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && h.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), h.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());\n        h.restore();\n        return {\n          source: f,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderStackedArea = function (a) {\n      function e() {\n        if (!(1 > k.length)) {\n          for (0 < D.lineThickness && b.stroke(); 0 < k.length;) {\n            var a = k.pop();\n            b.lineTo(a.x, a.y);\n            v && x.lineTo(a.x, a.y);\n          }\n\n          b.closePath();\n          b.globalAlpha = D.fillOpacity;\n          b.fill();\n          b.globalAlpha = 1;\n          b.beginPath();\n          v && (x.closePath(), x.fill(), x.beginPath());\n          k = [];\n        }\n      }\n\n      var c = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : c;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = null,\n            h = null,\n            r = [],\n            d = this.plotArea,\n            n = [],\n            k = [],\n            l = [],\n            p = [],\n            q = 0,\n            g,\n            m,\n            w = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            x = this._eventManager.ghostCtx,\n            s,\n            z,\n            u;\n        v && x.beginPath();\n        b.save();\n        v && x.save();\n        b.beginPath();\n        b.rect(d.x1, d.y1, d.width, d.height);\n        b.clip();\n        v && (x.beginPath(), x.rect(d.x1, d.y1, d.width, d.height), x.clip());\n\n        for (var f = [], t = 0; t < a.dataSeriesIndexes.length; t++) {\n          var B = a.dataSeriesIndexes[t],\n              D = this.data[B],\n              A = D.dataPoints;\n          D.dataPointIndexes = [];\n\n          for (q = 0; q < A.length; q++) B = A[q].x.getTime ? A[q].x.getTime() : A[q].x, D.dataPointIndexes[B] = q, f[B] || (l.push(B), f[B] = !0);\n\n          l.sort(Sa);\n        }\n\n        for (t = 0; t < a.dataSeriesIndexes.length; t++) {\n          B = a.dataSeriesIndexes[t];\n          D = this.data[B];\n          A = D.dataPoints;\n          z = !0;\n          k = [];\n          q = D.id;\n          this._eventManager.objectMap[q] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: B\n          };\n          q = W(q);\n          x.fillStyle = q;\n\n          if (0 < l.length) {\n            var f = D._colorSet[0],\n                C = D.lineColor = D.options.lineColor || f,\n                J = C;\n            b.fillStyle = f;\n            b.strokeStyle = C;\n            b.lineWidth = D.lineThickness;\n            u = \"solid\";\n\n            if (b.setLineDash) {\n              var T = G(D.nullDataLineDashType, D.lineThickness);\n              u = D.lineDashType;\n              var ba = G(u, D.lineThickness);\n              b.setLineDash(ba);\n            }\n\n            for (var Z = !0, q = 0; q < l.length; q++) {\n              var h = l[q],\n                  ga = null,\n                  ga = 0 <= D.dataPointIndexes[h] ? A[D.dataPointIndexes[h]] : {\n                x: h,\n                y: null\n              };\n              if (!(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax && (!D.connectNullData || !Z))) if (\"number\" !== typeof ga.y) D.connectNullData || Z || z || e(), Z = !0;else {\n                g = a.axisX.convertValueToPixel(h);\n                var oa = n[h] ? n[h] : 0;\n\n                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\n                  p[h] = ga.y + (p[h] ? p[h] : 0);\n                  if (0 >= p[h] && a.axisY.logarithmic) continue;\n                  m = a.axisY.convertValueToPixel(p[h]);\n                } else m = a.axisY.convertValueToPixel(ga.y), m -= oa;\n\n                k.push({\n                  x: g,\n                  y: w - oa\n                });\n                n[h] = w - m;\n                z || Z ? (!z && D.connectNullData ? (b.setLineDash && (D.options.nullDataLineDashType || u === D.lineDashType && D.lineDashType !== D.nullDataLineDashType) && (z = k.pop(), u = k[k.length - 1], e(), b.moveTo(s.x, s.y), k.push(u), k.push(z), u = D.nullDataLineDashType, b.setLineDash(T)), b.lineTo(g, m), v && x.lineTo(g, m)) : (b.beginPath(), b.moveTo(g, m), v && (x.beginPath(), x.moveTo(g, m))), Z = z = !1) : (b.lineTo(g, m), v && x.lineTo(g, m), 0 == q % 250 && (e(), b.moveTo(g, m), v && x.moveTo(g, m), k.push({\n                  x: g,\n                  y: w - oa\n                })));\n                s = {\n                  x: g,\n                  y: m\n                };\n                q < A.length - 1 && (J !== (A[q].lineColor || C) || u !== (A[q].lineDashType || D.lineDashType)) && (e(), b.beginPath(), b.moveTo(g, m), k.push({\n                  x: g,\n                  y: w - oa\n                }), J = A[q].lineColor || C, b.strokeStyle = J, b.setLineDash && (A[q].lineDashType ? (u = A[q].lineDashType, b.setLineDash(G(u, D.lineThickness))) : (u = D.lineDashType, b.setLineDash(ba))));\n\n                if (0 <= D.dataPointIndexes[h]) {\n                  var ka = D.dataPointIds[D.dataPointIndexes[h]];\n                  this._eventManager.objectMap[ka] = {\n                    id: ka,\n                    objectType: \"dataPoint\",\n                    dataSeriesIndex: B,\n                    dataPointIndex: D.dataPointIndexes[h],\n                    x1: g,\n                    y1: m\n                  };\n                }\n\n                0 <= D.dataPointIndexes[h] && 0 !== ga.markerSize && (0 < ga.markerSize || 0 < D.markerSize) && (oa = D.getMarkerProperties(D.dataPointIndexes[h], g, m, b), r.push(oa), h = W(ka), v && r.push({\n                  x: g,\n                  y: m,\n                  ctx: x,\n                  type: oa.type,\n                  size: oa.size,\n                  color: h,\n                  borderColor: h,\n                  borderThickness: oa.borderThickness\n                }));\n                (ga.indexLabel || D.indexLabel || ga.indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({\n                  chartType: \"stackedArea\",\n                  dataPoint: ga,\n                  dataSeries: D,\n                  point: {\n                    x: g,\n                    y: m\n                  },\n                  direction: 0 > ga.y === a.axisY.reversed ? 1 : -1,\n                  color: f\n                });\n              }\n            }\n\n            e();\n            b.moveTo(g, m);\n            v && x.moveTo(g, m);\n          }\n\n          delete D.dataPointIndexes;\n        }\n\n        V.drawMarkers(r);\n        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(d.x1, d.y1, d.width, d.height), x.restore());\n        b.restore();\n        return {\n          source: c,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderStackedArea100 = function (a) {\n      function e() {\n        for (0 < D.lineThickness && b.stroke(); 0 < k.length;) {\n          var a = k.pop();\n          b.lineTo(a.x, a.y);\n          v && u.lineTo(a.x, a.y);\n        }\n\n        b.closePath();\n        b.globalAlpha = D.fillOpacity;\n        b.fill();\n        b.globalAlpha = 1;\n        b.beginPath();\n        v && (u.closePath(), u.fill(), u.beginPath());\n        k = [];\n      }\n\n      var c = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : c;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = null,\n            h = null,\n            r = this.plotArea,\n            d = [],\n            n = [],\n            k = [],\n            l = [],\n            p = [],\n            q = 0,\n            g,\n            m,\n            w,\n            x,\n            s,\n            z = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            u = this._eventManager.ghostCtx;\n        b.save();\n        v && u.save();\n        b.beginPath();\n        b.rect(r.x1, r.y1, r.width, r.height);\n        b.clip();\n        v && (u.beginPath(), u.rect(r.x1, r.y1, r.width, r.height), u.clip());\n\n        for (var f = [], t = 0; t < a.dataSeriesIndexes.length; t++) {\n          var B = a.dataSeriesIndexes[t],\n              D = this.data[B],\n              A = D.dataPoints;\n          D.dataPointIndexes = [];\n\n          for (q = 0; q < A.length; q++) B = A[q].x.getTime ? A[q].x.getTime() : A[q].x, D.dataPointIndexes[B] = q, f[B] || (l.push(B), f[B] = !0);\n\n          l.sort(Sa);\n        }\n\n        for (t = 0; t < a.dataSeriesIndexes.length; t++) {\n          B = a.dataSeriesIndexes[t];\n          D = this.data[B];\n          A = D.dataPoints;\n          x = !0;\n          f = D.id;\n          this._eventManager.objectMap[f] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: B\n          };\n          f = W(f);\n          u.fillStyle = f;\n          k = [];\n\n          if (0 < l.length) {\n            var f = D._colorSet[q % D._colorSet.length],\n                C = D.lineColor = D.options.lineColor || f,\n                J = C;\n            b.fillStyle = f;\n            b.strokeStyle = C;\n            b.lineWidth = D.lineThickness;\n            s = \"solid\";\n\n            if (b.setLineDash) {\n              var T = G(D.nullDataLineDashType, D.lineThickness);\n              s = D.lineDashType;\n              var ba = G(s, D.lineThickness);\n              b.setLineDash(ba);\n            }\n\n            for (var Z = !0, q = 0; q < l.length; q++) {\n              var h = l[q],\n                  ga = null,\n                  ga = 0 <= D.dataPointIndexes[h] ? A[D.dataPointIndexes[h]] : {\n                x: h,\n                y: null\n              };\n              if (!(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax && (!D.connectNullData || !Z))) if (\"number\" !== typeof ga.y) D.connectNullData || Z || x || e(), Z = !0;else {\n                var oa;\n                oa = 0 !== a.dataPointYSums[h] ? 100 * (ga.y / a.dataPointYSums[h]) : 0;\n                g = a.axisX.convertValueToPixel(h);\n                var ka = n[h] ? n[h] : 0;\n\n                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\n                  p[h] = oa + (p[h] ? p[h] : 0);\n                  if (0 >= p[h] && a.axisY.logarithmic) continue;\n                  m = a.axisY.convertValueToPixel(p[h]);\n                } else m = a.axisY.convertValueToPixel(oa), m -= ka;\n\n                k.push({\n                  x: g,\n                  y: z - ka\n                });\n                n[h] = z - m;\n                x || Z ? (!x && D.connectNullData ? (b.setLineDash && (D.options.nullDataLineDashType || s === D.lineDashType && D.lineDashType !== D.nullDataLineDashType) && (x = k.pop(), s = k[k.length - 1], e(), b.moveTo(w.x, w.y), k.push(s), k.push(x), s = D.nullDataLineDashType, b.setLineDash(T)), b.lineTo(g, m), v && u.lineTo(g, m)) : (b.beginPath(), b.moveTo(g, m), v && (u.beginPath(), u.moveTo(g, m))), Z = x = !1) : (b.lineTo(g, m), v && u.lineTo(g, m), 0 == q % 250 && (e(), b.moveTo(g, m), v && u.moveTo(g, m), k.push({\n                  x: g,\n                  y: z - ka\n                })));\n                w = {\n                  x: g,\n                  y: m\n                };\n                q < A.length - 1 && (J !== (A[q].lineColor || C) || s !== (A[q].lineDashType || D.lineDashType)) && (e(), b.beginPath(), b.moveTo(g, m), k.push({\n                  x: g,\n                  y: z - ka\n                }), J = A[q].lineColor || C, b.strokeStyle = J, b.setLineDash && (A[q].lineDashType ? (s = A[q].lineDashType, b.setLineDash(G(s, D.lineThickness))) : (s = D.lineDashType, b.setLineDash(ba))));\n\n                if (0 <= D.dataPointIndexes[h]) {\n                  var E = D.dataPointIds[D.dataPointIndexes[h]];\n                  this._eventManager.objectMap[E] = {\n                    id: E,\n                    objectType: \"dataPoint\",\n                    dataSeriesIndex: B,\n                    dataPointIndex: D.dataPointIndexes[h],\n                    x1: g,\n                    y1: m\n                  };\n                }\n\n                0 <= D.dataPointIndexes[h] && 0 !== ga.markerSize && (0 < ga.markerSize || 0 < D.markerSize) && (ka = D.getMarkerProperties(D.dataPointIndexes[h], g, m, b), d.push(ka), h = W(E), v && d.push({\n                  x: g,\n                  y: m,\n                  ctx: u,\n                  type: ka.type,\n                  size: ka.size,\n                  color: h,\n                  borderColor: h,\n                  borderThickness: ka.borderThickness\n                }));\n                (ga.indexLabel || D.indexLabel || ga.indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({\n                  chartType: \"stackedArea100\",\n                  dataPoint: ga,\n                  dataSeries: D,\n                  point: {\n                    x: g,\n                    y: m\n                  },\n                  direction: 0 > ga.y === a.axisY.reversed ? 1 : -1,\n                  color: f\n                });\n              }\n            }\n\n            e();\n            b.moveTo(g, m);\n            v && u.moveTo(g, m);\n          }\n\n          delete D.dataPointIndexes;\n        }\n\n        V.drawMarkers(d);\n        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(r.x1, r.y1, r.width, r.height), u.restore());\n        b.restore();\n        return {\n          source: c,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderBubble = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = this.plotArea,\n            f = 0,\n            h,\n            r;\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(b.x1, b.y1, b.width, b.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());\n\n        for (var d = -Infinity, n = Infinity, k = 0; k < a.dataSeriesIndexes.length; k++) for (var l = a.dataSeriesIndexes[k], p = this.data[l], q = p.dataPoints, g = 0, f = 0; f < q.length; f++) h = q[f].getTime ? h = q[f].x.getTime() : h = q[f].x, h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax || \"undefined\" === typeof q[f].z || (g = q[f].z, g > d && (d = g), g < n && (n = g));\n\n        for (var m = 25 * Math.PI, w = Math.max(Math.pow(0.25 * Math.min(b.height, b.width) / 2, 2) * Math.PI, m), k = 0; k < a.dataSeriesIndexes.length; k++) if (l = a.dataSeriesIndexes[k], p = this.data[l], q = p.dataPoints, 0 < q.length) for (c.strokeStyle = \"#4572A7 \", f = 0; f < q.length; f++) if (h = q[f].getTime ? h = q[f].x.getTime() : h = q[f].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof q[f].y) {\n          h = a.axisX.convertValueToPixel(h);\n          r = a.axisY.convertValueToPixel(q[f].y);\n          var g = q[f].z,\n              x = 2 * Math.max(Math.sqrt((d === n ? w / 2 : m + (w - m) / (d - n) * (g - n)) / Math.PI) << 0, 1),\n              g = p.getMarkerProperties(f, c);\n          g.size = x;\n          c.globalAlpha = p.fillOpacity;\n          V.drawMarker(h, r, c, g.type, g.size, g.color, g.borderColor, g.borderThickness);\n          c.globalAlpha = 1;\n          var s = p.dataPointIds[f];\n          this._eventManager.objectMap[s] = {\n            id: s,\n            objectType: \"dataPoint\",\n            dataSeriesIndex: l,\n            dataPointIndex: f,\n            x1: h,\n            y1: r,\n            size: x\n          };\n          x = W(s);\n          v && V.drawMarker(h, r, this._eventManager.ghostCtx, g.type, g.size, x, x, g.borderThickness);\n          (q[f].indexLabel || p.indexLabel || q[f].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({\n            chartType: \"bubble\",\n            dataPoint: q[f],\n            dataSeries: p,\n            point: {\n              x: h,\n              y: r\n            },\n            direction: 1,\n            bounds: {\n              x1: h - g.size / 2,\n              y1: r - g.size / 2,\n              x2: h + g.size / 2,\n              y2: r + g.size / 2\n            },\n            color: null\n          });\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderScatter = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = this.plotArea,\n            f = 0,\n            h,\n            r;\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(b.x1, b.y1, b.width, b.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());\n\n        for (var d = 0; d < a.dataSeriesIndexes.length; d++) {\n          var n = a.dataSeriesIndexes[d],\n              k = this.data[n],\n              l = k.dataPoints;\n\n          if (0 < l.length) {\n            c.strokeStyle = \"#4572A7 \";\n            Math.pow(0.3 * Math.min(b.height, b.width) / 2, 2);\n\n            for (var p = 0, q = 0, f = 0; f < l.length; f++) if (h = l[f].getTime ? h = l[f].x.getTime() : h = l[f].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof l[f].y) {\n              h = a.axisX.convertValueToPixel(h);\n              r = a.axisY.convertValueToPixel(l[f].y);\n              var g = k.getMarkerProperties(f, h, r, c);\n              c.globalAlpha = k.fillOpacity;\n              V.drawMarker(g.x, g.y, g.ctx, g.type, g.size, g.color, g.borderColor, g.borderThickness);\n              c.globalAlpha = 1;\n              Math.sqrt((p - h) * (p - h) + (q - r) * (q - r)) < Math.min(g.size, 5) && l.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = k.dataPointIds[f], this._eventManager.objectMap[p] = {\n                id: p,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: n,\n                dataPointIndex: f,\n                x1: h,\n                y1: r\n              }, p = W(p), v && V.drawMarker(g.x, g.y, this._eventManager.ghostCtx, g.type, g.size, p, p, g.borderThickness), (l[f].indexLabel || k.indexLabel || l[f].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({\n                chartType: \"scatter\",\n                dataPoint: l[f],\n                dataSeries: k,\n                point: {\n                  x: h,\n                  y: r\n                },\n                direction: 1,\n                bounds: {\n                  x1: h - g.size / 2,\n                  y1: r - g.size / 2,\n                  x2: h + g.size / 2,\n                  y2: r + g.size / 2\n                },\n                color: null\n              }), p = h, q = r);\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderCandlestick = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e,\n          b = this._eventManager.ghostCtx;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = null,\n            h = null,\n            r = this.plotArea,\n            d = 0,\n            m,\n            k,\n            l,\n            p,\n            q,\n            g,\n            f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            h = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width,\n            t = a.axisX.dataInfo.minDiff;\n        isFinite(t) || (t = 0.3 * Math.abs(a.axisX.range));\n        t = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * r.width * (a.axisX.logarithmic ? Math.log(t) / Math.log(a.axisX.range) : Math.abs(t) / Math.abs(a.axisX.range)) << 0;\n        this.dataPointMaxWidth && f > h && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, h));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && h < f && (h = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));\n        t < f && (t = f);\n        t > h && (t = h);\n        c.save();\n        v && b.save();\n        c.beginPath();\n        c.rect(r.x1, r.y1, r.width, r.height);\n        c.clip();\n        v && (b.beginPath(), b.rect(r.x1, r.y1, r.width, r.height), b.clip());\n\n        for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\n          var x = a.dataSeriesIndexes[w],\n              s = this.data[x],\n              z = s.dataPoints;\n          if (0 < z.length) for (var u = 5 < t && s.bevelEnabled ? !0 : !1, d = 0; d < z.length; d++) if (z[d].getTime ? g = z[d].x.getTime() : g = z[d].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && !n(z[d].y) && z[d].y.length && \"number\" === typeof z[d].y[0] && \"number\" === typeof z[d].y[1] && \"number\" === typeof z[d].y[2] && \"number\" === typeof z[d].y[3]) {\n            m = a.axisX.convertValueToPixel(g);\n            k = a.axisY.convertValueToPixel(z[d].y[0]);\n            l = a.axisY.convertValueToPixel(z[d].y[1]);\n            p = a.axisY.convertValueToPixel(z[d].y[2]);\n            q = a.axisY.convertValueToPixel(z[d].y[3]);\n            var A = m - t / 2 << 0,\n                B = A + t << 0,\n                h = s.options.fallingColor ? s.fallingColor : s._colorSet[0],\n                f = z[d].color ? z[d].color : s._colorSet[0],\n                D = Math.round(Math.max(1, 0.15 * t)),\n                C = 0 === D % 2 ? 0 : 0.5,\n                G = s.dataPointIds[d];\n            this._eventManager.objectMap[G] = {\n              id: G,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: x,\n              dataPointIndex: d,\n              x1: A,\n              y1: k,\n              x2: B,\n              y2: l,\n              x3: m,\n              y3: p,\n              x4: m,\n              y4: q,\n              borderThickness: D,\n              color: f\n            };\n            c.strokeStyle = f;\n            c.beginPath();\n            c.lineWidth = D;\n            b.lineWidth = Math.max(D, 4);\n            \"candlestick\" === s.type ? (c.moveTo(m - C, l), c.lineTo(m - C, Math.min(k, q)), c.stroke(), c.moveTo(m - C, Math.max(k, q)), c.lineTo(m - C, p), c.stroke(), aa(c, A, Math.min(k, q), B, Math.max(k, q), z[d].y[0] <= z[d].y[3] ? s.risingColor : h, D, f, u, u, !1, !1, s.fillOpacity), v && (f = W(G), b.strokeStyle = f, b.moveTo(m - C, l), b.lineTo(m - C, Math.min(k, q)), b.stroke(), b.moveTo(m - C, Math.max(k, q)), b.lineTo(m - C, p), b.stroke(), aa(b, A, Math.min(k, q), B, Math.max(k, q), f, 0, null, !1, !1, !1, !1))) : \"ohlc\" === s.type && (c.moveTo(m - C, l), c.lineTo(m - C, p), c.stroke(), c.beginPath(), c.moveTo(m, k), c.lineTo(A, k), c.stroke(), c.beginPath(), c.moveTo(m, q), c.lineTo(B, q), c.stroke(), v && (f = W(G), b.strokeStyle = f, b.moveTo(m - C, l), b.lineTo(m - C, p), b.stroke(), b.beginPath(), b.moveTo(m, k), b.lineTo(A, k), b.stroke(), b.beginPath(), b.moveTo(m, q), b.lineTo(B, q), b.stroke()));\n            (z[d].indexLabel || s.indexLabel || z[d].indexLabelFormatter || s.indexLabelFormatter) && this._indexLabels.push({\n              chartType: s.type,\n              dataPoint: z[d],\n              dataSeries: s,\n              point: {\n                x: A + (B - A) / 2,\n                y: a.axisY.reversed ? p : l\n              },\n              direction: 1,\n              bounds: {\n                x1: A,\n                y1: Math.min(l, p),\n                x2: B,\n                y2: Math.max(l, p)\n              },\n              color: f\n            });\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(r.x1, r.y1, r.width, r.height), b.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderBoxAndWhisker = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e,\n          b = this._eventManager.ghostCtx;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = null,\n            h = this.plotArea,\n            r = 0,\n            d,\n            m,\n            k,\n            l,\n            p,\n            q,\n            g,\n            f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1,\n            r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width,\n            t = a.axisX.dataInfo.minDiff;\n        isFinite(t) || (t = 0.3 * Math.abs(a.axisX.range));\n        t = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * h.width * (a.axisX.logarithmic ? Math.log(t) / Math.log(a.axisX.range) : Math.abs(t) / Math.abs(a.axisX.range)) << 0;\n        this.dataPointMaxWidth && f > r && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, r));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && r < f && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));\n        t < f && (t = f);\n        t > r && (t = r);\n        c.save();\n        v && b.save();\n        c.beginPath();\n        c.rect(h.x1, h.y1, h.width, h.height);\n        c.clip();\n        v && (b.beginPath(), b.rect(h.x1, h.y1, h.width, h.height), b.clip());\n\n        for (var w = !1, w = !!a.axisY.reversed, x = 0; x < a.dataSeriesIndexes.length; x++) {\n          var s = a.dataSeriesIndexes[x],\n              z = this.data[s],\n              u = z.dataPoints;\n          if (0 < u.length) for (var A = 5 < t && z.bevelEnabled ? !0 : !1, r = 0; r < u.length; r++) if (u[r].getTime ? g = u[r].x.getTime() : g = u[r].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && !n(u[r].y) && u[r].y.length && \"number\" === typeof u[r].y[0] && \"number\" === typeof u[r].y[1] && \"number\" === typeof u[r].y[2] && \"number\" === typeof u[r].y[3] && \"number\" === typeof u[r].y[4] && 5 === u[r].y.length) {\n            d = a.axisX.convertValueToPixel(g);\n            m = a.axisY.convertValueToPixel(u[r].y[0]);\n            k = a.axisY.convertValueToPixel(u[r].y[1]);\n            l = a.axisY.convertValueToPixel(u[r].y[2]);\n            p = a.axisY.convertValueToPixel(u[r].y[3]);\n            q = a.axisY.convertValueToPixel(u[r].y[4]);\n            var B = d - t / 2 << 0,\n                D = d + t / 2 << 0,\n                f = u[r].color ? u[r].color : z._colorSet[0],\n                C = Math.round(Math.max(1, 0.15 * t)),\n                H = 0 === C % 2 ? 0 : 0.5,\n                J = u[r].whiskerColor ? u[r].whiskerColor : u[r].color ? z.whiskerColor ? z.whiskerColor : u[r].color : z.whiskerColor ? z.whiskerColor : f,\n                T = \"number\" === typeof u[r].whiskerThickness ? u[r].whiskerThickness : \"number\" === typeof z.options.whiskerThickness ? z.whiskerThickness : C,\n                ba = u[r].whiskerDashType ? u[r].whiskerDashType : z.whiskerDashType,\n                Z = n(u[r].whiskerLength) ? n(z.options.whiskerLength) ? t : z.whiskerLength : u[r].whiskerLength,\n                Z = \"number\" === typeof Z ? 0 >= Z ? 0 : Z >= t ? t : Z : \"string\" === typeof Z ? parseInt(Z) * t / 100 > t ? t : parseInt(Z) * t / 100 : t,\n                ga = 1 === Math.round(T) % 2 ? 0.5 : 0,\n                oa = u[r].stemColor ? u[r].stemColor : u[r].color ? z.stemColor ? z.stemColor : u[r].color : z.stemColor ? z.stemColor : f,\n                ka = \"number\" === typeof u[r].stemThickness ? u[r].stemThickness : \"number\" === typeof z.options.stemThickness ? z.stemThickness : C,\n                E = 1 === Math.round(ka) % 2 ? 0.5 : 0,\n                L = u[r].stemDashType ? u[r].stemDashType : z.stemDashType,\n                O = u[r].lineColor ? u[r].lineColor : u[r].color ? z.lineColor ? z.lineColor : u[r].color : z.lineColor ? z.lineColor : f,\n                Q = \"number\" === typeof u[r].lineThickness ? u[r].lineThickness : \"number\" === typeof z.options.lineThickness ? z.lineThickness : C,\n                P = u[r].lineDashType ? u[r].lineDashType : z.lineDashType,\n                M = 1 === Math.round(Q) % 2 ? 0.5 : 0,\n                N = z.upperBoxColor,\n                pb = z.lowerBoxColor,\n                ta = n(z.options.fillOpacity) ? 1 : z.fillOpacity,\n                R = z.dataPointIds[r];\n            this._eventManager.objectMap[R] = {\n              id: R,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: s,\n              dataPointIndex: r,\n              x1: B,\n              y1: m,\n              x2: D,\n              y2: k,\n              x3: d,\n              y3: l,\n              x4: d,\n              y4: p,\n              y5: q,\n              borderThickness: C,\n              color: f,\n              stemThickness: ka,\n              stemColor: oa,\n              whiskerThickness: T,\n              whiskerLength: Z,\n              whiskerColor: J,\n              lineThickness: Q,\n              lineColor: O\n            };\n            c.save();\n            0 < ka && (c.beginPath(), c.strokeStyle = oa, c.lineWidth = ka, c.setLineDash && c.setLineDash(G(L, ka)), c.moveTo(d - E, k), c.lineTo(d - E, m), c.stroke(), c.moveTo(d - E, p), c.lineTo(d - E, l), c.stroke());\n            c.restore();\n            b.lineWidth = Math.max(C, 4);\n            c.beginPath();\n            aa(c, B, Math.min(q, k), D, Math.max(k, q), pb, 0, f, w ? A : !1, w ? !1 : A, !1, !1, ta);\n            c.beginPath();\n            aa(c, B, Math.min(l, q), D, Math.max(q, l), N, 0, f, w ? !1 : A, w ? A : !1, !1, !1, ta);\n            c.beginPath();\n            c.lineWidth = C;\n            c.strokeStyle = f;\n            c.rect(B - H, Math.min(k, l) - H, D - B + 2 * H, Math.max(k, l) - Math.min(k, l) + 2 * H);\n            c.stroke();\n            c.save();\n            0 < Q && (c.beginPath(), c.globalAlpha = 1, c.setLineDash && c.setLineDash(G(P, Q)), c.strokeStyle = O, c.lineWidth = Q, c.moveTo(B, q - M), c.lineTo(D, q - M), c.stroke());\n            c.restore();\n            c.save();\n            0 < T && (c.beginPath(), c.setLineDash && c.setLineDash(G(ba, T)), c.strokeStyle = J, c.lineWidth = T, c.moveTo(d - Z / 2 << 0, p - ga), c.lineTo(d + Z / 2 << 0, p - ga), c.stroke(), c.moveTo(d - Z / 2 << 0, m + ga), c.lineTo(d + Z / 2 << 0, m + ga), c.stroke());\n            c.restore();\n            v && (f = W(R), b.strokeStyle = f, b.lineWidth = ka, 0 < ka && (b.moveTo(d - H - E, k), b.lineTo(d - H - E, Math.max(m, p)), b.stroke(), b.moveTo(d - H - E, Math.min(m, p)), b.lineTo(d - H - E, l), b.stroke()), aa(b, B, Math.max(k, l), D, Math.min(k, l), f, 0, null, !1, !1, !1, !1), 0 < T && (b.beginPath(), b.lineWidth = T, b.moveTo(d + Z / 2, p - ga), b.lineTo(d - Z / 2, p - ga), b.stroke(), b.moveTo(d + Z / 2, m + ga), b.lineTo(d - Z / 2, m + ga), b.stroke()));\n            (u[r].indexLabel || z.indexLabel || u[r].indexLabelFormatter || z.indexLabelFormatter) && this._indexLabels.push({\n              chartType: z.type,\n              dataPoint: u[r],\n              dataSeries: z,\n              point: {\n                x: B + (D - B) / 2,\n                y: a.axisY.reversed ? m : p\n              },\n              direction: 1,\n              bounds: {\n                x1: B,\n                y1: Math.min(m, p),\n                x2: D,\n                y2: Math.max(m, p)\n              },\n              color: f\n            });\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), b.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderRangeColumn = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = 0,\n            r,\n            d,\n            m,\n            h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n        r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;\n        var k = a.axisX.dataInfo.minDiff;\n        isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range));\n        k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n        this.dataPointMaxWidth && h > r && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, r));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && r < h && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, h));\n        k < h && (k = h);\n        k > r && (k = r);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n          var p = a.dataSeriesIndexes[l],\n              q = this.data[p],\n              g = q.dataPoints;\n          if (0 < g.length) for (var t = 5 < k && q.bevelEnabled ? !0 : !1, h = 0; h < g.length; h++) if (g[h].getTime ? m = g[h].x.getTime() : m = g[h].x, !(m < a.axisX.dataInfo.viewPortMin || m > a.axisX.dataInfo.viewPortMax) && !n(g[h].y) && g[h].y.length && \"number\" === typeof g[h].y[0] && \"number\" === typeof g[h].y[1]) {\n            b = a.axisX.convertValueToPixel(m);\n            r = a.axisY.convertValueToPixel(g[h].y[0]);\n            d = a.axisY.convertValueToPixel(g[h].y[1]);\n            var w = a.axisX.reversed ? b + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + l) * k << 0 : b - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + l) * k << 0,\n                x = a.axisX.reversed ? w - k << 0 : w + k << 0,\n                b = g[h].color ? g[h].color : q._colorSet[h % q._colorSet.length];\n\n            if (r > d) {\n              var s = r;\n              r = d;\n              d = s;\n            }\n\n            s = q.dataPointIds[h];\n            this._eventManager.objectMap[s] = {\n              id: s,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: p,\n              dataPointIndex: h,\n              x1: w,\n              y1: r,\n              x2: x,\n              y2: d\n            };\n            aa(c, a.axisX.reversed ? x : w, r, a.axisX.reversed ? w : x, d, b, 0, b, t, t, !1, !1, q.fillOpacity);\n            b = W(s);\n            v && aa(this._eventManager.ghostCtx, a.axisX.reversed ? x : w, r, a.axisX.reversed ? w : x, d, b, 0, null, !1, !1, !1, !1);\n            if (g[h].indexLabel || q.indexLabel || g[h].indexLabelFormatter || q.indexLabelFormatter) this._indexLabels.push({\n              chartType: \"rangeColumn\",\n              dataPoint: g[h],\n              dataSeries: q,\n              indexKeyword: 0,\n              point: {\n                x: w + (x - w) / 2,\n                y: g[h].y[1] >= g[h].y[0] ? d : r\n              },\n              direction: g[h].y[1] >= g[h].y[0] ? -1 : 1,\n              bounds: {\n                x1: w,\n                y1: Math.min(r, d),\n                x2: x,\n                y2: Math.max(r, d)\n              },\n              color: b\n            }), this._indexLabels.push({\n              chartType: \"rangeColumn\",\n              dataPoint: g[h],\n              dataSeries: q,\n              indexKeyword: 1,\n              point: {\n                x: w + (x - w) / 2,\n                y: g[h].y[1] >= g[h].y[0] ? r : d\n              },\n              direction: g[h].y[1] >= g[h].y[0] ? 1 : -1,\n              bounds: {\n                x1: w,\n                y1: Math.min(r, d),\n                x2: x,\n                y2: Math.max(r, d)\n              },\n              color: b\n            });\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderError = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e,\n          b = a.axisY._position ? \"left\" === a.axisY._position || \"right\" === a.axisY._position ? !1 : !0 : !1;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = null,\n            h = !1,\n            r = this.plotArea,\n            d = 0,\n            m,\n            k,\n            l,\n            p,\n            q,\n            g,\n            t,\n            w = a.axisX.dataInfo.minDiff;\n        isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(r.x1, r.y1, r.width, r.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.clip());\n\n        for (var x = 0, s = 0; s < this.data.length; s++) !this.data[s].type.match(/(bar|column)/ig) || !this.data[s].visible || this.data[s].type.match(/(stacked)/ig) && x || x++;\n\n        for (var z = 0; z < a.dataSeriesIndexes.length; z++) {\n          var u = a.dataSeriesIndexes[z],\n              C = this.data[u],\n              B = C.dataPoints,\n              D = n(C._linkedSeries) ? !1 : C._linkedSeries.type.match(/(bar|column)/ig) && C._linkedSeries.visible ? !0 : !1,\n              G = 0;\n          if (D) for (f = C._linkedSeries.id, s = 0; s < f; s++) !this.data[s].type.match(/(bar|column)/ig) || !this.data[s].visible || this.data[s].type.match(/(stacked)/ig) && G || (this.data[s].type.match(/(range)/ig) && (h = !0), G++);\n          f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n          d = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (D ? x : 1))) << 0 : 0.3 * this.width;\n          h && (d = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (D ? x : 1))) << 0 : 0.03 * this.width);\n          s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((b ? r.height : r.width) * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) / (D ? x : 1)) << 0;\n          this.dataPointMaxWidth && f > d && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, d));\n          !this.dataPointMaxWidth && this.dataPointMinWidth && d < f && (d = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));\n          s < f && (s = f);\n          s > d && (s = d);\n          if (0 < B.length) for (var H = C._colorSet, d = 0; d < B.length; d++) {\n            var f = C.lineColor = C.options.color ? C.options.color : H[0],\n                J = {\n              color: B[d].whiskerColor ? B[d].whiskerColor : B[d].color ? C.whiskerColor ? C.whiskerColor : B[d].color : C.whiskerColor ? C.whiskerColor : f,\n              thickness: n(B[d].whiskerThickness) ? C.whiskerThickness : B[d].whiskerThickness,\n              dashType: B[d].whiskerDashType ? B[d].whiskerDashType : C.whiskerDashType,\n              length: n(B[d].whiskerLength) ? n(C.options.whiskerLength) ? s : C.options.whiskerLength : B[d].whiskerLength,\n              trimLength: n(B[d].whiskerLength) ? n(C.options.whiskerLength) ? 50 : 0 : 0\n            };\n            J.length = \"number\" === typeof J.length ? 0 >= J.length ? 0 : J.length >= s ? s : J.length : \"string\" === typeof J.length ? parseInt(J.length) * s / 100 > s ? s : parseInt(J.length) * s / 100 > s : s;\n            J.thickness = \"number\" === typeof J.thickness ? 0 > J.thickness ? 0 : Math.round(J.thickness) : 2;\n            var T = {\n              color: B[d].stemColor ? B[d].stemColor : B[d].color ? C.stemColor ? C.stemColor : B[d].color : C.stemColor ? C.stemColor : f,\n              thickness: B[d].stemThickness ? B[d].stemThickness : C.stemThickness,\n              dashType: B[d].stemDashType ? B[d].stemDashType : C.stemDashType\n            };\n            T.thickness = \"number\" === typeof T.thickness ? 0 > T.thickness ? 0 : Math.round(T.thickness) : 2;\n            B[d].getTime ? t = B[d].x.getTime() : t = B[d].x;\n\n            if (!(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && !n(B[d].y) && B[d].y.length && \"number\" === typeof B[d].y[0] && \"number\" === typeof B[d].y[1]) {\n              var ba = a.axisX.convertValueToPixel(t);\n              b ? k = ba : m = ba;\n              ba = a.axisY.convertValueToPixel(B[d].y[0]);\n              b ? l = ba : q = ba;\n              ba = a.axisY.convertValueToPixel(B[d].y[1]);\n              b ? p = ba : g = ba;\n              b ? (q = a.axisX.reversed ? k + (D ? x : 1) * s / 2 - (D ? G - 1 : 0) * s << 0 : k - (D ? x : 1) * s / 2 + (D ? G - 1 : 0) * s << 0, g = a.axisX.reversed ? q - s << 0 : q + s << 0) : (l = a.axisX.reversed ? m + (D ? x : 1) * s / 2 - (D ? G - 1 : 0) * s << 0 : m - (D ? x : 1) * s / 2 + (D ? G - 1 : 0) * s << 0, p = a.axisX.reversed ? l - s << 0 : l + s << 0);\n              !b && q > g && (ba = q, q = g, g = ba);\n              b && l > p && (ba = l, l = p, p = ba);\n              ba = C.dataPointIds[d];\n              this._eventManager.objectMap[ba] = {\n                id: ba,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: u,\n                dataPointIndex: d,\n                x1: Math.min(l, p),\n                y1: Math.min(q, g),\n                x2: Math.max(p, l),\n                y2: Math.max(g, q),\n                isXYSwapped: b,\n                stemProperties: T,\n                whiskerProperties: J\n              };\n              A(c, Math.min(l, p), Math.min(q, g), Math.max(p, l), Math.max(g, q), f, J, T, b);\n              v && A(this._eventManager.ghostCtx, l, q, p, g, f, J, T, b);\n              if (B[d].indexLabel || C.indexLabel || B[d].indexLabelFormatter || C.indexLabelFormatter) this._indexLabels.push({\n                chartType: \"error\",\n                dataPoint: B[d],\n                dataSeries: C,\n                indexKeyword: 0,\n                point: {\n                  x: b ? B[d].y[1] >= B[d].y[0] ? l : p : l + (p - l) / 2,\n                  y: b ? q + (g - q) / 2 : B[d].y[1] >= B[d].y[0] ? g : q\n                },\n                direction: B[d].y[1] >= B[d].y[0] ? -1 : 1,\n                bounds: {\n                  x1: b ? Math.min(l, p) : l,\n                  y1: b ? q : Math.min(q, g),\n                  x2: b ? Math.max(l, p) : p,\n                  y2: b ? g : Math.max(q, g)\n                },\n                color: f,\n                axisSwapped: b\n              }), this._indexLabels.push({\n                chartType: \"error\",\n                dataPoint: B[d],\n                dataSeries: C,\n                indexKeyword: 1,\n                point: {\n                  x: b ? B[d].y[1] >= B[d].y[0] ? p : l : l + (p - l) / 2,\n                  y: b ? q + (g - q) / 2 : B[d].y[1] >= B[d].y[0] ? q : g\n                },\n                direction: B[d].y[1] >= B[d].y[0] ? 1 : -1,\n                bounds: {\n                  x1: b ? Math.min(l, p) : l,\n                  y1: b ? q : Math.min(q, g),\n                  x2: b ? Math.max(l, p) : p,\n                  y2: b ? g : Math.max(q, g)\n                },\n                color: f,\n                axisSwapped: b\n              });\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderRangeBar = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = null,\n            f = this.plotArea,\n            h = 0,\n            r,\n            d,\n            m,\n            k,\n            h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n        r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;\n        var l = a.axisX.dataInfo.minDiff;\n        isFinite(l) || (l = 0.3 * Math.abs(a.axisX.range));\n        l = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (f.height * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n        this.dataPointMaxWidth && h > r && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, r));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && r < h && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, h));\n        l < h && (l = h);\n        l > r && (l = r);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(f.x1, f.y1, f.width, f.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());\n\n        for (var p = 0; p < a.dataSeriesIndexes.length; p++) {\n          var q = a.dataSeriesIndexes[p],\n              g = this.data[q],\n              t = g.dataPoints;\n\n          if (0 < t.length) {\n            var w = 5 < l && g.bevelEnabled ? !0 : !1;\n            c.strokeStyle = \"#4572A7 \";\n\n            for (h = 0; h < t.length; h++) if (t[h].getTime ? k = t[h].x.getTime() : k = t[h].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !n(t[h].y) && t[h].y.length && \"number\" === typeof t[h].y[0] && \"number\" === typeof t[h].y[1]) {\n              r = a.axisY.convertValueToPixel(t[h].y[0]);\n              d = a.axisY.convertValueToPixel(t[h].y[1]);\n              m = a.axisX.convertValueToPixel(k);\n              m = a.axisX.reversed ? m + a.plotType.totalDataSeries * l / 2 - (a.previousDataSeriesCount + p) * l << 0 : m - a.plotType.totalDataSeries * l / 2 + (a.previousDataSeriesCount + p) * l << 0;\n              var x = a.axisX.reversed ? m - l << 0 : m + l << 0;\n              r > d && (b = r, r = d, d = b);\n              b = t[h].color ? t[h].color : g._colorSet[h % g._colorSet.length];\n              aa(c, r, a.axisX.reversed ? x : m, d, a.axisX.reversed ? m : x, b, 0, null, w, !1, !1, !1, g.fillOpacity);\n              b = g.dataPointIds[h];\n              this._eventManager.objectMap[b] = {\n                id: b,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: q,\n                dataPointIndex: h,\n                x1: r,\n                y1: m,\n                x2: d,\n                y2: x\n              };\n              b = W(b);\n              v && aa(this._eventManager.ghostCtx, r, a.axisX.reversed ? x : m, d, a.axisX.reversed ? m : x, b, 0, null, !1, !1, !1, !1);\n              if (t[h].indexLabel || g.indexLabel || t[h].indexLabelFormatter || g.indexLabelFormatter) this._indexLabels.push({\n                chartType: \"rangeBar\",\n                dataPoint: t[h],\n                dataSeries: g,\n                indexKeyword: 0,\n                point: {\n                  x: t[h].y[1] >= t[h].y[0] ? r : d,\n                  y: m + (x - m) / 2\n                },\n                direction: t[h].y[1] >= t[h].y[0] ? -1 : 1,\n                bounds: {\n                  x1: Math.min(r, d),\n                  y1: m,\n                  x2: Math.max(r, d),\n                  y2: x\n                },\n                color: b\n              }), this._indexLabels.push({\n                chartType: \"rangeBar\",\n                dataPoint: t[h],\n                dataSeries: g,\n                indexKeyword: 1,\n                point: {\n                  x: t[h].y[1] >= t[h].y[0] ? d : r,\n                  y: m + (x - m) / 2\n                },\n                direction: t[h].y[1] >= t[h].y[0] ? 1 : -1,\n                bounds: {\n                  x1: Math.min(r, d),\n                  y1: m,\n                  x2: Math.max(r, d),\n                  y2: x\n                },\n                color: b\n              });\n            }\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderRangeArea = function (a) {\n      function e() {\n        if (z) {\n          for (var a = null, c = n.length - 1; 0 <= c; c--) a = n[c], b.lineTo(a.x, a.y2), f.lineTo(a.x, a.y2);\n\n          b.closePath();\n          b.globalAlpha = l.fillOpacity;\n          b.fill();\n          b.globalAlpha = 1;\n          f.fill();\n\n          if (0 < l.lineThickness) {\n            b.beginPath();\n            b.moveTo(a.x, a.y2);\n\n            for (c = 0; c < n.length; c++) a = n[c], b.lineTo(a.x, a.y2);\n\n            b.moveTo(n[0].x, n[0].y1);\n\n            for (c = 0; c < n.length; c++) a = n[c], b.lineTo(a.x, a.y1);\n\n            b.stroke();\n          }\n\n          b.beginPath();\n          b.moveTo(m, w);\n          f.beginPath();\n          f.moveTo(m, w);\n          z = {\n            x: m,\n            y: w\n          };\n          n = [];\n          n.push({\n            x: m,\n            y1: w,\n            y2: x\n          });\n        }\n      }\n\n      var c = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : c;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = this._eventManager.ghostCtx,\n            h = [],\n            r = this.plotArea;\n        b.save();\n        v && f.save();\n        b.beginPath();\n        b.rect(r.x1, r.y1, r.width, r.height);\n        b.clip();\n        v && (f.beginPath(), f.rect(r.x1, r.y1, r.width, r.height), f.clip());\n\n        for (var d = 0; d < a.dataSeriesIndexes.length; d++) {\n          var n = [],\n              k = a.dataSeriesIndexes[d],\n              l = this.data[k],\n              p = l.dataPoints,\n              h = l.id;\n          this._eventManager.objectMap[h] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: k\n          };\n          h = W(h);\n          f.fillStyle = h;\n          var h = [],\n              q = !0,\n              g = 0,\n              m,\n              w,\n              x,\n              s,\n              z = null;\n\n          if (0 < p.length) {\n            var u = l._colorSet[g % l._colorSet.length],\n                t = l.lineColor = l.options.lineColor || u,\n                B = t;\n            b.fillStyle = u;\n            b.strokeStyle = t;\n            b.lineWidth = l.lineThickness;\n            var D = \"solid\";\n\n            if (b.setLineDash) {\n              var A = G(l.nullDataLineDashType, l.lineThickness),\n                  D = l.lineDashType,\n                  C = G(D, l.lineThickness);\n              b.setLineDash(C);\n            }\n\n            for (var J = !0; g < p.length; g++) if (s = p[g].x.getTime ? p[g].x.getTime() : p[g].x, !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!l.connectNullData || !J))) if (null !== p[g].y && p[g].y.length && \"number\" === typeof p[g].y[0] && \"number\" === typeof p[g].y[1]) {\n              m = a.axisX.convertValueToPixel(s);\n              w = a.axisY.convertValueToPixel(p[g].y[0]);\n              x = a.axisY.convertValueToPixel(p[g].y[1]);\n              q || J ? (l.connectNullData && !q ? (b.setLineDash && (l.options.nullDataLineDashType || D === l.lineDashType && l.lineDashType !== l.nullDataLineDashType) && (n[n.length - 1].newLineDashArray = C, D = l.nullDataLineDashType, b.setLineDash(A)), b.lineTo(m, w), v && f.lineTo(m, w), n.push({\n                x: m,\n                y1: w,\n                y2: x\n              })) : (b.beginPath(), b.moveTo(m, w), z = {\n                x: m,\n                y: w\n              }, n = [], n.push({\n                x: m,\n                y1: w,\n                y2: x\n              }), v && (f.beginPath(), f.moveTo(m, w))), J = q = !1) : (b.lineTo(m, w), n.push({\n                x: m,\n                y1: w,\n                y2: x\n              }), v && f.lineTo(m, w), 0 == g % 250 && e());\n              s = l.dataPointIds[g];\n              this._eventManager.objectMap[s] = {\n                id: s,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: k,\n                dataPointIndex: g,\n                x1: m,\n                y1: w,\n                y2: x\n              };\n              g < p.length - 1 && (B !== (p[g].lineColor || t) || D !== (p[g].lineDashType || l.lineDashType)) && (e(), B = p[g].lineColor || t, n[n.length - 1].newStrokeStyle = B, b.strokeStyle = B, b.setLineDash && (p[g].lineDashType ? (D = p[g].lineDashType, n[n.length - 1].newLineDashArray = G(D, l.lineThickness), b.setLineDash(n[n.length - 1].newLineDashArray)) : (D = l.lineDashType, n[n.length - 1].newLineDashArray = C, b.setLineDash(C))));\n\n              if (0 !== p[g].markerSize && (0 < p[g].markerSize || 0 < l.markerSize)) {\n                var T = l.getMarkerProperties(g, m, x, b);\n                h.push(T);\n                var ba = W(s);\n                v && h.push({\n                  x: m,\n                  y: x,\n                  ctx: f,\n                  type: T.type,\n                  size: T.size,\n                  color: ba,\n                  borderColor: ba,\n                  borderThickness: T.borderThickness\n                });\n                T = l.getMarkerProperties(g, m, w, b);\n                h.push(T);\n                ba = W(s);\n                v && h.push({\n                  x: m,\n                  y: w,\n                  ctx: f,\n                  type: T.type,\n                  size: T.size,\n                  color: ba,\n                  borderColor: ba,\n                  borderThickness: T.borderThickness\n                });\n              }\n\n              if (p[g].indexLabel || l.indexLabel || p[g].indexLabelFormatter || l.indexLabelFormatter) this._indexLabels.push({\n                chartType: \"rangeArea\",\n                dataPoint: p[g],\n                dataSeries: l,\n                indexKeyword: 0,\n                point: {\n                  x: m,\n                  y: w\n                },\n                direction: p[g].y[0] > p[g].y[1] === a.axisY.reversed ? -1 : 1,\n                color: u\n              }), this._indexLabels.push({\n                chartType: \"rangeArea\",\n                dataPoint: p[g],\n                dataSeries: l,\n                indexKeyword: 1,\n                point: {\n                  x: m,\n                  y: x\n                },\n                direction: p[g].y[0] > p[g].y[1] === a.axisY.reversed ? 1 : -1,\n                color: u\n              });\n            } else J || q || e(), J = !0;\n\n            e();\n            V.drawMarkers(h);\n          }\n        }\n\n        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());\n        b.restore();\n        return {\n          source: c,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderRangeSplineArea = function (a) {\n      function e(a, c) {\n        var g = t(w, 2);\n\n        if (0 < g.length) {\n          if (0 < k.lineThickness) {\n            b.strokeStyle = c;\n            b.setLineDash && b.setLineDash(a);\n            b.beginPath();\n            b.moveTo(g[0].x, g[0].y);\n\n            for (var e = 0; e < g.length - 3; e += 3) {\n              if (g[e].newStrokeStyle || g[e].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(g[e].x, g[e].y), g[e].newStrokeStyle && (b.strokeStyle = g[e].newStrokeStyle), g[e].newLineDashArray && b.setLineDash(g[e].newLineDashArray);\n              b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);\n            }\n          }\n\n          b.beginPath();\n          b.moveTo(g[0].x, g[0].y);\n          v && (f.beginPath(), f.moveTo(g[0].x, g[0].y));\n\n          for (e = 0; e < g.length - 3; e += 3) b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y), v && f.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);\n\n          g = t(x, 2);\n          b.lineTo(x[x.length - 1].x, x[x.length - 1].y);\n\n          for (e = g.length - 1; 2 < e; e -= 3) b.bezierCurveTo(g[e - 1].x, g[e - 1].y, g[e - 2].x, g[e - 2].y, g[e - 3].x, g[e - 3].y), v && f.bezierCurveTo(g[e - 1].x, g[e - 1].y, g[e - 2].x, g[e - 2].y, g[e - 3].x, g[e - 3].y);\n\n          b.closePath();\n          b.globalAlpha = k.fillOpacity;\n          b.fill();\n          v && (f.closePath(), f.fill());\n          b.globalAlpha = 1;\n\n          if (0 < k.lineThickness) {\n            b.strokeStyle = c;\n            b.setLineDash && b.setLineDash(a);\n            b.beginPath();\n            b.moveTo(g[0].x, g[0].y);\n\n            for (var h = e = 0; e < g.length - 3; e += 3, h++) {\n              if (w[h].newStrokeStyle || w[h].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(g[e].x, g[e].y), w[h].newStrokeStyle && (b.strokeStyle = w[h].newStrokeStyle), w[h].newLineDashArray && b.setLineDash(w[h].newLineDashArray);\n              b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);\n            }\n\n            g = t(w, 2);\n            b.moveTo(g[0].x, g[0].y);\n\n            for (h = e = 0; e < g.length - 3; e += 3, h++) {\n              if (w[h].newStrokeStyle || w[h].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(g[e].x, g[e].y), w[h].newStrokeStyle && (b.strokeStyle = w[h].newStrokeStyle), w[h].newLineDashArray && b.setLineDash(w[h].newLineDashArray);\n              b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);\n            }\n\n            b.stroke();\n          }\n\n          b.beginPath();\n        }\n      }\n\n      var c = a.targetCanvasCtx || this.plotArea.ctx,\n          b = v ? this._preRenderCtx : c;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var f = this._eventManager.ghostCtx,\n            h = [],\n            r = this.plotArea;\n        b.save();\n        v && f.save();\n        b.beginPath();\n        b.rect(r.x1, r.y1, r.width, r.height);\n        b.clip();\n        v && (f.beginPath(), f.rect(r.x1, r.y1, r.width, r.height), f.clip());\n\n        for (var d = 0; d < a.dataSeriesIndexes.length; d++) {\n          var n = a.dataSeriesIndexes[d],\n              k = this.data[n],\n              l = k.dataPoints,\n              h = k.id;\n          this._eventManager.objectMap[h] = {\n            objectType: \"dataSeries\",\n            dataSeriesIndex: n\n          };\n          h = W(h);\n          f.fillStyle = h;\n          var h = [],\n              p = 0,\n              q,\n              g,\n              m,\n              w = [],\n              x = [];\n\n          if (0 < l.length) {\n            var s = k._colorSet[p % k._colorSet.length],\n                z = k.lineColor = k.options.lineColor || s,\n                u = z;\n            b.fillStyle = s;\n            b.lineWidth = k.lineThickness;\n            var C = \"solid\",\n                B;\n\n            if (b.setLineDash) {\n              var D = G(k.nullDataLineDashType, k.lineThickness),\n                  C = k.lineDashType;\n              B = G(C, k.lineThickness);\n            }\n\n            for (g = !1; p < l.length; p++) if (q = l[p].x.getTime ? l[p].x.getTime() : l[p].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !g))) if (null !== l[p].y && l[p].y.length && \"number\" === typeof l[p].y[0] && \"number\" === typeof l[p].y[1]) {\n              q = a.axisX.convertValueToPixel(q);\n              g = a.axisY.convertValueToPixel(l[p].y[0]);\n              m = a.axisY.convertValueToPixel(l[p].y[1]);\n              var A = k.dataPointIds[p];\n              this._eventManager.objectMap[A] = {\n                id: A,\n                objectType: \"dataPoint\",\n                dataSeriesIndex: n,\n                dataPointIndex: p,\n                x1: q,\n                y1: g,\n                y2: m\n              };\n              w[w.length] = {\n                x: q,\n                y: g\n              };\n              x[x.length] = {\n                x: q,\n                y: m\n              };\n              p < l.length - 1 && (u !== (l[p].lineColor || z) || C !== (l[p].lineDashType || k.lineDashType)) && (u = l[p].lineColor || z, w[w.length - 1].newStrokeStyle = u, b.setLineDash && (l[p].lineDashType ? (C = l[p].lineDashType, w[w.length - 1].newLineDashArray = G(C, k.lineThickness)) : (C = k.lineDashType, w[w.length - 1].newLineDashArray = B)));\n\n              if (0 !== l[p].markerSize && (0 < l[p].markerSize || 0 < k.markerSize)) {\n                var H = k.getMarkerProperties(p, q, g, b);\n                h.push(H);\n                var J = W(A);\n                v && h.push({\n                  x: q,\n                  y: g,\n                  ctx: f,\n                  type: H.type,\n                  size: H.size,\n                  color: J,\n                  borderColor: J,\n                  borderThickness: H.borderThickness\n                });\n                H = k.getMarkerProperties(p, q, m, b);\n                h.push(H);\n                J = W(A);\n                v && h.push({\n                  x: q,\n                  y: m,\n                  ctx: f,\n                  type: H.type,\n                  size: H.size,\n                  color: J,\n                  borderColor: J,\n                  borderThickness: H.borderThickness\n                });\n              }\n\n              if (l[p].indexLabel || k.indexLabel || l[p].indexLabelFormatter || k.indexLabelFormatter) this._indexLabels.push({\n                chartType: \"rangeSplineArea\",\n                dataPoint: l[p],\n                dataSeries: k,\n                indexKeyword: 0,\n                point: {\n                  x: q,\n                  y: g\n                },\n                direction: l[p].y[0] <= l[p].y[1] ? -1 : 1,\n                color: s\n              }), this._indexLabels.push({\n                chartType: \"rangeSplineArea\",\n                dataPoint: l[p],\n                dataSeries: k,\n                indexKeyword: 1,\n                point: {\n                  x: q,\n                  y: m\n                },\n                direction: l[p].y[0] <= l[p].y[1] ? 1 : -1,\n                color: s\n              });\n              g = !1;\n            } else 0 < p && !g && (k.connectNullData ? b.setLineDash && 0 < w.length && (k.options.nullDataLineDashType || !l[p - 1].lineDashType) && (w[w.length - 1].newLineDashArray = D, C = k.nullDataLineDashType) : (e(B, z), w = [], x = [])), g = !0;\n\n            e(B, z);\n            V.drawMarkers(h);\n          }\n        }\n\n        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());\n        b.restore();\n        return {\n          source: c,\n          dest: this.plotArea.ctx,\n          animationCallback: K.xClipAnimation,\n          easingFunction: K.easing.linear,\n          animationBase: 0\n        };\n      }\n    };\n\n    m.prototype.renderWaterfall = function (a) {\n      var e = a.targetCanvasCtx || this.plotArea.ctx,\n          c = v ? this._preRenderCtx : e;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var b = this._eventManager.ghostCtx,\n            f = null,\n            h = this.plotArea,\n            r = 0,\n            d,\n            n,\n            k,\n            l,\n            p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),\n            r = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n        n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;\n        var q = a.axisX.dataInfo.minDiff;\n        isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range));\n        q = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (h.width * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n        this.dataPointMaxWidth && r > n && (r = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n));\n        !this.dataPointMaxWidth && this.dataPointMinWidth && n < r && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, r));\n        q < r && (q = r);\n        q > n && (q = n);\n        c.save();\n        v && this._eventManager.ghostCtx.save();\n        c.beginPath();\n        c.rect(h.x1, h.y1, h.width, h.height);\n        c.clip();\n        v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip());\n\n        for (var g = 0; g < a.dataSeriesIndexes.length; g++) {\n          var m = a.dataSeriesIndexes[g],\n              w = this.data[m],\n              x = w.dataPoints,\n              f = w._colorSet[0];\n          w.risingColor = w.options.risingColor ? w.options.risingColor : f;\n          w.fallingColor = w.options.fallingColor ? w.options.fallingColor : \"#e40a0a\";\n          var s = \"number\" === typeof w.options.lineThickness ? Math.round(w.lineThickness) : 1,\n              z = 1 === Math.round(s) % 2 ? -0.5 : 0;\n          if (0 < x.length) for (var u = 5 < q && w.bevelEnabled ? !0 : !1, t = !1, B = null, D = null, r = 0; r < x.length; r++) if (x[r].getTime ? l = x[r].x.getTime() : l = x[r].x, \"number\" !== typeof x[r].y) {\n            if (0 < r && !t && w.connectNullData) var C = w.options.nullDataLineDashType || !x[r - 1].lineDashType ? w.nullDataLineDashType : x[r - 1].lineDashType;\n            t = !0;\n          } else {\n            d = a.axisX.convertValueToPixel(l);\n            n = 0 === w.dataPointEOs[r].cumulativeSum ? p : a.axisY.convertValueToPixel(w.dataPointEOs[r].cumulativeSum);\n            k = 0 === w.dataPointEOs[r].cumulativeSumYStartValue ? p : a.axisY.convertValueToPixel(w.dataPointEOs[r].cumulativeSumYStartValue);\n            d = a.axisX.reversed ? d + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + g) * q << 0 : d - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + g) * q << 0;\n            var A = a.axisX.reversed ? d - q << 0 : d + q << 0;\n            n > k && (f = n, n = k, k = f);\n            a.axisY.reversed && (f = n, n = k, k = f);\n            f = w.dataPointIds[r];\n            this._eventManager.objectMap[f] = {\n              id: f,\n              objectType: \"dataPoint\",\n              dataSeriesIndex: m,\n              dataPointIndex: r,\n              x1: d,\n              y1: n,\n              x2: A,\n              y2: k\n            };\n            var J = x[r].color ? x[r].color : 0 < x[r].y ? w.risingColor : w.fallingColor;\n            aa(c, a.axisX.reversed ? A : d, a.axisY.reversed ? k : n, a.axisX.reversed ? d : A, a.axisY.reversed ? n : k, J, 0, J, u, u, !1, !1, w.fillOpacity);\n            f = W(f);\n            v && aa(this._eventManager.ghostCtx, a.axisX.reversed ? A : d, n, a.axisX.reversed ? d : A, k, f, 0, null, !1, !1, !1, !1);\n            var T,\n                J = d;\n            T = \"undefined\" !== typeof x[r].isIntermediateSum && !0 === x[r].isIntermediateSum || \"undefined\" !== typeof x[r].isCumulativeSum && !0 === x[r].isCumulativeSum ? 0 < x[r].y ? n : k : 0 < x[r].y ? k : n;\n            0 < r && B && (!t || w.connectNullData) && (t && c.setLineDash && c.setLineDash(G(C, s)), c.beginPath(), c.moveTo(B, D - z), c.lineTo(J, T - z), 0 < s && c.stroke(), v && (b.beginPath(), b.moveTo(B, D - z), b.lineTo(J, T - z), 0 < s && b.stroke()));\n            t = !1;\n            B = A;\n            D = 0 < x[r].y ? n : k;\n            J = x[r].lineDashType ? x[r].lineDashType : w.options.lineDashType ? w.options.lineDashType : \"shortDash\";\n            c.strokeStyle = x[r].lineColor ? x[r].lineColor : w.options.lineColor ? w.options.lineColor : \"#9e9e9e\";\n            c.lineWidth = s;\n            c.setLineDash && (J = G(J, s), c.setLineDash(J));\n            (x[r].indexLabel || w.indexLabel || x[r].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({\n              chartType: \"waterfall\",\n              dataPoint: x[r],\n              dataSeries: w,\n              point: {\n                x: d + (A - d) / 2,\n                y: 0 <= x[r].y ? n : k\n              },\n              direction: 0 > x[r].y === a.axisY.reversed ? 1 : -1,\n              bounds: {\n                x1: d,\n                y1: Math.min(n, k),\n                x2: A,\n                y2: Math.max(n, k)\n              },\n              color: f\n            });\n          }\n        }\n\n        v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());\n        c.restore();\n        return {\n          source: e,\n          dest: this.plotArea.ctx,\n          animationCallback: K.fadeInAnimation,\n          easingFunction: K.easing.easeInQuad,\n          animationBase: 0\n        };\n      }\n    };\n\n    var ia = function (a, e, c, b, f, h, r, d, n) {\n      if (!(0 > c)) {\n        \"undefined\" === typeof d && (d = 1);\n\n        if (!v) {\n          var k = Number((r % (2 * Math.PI)).toFixed(8));\n          Number((h % (2 * Math.PI)).toFixed(8)) === k && (r -= 1E-4);\n        }\n\n        a.save();\n        a.globalAlpha = d;\n        \"pie\" === f ? (a.beginPath(), a.moveTo(e.x, e.y), a.arc(e.x, e.y, c, h, r, !1), a.fillStyle = b, a.strokeStyle = \"white\", a.lineWidth = 2, a.closePath(), a.fill()) : \"doughnut\" === f && (a.beginPath(), a.arc(e.x, e.y, c, h, r, !1), 0 <= n && a.arc(e.x, e.y, n * c, r, h, !0), a.closePath(), a.fillStyle = b, a.strokeStyle = \"white\", a.lineWidth = 2, a.fill());\n        a.globalAlpha = 1;\n        a.restore();\n      }\n    };\n\n    m.prototype.renderPie = function (a) {\n      function e() {\n        if (k && l) {\n          var a = 0,\n              b = 0,\n              c = 0,\n              f = 0;\n          n(k.options.indexLabelMaxWidth) && (k.indexLabelMaxWidth = 0.33 * q.width);\n\n          for (var e = 0; e < l.length; e++) {\n            var h = l[e],\n                r = k.dataPointIds[e];\n            g[e].id = r;\n            g[e].objectType = \"dataPoint\";\n            g[e].dataPointIndex = e;\n            g[e].dataSeriesIndex = 0;\n            var d = g[e],\n                p = {\n              percent: null,\n              total: null\n            },\n                y = null,\n                p = m.getPercentAndTotal(k, h);\n            if (k.indexLabelFormatter || h.indexLabelFormatter) y = {\n              chart: m.options,\n              dataSeries: k,\n              dataPoint: h,\n              total: p.total,\n              percent: p.percent\n            };\n            p = h.indexLabelFormatter ? h.indexLabelFormatter(y) : h.indexLabel ? m.replaceKeywordsWithValue(h.indexLabel, h, k, e) : k.indexLabelFormatter ? k.indexLabelFormatter(y) : k.indexLabel ? m.replaceKeywordsWithValue(k.indexLabel, h, k, e) : h.label ? h.label : \"\";\n            m._eventManager.objectMap[r] = d;\n            d.center = {\n              x: u.x,\n              y: u.y\n            };\n            d.y = h.y;\n            d.radius = A;\n            d.percentInnerRadius = H;\n            d.indexLabelText = p;\n            d.indexLabelPlacement = k.indexLabelPlacement;\n            d.indexLabelLineColor = h.indexLabelLineColor ? h.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : h.color ? h.color : k._colorSet[e % k._colorSet.length];\n            d.indexLabelLineThickness = n(h.indexLabelLineThickness) ? k.indexLabelLineThickness : h.indexLabelLineThickness;\n            d.indexLabelLineDashType = h.indexLabelLineDashType ? h.indexLabelLineDashType : k.indexLabelLineDashType;\n            d.indexLabelFontColor = h.indexLabelFontColor ? h.indexLabelFontColor : k.indexLabelFontColor;\n            d.indexLabelFontStyle = h.indexLabelFontStyle ? h.indexLabelFontStyle : k.indexLabelFontStyle;\n            d.indexLabelFontWeight = h.indexLabelFontWeight ? h.indexLabelFontWeight : k.indexLabelFontWeight;\n            d.indexLabelFontSize = n(h.indexLabelFontSize) ? k.indexLabelFontSize : h.indexLabelFontSize;\n            d.indexLabelFontFamily = h.indexLabelFontFamily ? h.indexLabelFontFamily : k.indexLabelFontFamily;\n            d.indexLabelBackgroundColor = h.indexLabelBackgroundColor ? h.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ? k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;\n            d.indexLabelMaxWidth = h.indexLabelMaxWidth ? h.indexLabelMaxWidth : k.indexLabelMaxWidth;\n            d.indexLabelWrap = \"undefined\" !== typeof h.indexLabelWrap ? h.indexLabelWrap : k.indexLabelWrap;\n            d.indexLabelTextAlign = h.indexLabelTextAlign ? h.indexLabelTextAlign : k.indexLabelTextAlign ? k.indexLabelTextAlign : \"left\";\n            d.startAngle = 0 === e ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : g[e - 1].endAngle;\n            d.startAngle = (d.startAngle + 2 * Math.PI) % (2 * Math.PI);\n            d.endAngle = d.startAngle + 2 * Math.PI / t * Math.abs(h.y);\n            h = (d.endAngle + d.startAngle) / 2;\n            h = (h + 2 * Math.PI) % (2 * Math.PI);\n            d.midAngle = h;\n\n            if (d.midAngle > Math.PI / 2 - s && d.midAngle < Math.PI / 2 + s) {\n              if (0 === a || g[c].midAngle > d.midAngle) c = e;\n              a++;\n            } else if (d.midAngle > 3 * Math.PI / 2 - s && d.midAngle < 3 * Math.PI / 2 + s) {\n              if (0 === b || g[f].midAngle > d.midAngle) f = e;\n              b++;\n            }\n\n            d.hemisphere = h > Math.PI / 2 && h <= 3 * Math.PI / 2 ? \"left\" : \"right\";\n            d.indexLabelTextBlock = new ja(m.plotArea.ctx, {\n              fontSize: d.indexLabelFontSize,\n              fontFamily: d.indexLabelFontFamily,\n              fontColor: d.indexLabelFontColor,\n              fontStyle: d.indexLabelFontStyle,\n              fontWeight: d.indexLabelFontWeight,\n              textAlign: d.indexLabelTextAlign,\n              backgroundColor: d.indexLabelBackgroundColor,\n              maxWidth: d.indexLabelMaxWidth,\n              maxHeight: d.indexLabelWrap ? 5 * d.indexLabelFontSize : 1.5 * d.indexLabelFontSize,\n              text: d.indexLabelText,\n              padding: 0,\n              textBaseline: \"middle\"\n            });\n            d.indexLabelTextBlock.measureText();\n          }\n\n          r = h = 0;\n          p = !1;\n\n          for (e = 0; e < l.length; e++) d = g[(c + e) % l.length], 1 < a && d.midAngle > Math.PI / 2 - s && d.midAngle < Math.PI / 2 + s && (h <= a / 2 && !p ? (d.hemisphere = \"right\", h++) : (d.hemisphere = \"left\", p = !0));\n\n          p = !1;\n\n          for (e = 0; e < l.length; e++) d = g[(f + e) % l.length], 1 < b && d.midAngle > 3 * Math.PI / 2 - s && d.midAngle < 3 * Math.PI / 2 + s && (r <= b / 2 && !p ? (d.hemisphere = \"left\", r++) : (d.hemisphere = \"right\", p = !0));\n        }\n      }\n\n      function c(a, b) {\n        var c = m.plotArea.ctx;\n        c.clearRect(q.x1, q.y1, q.width, q.height);\n        c.fillStyle = m.backgroundColor;\n        c.fillRect(q.x1, q.y1, q.width, q.height);\n\n        for (c = 0; c < l.length; c++) {\n          var e = g[c].startAngle,\n              f = g[c].endAngle;\n\n          if (f > e) {\n            var h = 0.07 * A * Math.cos(g[c].midAngle),\n                d = 0.07 * A * Math.sin(g[c].midAngle),\n                r = !1;\n\n            if (l[c].exploded) {\n              if (1E-9 < Math.abs(g[c].center.x - (u.x + h)) || 1E-9 < Math.abs(g[c].center.y - (u.y + d))) g[c].center.x = u.x + h * a, g[c].center.y = u.y + d * a, r = !0;\n            } else if (0 < Math.abs(g[c].center.x - u.x) || 0 < Math.abs(g[c].center.y - u.y)) g[c].center.x = u.x + h * (1 - a), g[c].center.y = u.y + d * (1 - a), r = !0;\n\n            r && b && (h = {}, h.dataSeries = k, h.dataPoint = k.dataPoints[c], h.index = c, m.toolTip.highlightObjects([h]));\n            ia(m.plotArea.ctx, g[c].center, g[c].radius, l[c].color ? l[c].color : k._colorSet[c % k._colorSet.length], k.type, e, f, k.fillOpacity, g[c].percentInnerRadius);\n          }\n        }\n\n        c = m.plotArea.ctx;\n        c.save();\n        c.fillStyle = \"black\";\n        c.strokeStyle = \"grey\";\n        c.textBaseline = \"middle\";\n        c.lineJoin = \"round\";\n\n        for (e = e = 0; e < l.length; e++) f = g[e], f.indexLabelText && (f.indexLabelTextBlock.y -= f.indexLabelTextBlock.height / 2 - f.indexLabelTextBlock.fontSize / 2, h = 0, h = \"left\" === f.hemisphere ? \"inside\" !== k.indexLabelPlacement ? -(f.indexLabelTextBlock.width + p) : -f.indexLabelTextBlock.width / 2 : \"inside\" !== k.indexLabelPlacement ? p : -f.indexLabelTextBlock.width / 2, f.indexLabelTextBlock.x += h, f.indexLabelTextBlock.render(!0), f.indexLabelTextBlock.x -= h, f.indexLabelTextBlock.y += f.indexLabelTextBlock.height / 2 - f.indexLabelTextBlock.fontSize / 2, \"inside\" !== f.indexLabelPlacement && 0 < f.indexLabelLineThickness && (h = f.center.x + A * Math.cos(f.midAngle), d = f.center.y + A * Math.sin(f.midAngle), c.strokeStyle = f.indexLabelLineColor, c.lineWidth = f.indexLabelLineThickness, c.setLineDash && c.setLineDash(G(f.indexLabelLineDashType, f.indexLabelLineThickness)), c.beginPath(), c.moveTo(h, d), c.lineTo(f.indexLabelTextBlock.x, f.indexLabelTextBlock.y), c.lineTo(f.indexLabelTextBlock.x + (\"left\" === f.hemisphere ? -p : p), f.indexLabelTextBlock.y), c.stroke()), c.lineJoin = \"miter\");\n\n        c.save();\n      }\n\n      function b(a, b) {\n        var c = 0,\n            c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2,\n            g = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2,\n            f = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2,\n            e = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2;\n        return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? f - g : c - e;\n      }\n\n      function f(a) {\n        for (var c = null, f = 1; f < l.length; f++) if (c = (a + f + g.length) % g.length, g[c].hemisphere !== g[a].hemisphere) {\n          c = null;\n          break;\n        } else if (g[c].indexLabelText && c !== a && (0 > b(g[c], g[a]) || (\"right\" === g[a].hemisphere ? g[c].indexLabelTextBlock.y >= g[a].indexLabelTextBlock.y : g[c].indexLabelTextBlock.y <= g[a].indexLabelTextBlock.y))) break;else c = null;\n\n        return c;\n      }\n\n      function h(a, c, e) {\n        e = (e || 0) + 1;\n        if (1E3 < e) return 0;\n        c = c || 0;\n        var d = 0,\n            r = u.y - 1 * w,\n            k = u.y + 1 * w;\n\n        if (0 <= a && a < l.length) {\n          var p = g[a];\n          if (0 > c && p.indexLabelTextBlock.y < r || 0 < c && p.indexLabelTextBlock.y > k) return 0;\n          var q = 0,\n              n = 0,\n              n = q = q = 0;\n          0 > c ? p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 > r && p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 + c < r && (c = -(r - (p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 + c))) : p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2 < r && p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2 + c > k && (c = p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2 + c - k);\n          c = p.indexLabelTextBlock.y + c;\n          r = 0;\n          r = \"right\" === p.hemisphere ? u.x + Math.sqrt(Math.pow(w, 2) - Math.pow(c - u.y, 2)) : u.x - Math.sqrt(Math.pow(w, 2) - Math.pow(c - u.y, 2));\n          n = u.x + A * Math.cos(p.midAngle);\n          q = u.y + A * Math.sin(p.midAngle);\n          q = Math.sqrt(Math.pow(r - n, 2) + Math.pow(c - q, 2));\n          n = Math.acos(A / w);\n          q = Math.acos((w * w + A * A - q * q) / (2 * A * w));\n          c = q < n ? c - p.indexLabelTextBlock.y : 0;\n          r = null;\n\n          for (k = 1; k < l.length; k++) if (r = (a - k + g.length) % g.length, g[r].hemisphere !== g[a].hemisphere) {\n            r = null;\n            break;\n          } else if (g[r].indexLabelText && g[r].hemisphere === g[a].hemisphere && r !== a && (0 > b(g[r], g[a]) || (\"right\" === g[a].hemisphere ? g[r].indexLabelTextBlock.y <= g[a].indexLabelTextBlock.y : g[r].indexLabelTextBlock.y >= g[a].indexLabelTextBlock.y))) break;else r = null;\n\n          n = r;\n          q = f(a);\n          k = r = 0;\n          0 > c ? (k = \"right\" === p.hemisphere ? n : q, d = c, null !== k && (n = -c, c = p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 - (g[k].indexLabelTextBlock.y + g[k].indexLabelTextBlock.height / 2), c - n < v && (r = -n, k = h(k, r, e + 1), +k.toFixed(z) > +r.toFixed(z) && (d = c > v ? -(c - v) : -(n - (k - r)))))) : 0 < c && (k = \"right\" === p.hemisphere ? q : n, d = c, null !== k && (n = c, c = g[k].indexLabelTextBlock.y - g[k].indexLabelTextBlock.height / 2 - (p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2), c - n < v && (r = n, k = h(k, r, e + 1), +k.toFixed(z) < +r.toFixed(z) && (d = c > v ? c - v : n - (r - k)))));\n          d && (e = p.indexLabelTextBlock.y + d, c = 0, c = \"right\" === p.hemisphere ? u.x + Math.sqrt(Math.pow(w, 2) - Math.pow(e - u.y, 2)) : u.x - Math.sqrt(Math.pow(w, 2) - Math.pow(e - u.y, 2)), p.midAngle > Math.PI / 2 - s && p.midAngle < Math.PI / 2 + s ? (r = (a - 1 + g.length) % g.length, r = g[r], a = g[(a + 1 + g.length) % g.length], \"left\" === p.hemisphere && \"right\" === r.hemisphere && c > r.indexLabelTextBlock.x ? c = r.indexLabelTextBlock.x - 15 : \"right\" === p.hemisphere && \"left\" === a.hemisphere && c < a.indexLabelTextBlock.x && (c = a.indexLabelTextBlock.x + 15)) : p.midAngle > 3 * Math.PI / 2 - s && p.midAngle < 3 * Math.PI / 2 + s && (r = (a - 1 + g.length) % g.length, r = g[r], a = g[(a + 1 + g.length) % g.length], \"right\" === p.hemisphere && \"left\" === r.hemisphere && c < r.indexLabelTextBlock.x ? c = r.indexLabelTextBlock.x + 15 : \"left\" === p.hemisphere && \"right\" === a.hemisphere && c > a.indexLabelTextBlock.x && (c = a.indexLabelTextBlock.x - 15)), p.indexLabelTextBlock.y = e, p.indexLabelTextBlock.x = c, p.indexLabelAngle = Math.atan2(p.indexLabelTextBlock.y - u.y, p.indexLabelTextBlock.x - u.x));\n        }\n\n        return d;\n      }\n\n      function r() {\n        var a = m.plotArea.ctx;\n        a.fillStyle = \"grey\";\n        a.strokeStyle = \"grey\";\n        a.font = \"16px Arial\";\n        a.textBaseline = \"middle\";\n\n        for (var c = a = 0, e = 0, d = !0, c = 0; 10 > c && (1 > c || 0 < e); c++) {\n          if (k.radius || !k.radius && \"undefined\" !== typeof k.innerRadius && null !== k.innerRadius && A - e <= C) d = !1;\n          d && (A -= e);\n          e = 0;\n\n          if (\"inside\" !== k.indexLabelPlacement) {\n            w = A * x;\n\n            for (a = 0; a < l.length; a++) {\n              var r = g[a];\n              r.indexLabelTextBlock.x = u.x + w * Math.cos(r.midAngle);\n              r.indexLabelTextBlock.y = u.y + w * Math.sin(r.midAngle);\n              r.indexLabelAngle = r.midAngle;\n              r.radius = A;\n              r.percentInnerRadius = H;\n            }\n\n            for (var n, s, a = 0; a < l.length; a++) {\n              var r = g[a],\n                  y = f(a);\n\n              if (null !== y) {\n                n = g[a];\n                s = g[y];\n                var t = 0,\n                    t = b(n, s) - v;\n\n                if (0 > t) {\n                  for (var B = s = 0, G = 0; G < l.length; G++) G !== a && g[G].hemisphere === r.hemisphere && (g[G].indexLabelTextBlock.y < r.indexLabelTextBlock.y ? s++ : B++);\n\n                  s = t / (s + B || 1) * B;\n                  var B = -1 * (t - s),\n                      K = G = 0;\n                  \"right\" === r.hemisphere ? (G = h(a, s), B = -1 * (t - G), K = h(y, B), +K.toFixed(z) < +B.toFixed(z) && +G.toFixed(z) <= +s.toFixed(z) && h(a, -(B - K))) : (G = h(y, s), B = -1 * (t - G), K = h(a, B), +K.toFixed(z) < +B.toFixed(z) && +G.toFixed(z) <= +s.toFixed(z) && h(y, -(B - K)));\n                }\n              }\n            }\n          } else for (a = 0; a < l.length; a++) r = g[a], w = \"pie\" === k.type ? 0.7 * A : 0.85 * A, y = u.x + w * Math.cos(r.midAngle), s = u.y + w * Math.sin(r.midAngle), r.indexLabelTextBlock.x = y, r.indexLabelTextBlock.y = s;\n\n          for (a = 0; a < l.length; a++) if (r = g[a], y = r.indexLabelTextBlock.measureText(), 0 !== y.height && 0 !== y.width) y = y = 0, \"right\" === r.hemisphere ? (y = q.x2 - (r.indexLabelTextBlock.x + r.indexLabelTextBlock.width + p), y *= -1) : y = q.x1 - (r.indexLabelTextBlock.x - r.indexLabelTextBlock.width - p), 0 < y && (!d && r.indexLabelText && (s = \"right\" === r.hemisphere ? q.x2 - r.indexLabelTextBlock.x : r.indexLabelTextBlock.x - q.x1, 0.3 * r.indexLabelTextBlock.maxWidth > s ? r.indexLabelText = \"\" : r.indexLabelTextBlock.maxWidth = 0.85 * s, 0.3 * r.indexLabelTextBlock.maxWidth < s && (r.indexLabelTextBlock.x -= \"right\" === r.hemisphere ? 2 : -2)), Math.abs(r.indexLabelTextBlock.y - r.indexLabelTextBlock.height / 2 - u.y) < A || Math.abs(r.indexLabelTextBlock.y + r.indexLabelTextBlock.height / 2 - u.y) < A) && (y /= Math.abs(Math.cos(r.indexLabelAngle)), 9 < y && (y *= 0.3), y > e && (e = y)), y = y = 0, 0 < r.indexLabelAngle && r.indexLabelAngle < Math.PI ? (y = q.y2 - (r.indexLabelTextBlock.y + r.indexLabelTextBlock.height / 2 + 5), y *= -1) : y = q.y1 - (r.indexLabelTextBlock.y - r.indexLabelTextBlock.height / 2 - 5), 0 < y && (!d && r.indexLabelText && (s = 0 < r.indexLabelAngle && r.indexLabelAngle < Math.PI ? -1 : 1, 0 === h(a, y * s) && h(a, 2 * s)), Math.abs(r.indexLabelTextBlock.x - u.x) < A && (y /= Math.abs(Math.sin(r.indexLabelAngle)), 9 < y && (y *= 0.3), y > e && (e = y)));\n\n          var M = function (a, b, c) {\n            for (var f = [], e = 0; f.push(g[b]), b !== c; b = (b + 1 + l.length) % l.length);\n\n            f.sort(function (a, b) {\n              return a.y - b.y;\n            });\n\n            for (b = 0; b < f.length; b++) if (c = f[b], e < 0.7 * a) e += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = \"\", c.indexLabelText = \"\", c.indexLabelTextBlock.measureText();else break;\n          };\n\n          (function () {\n            for (var a = -1, c = -1, e = 0, h = !1, r = 0; r < l.length; r++) if (h = !1, n = g[r], n.indexLabelText) {\n              var d = f(r);\n\n              if (null !== d) {\n                var k = g[d];\n                t = 0;\n                t = b(n, k);\n                var q;\n\n                if (q = 0 > t) {\n                  q = n.indexLabelTextBlock.x;\n                  var m = n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2,\n                      s = n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2,\n                      y = k.indexLabelTextBlock.y - k.indexLabelTextBlock.height / 2,\n                      u = k.indexLabelTextBlock.x + k.indexLabelTextBlock.width,\n                      w = k.indexLabelTextBlock.y + k.indexLabelTextBlock.height / 2;\n                  q = n.indexLabelTextBlock.x + n.indexLabelTextBlock.width < k.indexLabelTextBlock.x - p || q > u + p || m > w + p || s < y - p ? !1 : !0;\n                }\n\n                q ? (0 > a && (a = r), d !== a && (c = d, e += -t), 0 === r % Math.max(l.length / 10, 3) && (h = !0)) : h = !0;\n                h && 0 < e && 0 <= a && 0 <= c && (M(e, a, c), c = a = -1, e = 0);\n              }\n            }\n\n            0 < e && M(e, a, c);\n          })();\n        }\n      }\n\n      function d() {\n        m.plotArea.layoutManager.reset();\n        m.title && (m.title.dockInsidePlotArea || \"center\" === m.title.horizontalAlign && \"center\" === m.title.verticalAlign) && m.title.render();\n        if (m.subtitles) for (var a = 0; a < m.subtitles.length; a++) {\n          var b = m.subtitles[a];\n          (b.dockInsidePlotArea || \"center\" === b.horizontalAlign && \"center\" === b.verticalAlign) && b.render();\n        }\n        m.legend && (m.legend.dockInsidePlotArea || \"center\" === m.legend.horizontalAlign && \"center\" === m.legend.verticalAlign) && (m.legend.setLayout(), m.legend.render());\n      }\n\n      var m = this;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        var k = this.data[a.dataSeriesIndexes[0]],\n            l = k.dataPoints,\n            p = 10,\n            q = this.plotArea,\n            g = k.dataPointEOs,\n            v = 2,\n            w,\n            x = 1.3,\n            s = 20 / 180 * Math.PI,\n            z = 6,\n            u = {\n          x: (q.x2 + q.x1) / 2,\n          y: (q.y2 + q.y1) / 2\n        },\n            t = 0;\n        a = !1;\n\n        for (var B = 0; B < l.length; B++) t += Math.abs(l[B].y), !a && \"undefined\" !== typeof l[B].indexLabel && null !== l[B].indexLabel && 0 < l[B].indexLabel.toString().length && (a = !0), !a && \"undefined\" !== typeof l[B].label && null !== l[B].label && 0 < l[B].label.toString().length && (a = !0);\n\n        if (0 !== t) {\n          a = a || \"undefined\" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;\n          var A = \"inside\" !== k.indexLabelPlacement && a ? 0.75 * Math.min(q.width, q.height) / 2 : 0.92 * Math.min(q.width, q.height) / 2;\n          k.radius && (A = Ua(k.radius, A));\n          var C = \"undefined\" !== typeof k.innerRadius && null !== k.innerRadius ? Ua(k.innerRadius, A) : 0.7 * A;\n          k.radius = A;\n          \"doughnut\" === k.type && (k.innerRadius = C);\n          var H = Math.min(C / A, (A - 1) / A);\n\n          this.pieDoughnutClickHandler = function (a) {\n            m.isAnimating || !n(this.explodeOnClick) && !this.explodeOnClick || (a = a.dataPoint, a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && m._animator.animate(0, 500, function (a) {\n              c(a, !0);\n              d();\n              m.dispatchEvent(\"dataAnimationIterationEnd\", {\n                chart: m\n              });\n              m.dispatchEvent(\"dataAnimationEnd\", {\n                chart: m\n              });\n            }));\n          };\n\n          e();\n          r();\n          r();\n          r();\n          r();\n          this.disableToolTip = !0;\n\n          this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) {\n            var b = m.plotArea.ctx;\n            b.clearRect(q.x1, q.y1, q.width, q.height);\n            b.fillStyle = m.backgroundColor;\n            b.fillRect(q.x1, q.y1, q.width, q.height);\n\n            for (var b = g[0].startAngle + 2 * Math.PI * a, c = 0; c < l.length; c++) {\n              var e = 0 === c ? g[c].startAngle : f,\n                  f = e + (g[c].endAngle - g[c].startAngle),\n                  h = !1;\n              f > b && (f = b, h = !0);\n              var r = l[c].color ? l[c].color : k._colorSet[c % k._colorSet.length];\n              f > e && ia(m.plotArea.ctx, g[c].center, g[c].radius, r, k.type, e, f, k.fillOpacity, g[c].percentInnerRadius);\n              if (h) break;\n            }\n\n            d();\n            m.dispatchEvent(\"dataAnimationIterationEnd\", {\n              chart: m\n            });\n            1 <= a && m.dispatchEvent(\"dataAnimationEnd\", {\n              chart: m\n            });\n          }, function () {\n            m.disableToolTip = !1;\n\n            m._animator.animate(0, m.animatedRender ? 500 : 0, function (a) {\n              c(a, !1);\n              d();\n              m.dispatchEvent(\"dataAnimationIterationEnd\", {\n                chart: m\n              });\n            });\n\n            m.dispatchEvent(\"dataAnimationEnd\", {\n              chart: m\n            });\n          });\n        }\n      }\n    };\n\n    var qa = function (a, e, c, b) {\n      \"undefined\" === typeof c && (c = 1);\n      0 >= Math.round(e.y4 - e.y1) || (a.save(), a.globalAlpha = c, a.beginPath(), a.moveTo(Math.round(e.x1), Math.round(e.y1)), a.lineTo(Math.round(e.x2), Math.round(e.y2)), a.lineTo(Math.round(e.x3), Math.round(e.y3)), a.lineTo(Math.round(e.x4), Math.round(e.y4)), \"undefined\" !== e.x5 && (a.lineTo(Math.round(e.x5), Math.round(e.y5)), a.lineTo(Math.round(e.x6), Math.round(e.y6))), a.closePath(), a.fillStyle = b ? b : e.color, a.fill(), a.globalAplha = 1, a.restore());\n    };\n\n    m.prototype.renderFunnel = function (a) {\n      function e() {\n        for (var a = 0, b = [], c = 0; c < z.length; c++) {\n          if (\"undefined\" === typeof z[c].y) return -1;\n          z[c].y = \"number\" === typeof z[c].y ? z[c].y : 0;\n          a += Math.abs(z[c].y);\n        }\n\n        if (0 === a) return -1;\n\n        for (c = b[0] = 0; c < z.length; c++) b.push(Math.abs(z[c].y) * H / a);\n\n        return b;\n      }\n\n      function c() {\n        var a = U,\n            b = X,\n            c = M,\n            f = Y,\n            e,\n            g;\n        e = Z;\n        g = O - N;\n        f = Math.abs((g - e) * (b - a + (f - c)) / 2);\n        c = Y - M;\n        e = g - e;\n        g = c * (g - O);\n        g = Math.abs(g);\n        g = f + g;\n\n        for (var f = [], h = 0, r = 0; r < z.length; r++) {\n          if (\"undefined\" === typeof z[r].y) return -1;\n          z[r].y = \"number\" === typeof z[r].y ? z[r].y : 0;\n          h += Math.abs(z[r].y);\n        }\n\n        if (0 === h) return -1;\n\n        for (var d = f[0] = 0, k = 0, l, p, b = b - a, d = !1, r = 0; r < z.length; r++) a = Math.abs(z[r].y) * g / h, d ? l = 0 == Number(c.toFixed(3)) ? 0 : a / c : (p = ca * ca * b * b - 4 * Math.abs(ca) * a, 0 > p ? (p = c, d = (b + p) * (e - k) / 2, a -= d, l = e - k, k += e - k, l += 0 == p ? 0 : a / p, k += a / p, d = !0) : (l = (Math.abs(ca) * b - Math.sqrt(p)) / 2, p = b - 2 * l / Math.abs(ca), k += l, k > e && (k -= l, p = c, d = (b + p) * (e - k) / 2, a -= d, l = e - k, k += e - k, l += a / p, k += a / p, d = !0), b = p)), f.push(l);\n\n        return f;\n      }\n\n      function b() {\n        if (s && z) {\n          for (var a, b, c, e, f, h, r, d, k, l, p, q, m, y, u, w = [], t = [], I = {\n            percent: null,\n            total: null\n          }, A = null, B = 0; B < z.length; B++) u = R[B], u = \"undefined\" !== typeof u.x5 ? (u.y2 + u.y4) / 2 : (u.y2 + u.y3) / 2, u = g(u).x2 + 1, w[B] = Q - u - W;\n\n          u = 0.5 * W;\n\n          for (var B = 0, C = z.length - 1; B < z.length || 0 <= C; B++, C--) {\n            b = s.reversed ? z[C] : z[B];\n            a = b.color ? b.color : s.reversed ? s._colorSet[(z.length - 1 - B) % s._colorSet.length] : s._colorSet[B % s._colorSet.length];\n            c = b.indexLabelPlacement || s.indexLabelPlacement || \"outside\";\n            y = b.indexLabelTextAlign || s.indexLabelTextAlign || \"left\";\n            e = b.indexLabelBackgroundColor || s.indexLabelBackgroundColor || (v ? \"transparent\" : null);\n            f = b.indexLabelFontColor || s.indexLabelFontColor || \"#979797\";\n            h = n(b.indexLabelFontSize) ? s.indexLabelFontSize : b.indexLabelFontSize;\n            r = b.indexLabelFontStyle || s.indexLabelFontStyle || \"normal\";\n            d = b.indexLabelFontFamily || s.indexLabelFontFamily || \"arial\";\n            k = b.indexLabelFontWeight || s.indexLabelFontWeight || \"normal\";\n            a = b.indexLabelLineColor || s.options.indexLabelLineColor || a;\n            l = \"number\" === typeof b.indexLabelLineThickness ? b.indexLabelLineThickness : \"number\" === typeof s.indexLabelLineThickness ? s.indexLabelLineThickness : 2;\n            p = b.indexLabelLineDashType || s.indexLabelLineDashType || \"solid\";\n            q = \"undefined\" !== typeof b.indexLabelWrap ? b.indexLabelWrap : \"undefined\" !== typeof s.indexLabelWrap ? s.indexLabelWrap : !0;\n            m = s.dataPointIds[B];\n            x._eventManager.objectMap[m] = {\n              id: m,\n              objectType: \"dataPoint\",\n              dataPointIndex: B,\n              dataSeriesIndex: 0,\n              funnelSection: R[s.reversed ? z.length - 1 - B : B]\n            };\n            \"inside\" === s.indexLabelPlacement && (w[B] = B !== da ? s.reversed ? R[B].x2 - R[B].x1 : R[B].x3 - R[B].x4 : R[B].x3 - R[B].x6, 20 > w[B] && (w[B] = B !== da ? s.reversed ? R[B].x3 - R[B].x4 : R[B].x2 - R[B].x1 : R[B].x2 - R[B].x1, w[B] /= 2));\n            m = b.indexLabelMaxWidth ? b.indexLabelMaxWidth : s.options.indexLabelMaxWidth ? s.indexLabelMaxWidth : w[B];\n            if (m > w[B] || 0 > m) m = w[B];\n            t[B] = \"inside\" === s.indexLabelPlacement ? q ? Math.max(R[B].height, h) : 1.5 * h : !1;\n            I = x.getPercentAndTotal(s, b);\n            if (s.indexLabelFormatter || b.indexLabelFormatter) A = {\n              chart: x.options,\n              dataSeries: s,\n              dataPoint: b,\n              total: I.total,\n              percent: I.percent\n            };\n            b = b.indexLabelFormatter ? b.indexLabelFormatter(A) : b.indexLabel ? x.replaceKeywordsWithValue(b.indexLabel, b, s, B) : s.indexLabelFormatter ? s.indexLabelFormatter(A) : s.indexLabel ? x.replaceKeywordsWithValue(s.indexLabel, b, s, B) : b.label ? b.label : \"\";\n            0 >= l && (l = 0);\n            1E3 > m && 1E3 - m < u && (m += 1E3 - m);\n            n(s.options.indexLabelMaxWidth) && (s.indexLabelMaxWidth = n(s.indexLabelMaxWidth) ? m : Math.max(m, s.indexLabelMaxWidth));\n            P.roundRect || za(P);\n            c = new ja(P, {\n              fontSize: h,\n              fontFamily: d,\n              fontColor: f,\n              fontStyle: r,\n              fontWeight: k,\n              horizontalAlign: c,\n              textAlign: y,\n              backgroundColor: e,\n              maxWidth: m,\n              maxHeight: !1 === t[B] ? q ? 4.28571429 * h : 1.5 * h : t[B],\n              text: b,\n              padding: ea,\n              textBaseline: \"middle\"\n            });\n            c.measureText();\n            c.height = c.height === 2 * c.padding ? 0 : c.height;\n            c.width = c.width === 2 * c.padding ? 0 : c.width;\n            F.push({\n              textBlock: c,\n              id: s.reversed ? C : B,\n              isDirty: !1,\n              lineColor: a,\n              lineThickness: l,\n              lineDashType: p,\n              height: c.height < c.maxHeight ? c.height : c.maxHeight,\n              width: c.width < c.maxWidth ? c.width : c.maxWidth\n            });\n          }\n        }\n      }\n\n      function f() {\n        var a,\n            b,\n            c,\n            e,\n            f,\n            g = [];\n        f = !1;\n        c = 0;\n\n        for (var h, r = Q - X - W / 2, r = s.options.indexLabelMaxWidth ? s.indexLabelMaxWidth > r ? r : s.indexLabelMaxWidth : r, d = F.length - 1; 0 <= d; d--) {\n          h = z[F[d].id];\n          c = F[d];\n          e = c.textBlock;\n          b = (a = q(d) < R.length ? F[q(d)] : null) ? a.textBlock : null;\n          c = c.height;\n          a && e.y + c + ea > b.y && (f = !0);\n          c = h.indexLabelMaxWidth || r;\n          if (c > r || 0 > c) c = r;\n          g.push(c);\n        }\n\n        if (f) for (d = F.length - 1; 0 <= d; d--) a = R[d], F[d].textBlock.maxWidth = g[g.length - (d + 1)], F[d].textBlock.measureText(), F[d].textBlock.height = F[d].textBlock.height === 2 * F[d].textBlock.padding ? 0 : F[d].textBlock.height, F[d].textBlock.width = F[d].textBlock.width === 2 * F[d].textBlock.padding ? 0 : F[d].textBlock.width, F[d].textBlock.x = Q - r, c = F[d].textBlock.height < F[d].textBlock.maxHeight ? F[d].textBlock.height : F[d].textBlock.maxHeight, f = F[d].textBlock.width < F[d].textBlock.maxWidth ? F[d].textBlock.width : F[d].textBlock.maxWidth, F[d].height = c, F[d].width = f, c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, F[d].textBlock.y = c - F[d].height / 2, s.reversed ? (F[d].textBlock.y + F[d].height > S + A && (F[d].textBlock.y = S + A - F[d].height), F[d].textBlock.y < ta - A && (F[d].textBlock.y = ta - A)) : (F[d].textBlock.y < S - A && (F[d].textBlock.y = S - A), F[d].textBlock.y + F[d].height > ta + A && (F[d].textBlock.y = ta + A - F[d].height));\n      }\n\n      function h() {\n        var a, b, c, f;\n        if (\"inside\" !== s.indexLabelPlacement) for (var e = 0; e < R.length; e++) 0 == F[e].textBlock.text.length ? F[e].isDirty = !0 : (a = R[e], c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, b = s.reversed ? \"undefined\" !== typeof a.x5 ? c > V ? g(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : \"undefined\" !== typeof a.x5 ? c < V ? g(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, F[e].textBlock.x = b + W, F[e].textBlock.y = c - F[e].height / 2, s.reversed ? (F[e].textBlock.y + F[e].height > S + A && (F[e].textBlock.y = S + A - F[e].height), F[e].textBlock.y < ta - A && (F[e].textBlock.y = ta - A)) : (F[e].textBlock.y < S - A && (F[e].textBlock.y = S - A), F[e].textBlock.y + F[e].height > ta + A && (F[e].textBlock.y = ta + A - F[e].height)));else for (e = 0; e < R.length; e++) 0 == F[e].textBlock.text.length ? F[e].isDirty = !0 : (a = R[e], b = a.height, c = F[e].height, f = F[e].width, b >= c ? (b = e != da ? (a.x4 + a.x3) / 2 - f / 2 : (a.x5 + a.x4) / 2 - f / 2, c = e != da ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, F[e].textBlock.x = b, F[e].textBlock.y = c) : F[e].isDirty = !0);\n      }\n\n      function r() {\n        function a(b, c) {\n          var e;\n          if (0 > b || b >= F.length) return 0;\n          var f,\n              g = F[b].textBlock;\n\n          if (0 > c) {\n            c *= -1;\n            f = p(b);\n            e = d(f, b);\n            if (e >= c) return g.y -= c, c;\n            if (0 == b) return 0 < e && (g.y -= e), e;\n            e += a(f, -(c - e));\n            0 < e && (g.y -= e);\n            return e;\n          }\n\n          f = q(b);\n          e = d(b, f);\n          if (e >= c) return g.y += c, c;\n          if (b == R.length - 1) return 0 < e && (g.y += e), e;\n          e += a(f, c - e);\n          0 < e && (g.y += e);\n          return e;\n        }\n\n        function b() {\n          var a,\n              e,\n              f,\n              g,\n              h = 0,\n              r;\n          g = (O - Z + 2 * A) / l;\n          r = l;\n\n          for (var d, k = 1; k < r; k++) {\n            f = k * g;\n\n            for (var n = F.length - 1; 0 <= n; n--) !F[n].isDirty && F[n].textBlock.y < f && F[n].textBlock.y + F[n].height > f && (d = q(n), !(d >= F.length - 1) && F[n].textBlock.y + F[n].height + ea > F[d].textBlock.y && (F[n].textBlock.y = F[n].textBlock.y + F[n].height - f > f - F[n].textBlock.y ? f + 1 : f - F[n].height - 1));\n          }\n\n          for (d = R.length - 1; 0 < d; d--) if (!F[d].isDirty) {\n            f = p(d);\n            if (0 > f && (f = 0, F[f].isDirty)) break;\n\n            if (F[d].textBlock.y < F[f].textBlock.y + F[f].height) {\n              e = e || d;\n              g = d;\n\n              for (r = 0; F[g].textBlock.y < F[f].textBlock.y + F[f].height + ea;) {\n                a = a || F[g].textBlock.y + F[g].height;\n                r += F[g].height;\n                r += ea;\n                g = f;\n\n                if (0 >= g) {\n                  g = 0;\n                  r += F[g].height;\n                  break;\n                }\n\n                f = p(g);\n\n                if (0 > f) {\n                  g = 0;\n                  r += F[g].height;\n                  break;\n                }\n              }\n\n              if (g != d) {\n                h = F[g].textBlock.y;\n                a -= h;\n                a = r - a;\n                h = c(a, e, g);\n                break;\n              }\n            }\n          }\n\n          return h;\n        }\n\n        function c(a, b, e) {\n          var f = [],\n              g = 0,\n              h = 0;\n\n          for (a = Math.abs(a); e <= b; e++) f.push(R[e]);\n\n          f.sort(function (a, b) {\n            return a.height - b.height;\n          });\n\n          for (e = 0; e < f.length; e++) if (b = f[e], g < a) h++, g += F[b.id].height + ea, F[b.id].textBlock.text = \"\", F[b.id].indexLabelText = \"\", F[b.id].isDirty = !0, F[b.id].textBlock.measureText();else break;\n\n          return h;\n        }\n\n        for (var e, f, g, h, r, k, l = 1, n = 0; n < 2 * l; n++) {\n          for (var m = F.length - 1; 0 <= m && !(0 <= p(m) && p(m), g = F[m], h = g.textBlock, k = (r = q(m) < R.length ? F[q(m)] : null) ? r.textBlock : null, e = +g.height.toFixed(6), f = +h.y.toFixed(6), !g.isDirty && r && f + e + ea > +k.y.toFixed(6) && (e = h.y + e + ea - k.y, f = a(m, -e), f < e && (0 < f && (e -= f), f = a(q(m), e), f != e))); m--);\n\n          b();\n        }\n      }\n\n      function d(a, b) {\n        return (b < R.length ? F[b].textBlock.y : s.reversed ? S + A : ta + A) - (0 > a ? s.reversed ? ta - A : S - A : F[a].textBlock.y + F[a].height + ea);\n      }\n\n      function m(a, b, c) {\n        var e,\n            f,\n            g,\n            r = [],\n            d = A,\n            p = [];\n        -1 !== b && (0 <= $.indexOf(b) ? (f = $.indexOf(b), $.splice(f, 1)) : ($.push(b), $ = $.sort(function (a, b) {\n          return a - b;\n        })));\n        if (0 === $.length) r = ia;else {\n          f = A * (1 != $.length || 0 != $[0] && $[0] != R.length - 1 ? 2 : 1) / k();\n\n          for (var q = 0; q < R.length; q++) {\n            if (1 == $.length && 0 == $[0]) {\n              if (0 === q) {\n                r.push(ia[q]);\n                e = d;\n                continue;\n              }\n            } else 0 === q && (e = -1 * d);\n\n            r.push(ia[q] + e);\n            if (0 <= $.indexOf(q) || q < R.length && 0 <= $.indexOf(q + 1)) e += f;\n          }\n        }\n\n        g = function () {\n          for (var a = [], b = 0; b < R.length; b++) a.push(r[b] - R[b].y1);\n\n          return a;\n        }();\n\n        var n = {\n          startTime: new Date().getTime(),\n          duration: c || 500,\n          easingFunction: function (a, b, c, e) {\n            return K.easing.easeOutQuart(a, b, c, e);\n          },\n          changeSection: function (a) {\n            for (var b, c, e = 0; e < R.length; e++) b = g[e], c = R[e], b *= a, \"undefined\" === typeof p[e] && (p[e] = 0), 0 > p && (p *= -1), c.y1 += b - p[e], c.y2 += b - p[e], c.y3 += b - p[e], c.y4 += b - p[e], c.y5 && (c.y5 += b - p[e], c.y6 += b - p[e]), p[e] = b;\n          }\n        };\n\n        a._animator.animate(0, c, function (c) {\n          var e = a.plotArea.ctx || a.ctx;\n          ha = !0;\n          e.clearRect(u.x1, u.y1, u.x2 - u.x1, u.y2 - u.y1);\n          e.fillStyle = a.backgroundColor;\n          e.fillRect(u.x1, u.y1, u.width, u.height);\n          n.changeSection(c, b);\n          var f = {};\n          f.dataSeries = s;\n          f.dataPoint = s.reversed ? s.dataPoints[z.length - 1 - b] : s.dataPoints[b];\n          f.index = s.reversed ? z.length - 1 - b : b;\n          a.toolTip.highlightObjects([f]);\n\n          for (f = 0; f < R.length; f++) qa(e, R[f], s.fillOpacity);\n\n          w(e);\n          J && (\"inside\" !== s.indexLabelPlacement ? l(e) : h(), t(e));\n          1 <= c && (ha = !1);\n        }, null, K.easing.easeOutQuart);\n      }\n\n      function k() {\n        for (var a = 0, b = 0; b < R.length - 1; b++) (0 <= $.indexOf(b) || 0 <= $.indexOf(b + 1)) && a++;\n\n        return a;\n      }\n\n      function l(a) {\n        for (var b, c, e, f, h = 0; h < R.length; h++) f = 1 === F[h].lineThickness % 2 ? 0.5 : 0, c = ((R[h].y2 + R[h].y4) / 2 << 0) + f, b = g(c).x2 - 1, e = F[h].textBlock.x, f = (F[h].textBlock.y + F[h].height / 2 << 0) + f, F[h].isDirty || 0 == F[h].lineThickness || (a.strokeStyle = F[h].lineColor, a.lineWidth = F[h].lineThickness, a.setLineDash && a.setLineDash(G(F[h].lineDashType, F[h].lineThickness)), a.beginPath(), a.moveTo(b, c), a.lineTo(e, f), a.stroke());\n      }\n\n      function p(a) {\n        for (a -= 1; -1 <= a && -1 != a && F[a].isDirty; a--);\n\n        return a;\n      }\n\n      function q(a) {\n        for (a += 1; a <= R.length && a != R.length && F[a].isDirty; a++);\n\n        return a;\n      }\n\n      function g(a) {\n        for (var b, c = 0; c < z.length; c++) if (R[c].y1 < a && R[c].y4 > a) {\n          b = R[c];\n          break;\n        }\n\n        return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2), {\n          x1: a,\n          x2: a\n        }) : -1;\n      }\n\n      function t(a) {\n        for (var b = 0; b < R.length; b++) F[b].isDirty || (a && (F[b].textBlock.ctx = a), F[b].textBlock.y += F[b].textBlock._lineHeight / 2, F[b].textBlock.render(!0), F[b].textBlock.y -= F[b].textBlock._lineHeight / 2);\n      }\n\n      function w(a) {\n        x.plotArea.layoutManager.reset();\n        a.roundRect || za(a);\n        x.title && (x.title.dockInsidePlotArea || \"center\" === x.title.horizontalAlign && \"center\" === x.title.verticalAlign) && (x.title.ctx = a, x.title.render());\n        if (x.subtitles) for (var b = 0; b < x.subtitles.length; b++) {\n          var c = x.subtitles[b];\n          if (c.dockInsidePlotArea || \"center\" === c.horizontalAlign && \"center\" === c.verticalAlign) x.subtitles.ctx = a, c.render();\n        }\n        x.legend && (x.legend.dockInsidePlotArea || \"center\" === x.legend.horizontalAlign && \"center\" === x.legend.verticalAlign) && (x.legend.ctx = a, x.legend.setLayout(), x.legend.render());\n        va.fNg && va.fNg(x);\n      }\n\n      var x = this;\n\n      if (!(0 >= a.dataSeriesIndexes.length)) {\n        for (var s = this.data[a.dataSeriesIndexes[0]], z = s.dataPoints, u = this.plotArea, A = 0.025 * u.width, B = 0.01 * u.width, C = 0, H = u.height - 2 * A, L = Math.min(u.width - 2 * B, 2.8 * u.height), J = !1, T = 0; T < z.length; T++) if (!J && \"undefined\" !== typeof z[T].indexLabel && null !== z[T].indexLabel && 0 < z[T].indexLabel.toString().length && (J = !0), !J && \"undefined\" !== typeof z[T].label && null !== z[T].label && 0 < z[T].label.toString().length && (J = !0), !J && \"function\" === typeof s.indexLabelFormatter || \"function\" === typeof z[T].indexLabelFormatter) J = !0;\n\n        J = J || \"undefined\" !== typeof s.indexLabel && null !== s.indexLabel && 0 < s.indexLabel.toString().length;\n        \"inside\" !== s.indexLabelPlacement && J || (B = (u.width - 0.75 * L) / 2);\n        var T = u.x1 + B,\n            Q = u.x2 - B,\n            Z = u.y1 + A,\n            O = u.y2 - A,\n            P = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;\n\n        if (0 != s.length && s.dataPoints && s.visible && 0 !== z.length) {\n          var N, E;\n          a = 75 * L / 100;\n          var W = 30 * (Q - a) / 100;\n          \"funnel\" === s.type ? (N = n(s.options.neckHeight) ? 0.35 * H : s.neckHeight, E = n(s.options.neckWidth) ? 0.25 * a : s.neckWidth, \"string\" === typeof N && N.match(/%$/) ? (N = parseInt(N), N = N * H / 100) : N = parseInt(N), \"string\" === typeof E && E.match(/%$/) ? (E = parseInt(E), E = E * a / 100) : E = parseInt(E), N > H ? N = H : 0 >= N && (N = 0), E > a ? E = a - 0.5 : 0 >= E && (E = 0)) : \"pyramid\" === s.type && (E = N = 0, s.reversed = s.reversed ? !1 : !0);\n          var B = T + a / 2,\n              U = T,\n              X = T + a,\n              S = s.reversed ? O : Z,\n              M = B - E / 2,\n              Y = B + E / 2,\n              V = s.reversed ? Z + N : O - N,\n              ta = s.reversed ? Z : O;\n          E = s.valueRepresents = s.valueRepresents ? s.valueRepresents : \"height\";\n          T = [];\n          a = [];\n          var R = [],\n              B = [],\n              aa = Z,\n              da,\n              ca = (V - S) / (M - U),\n              fa = -ca,\n              L = \"area\" === E ? c() : e();\n\n          if (-1 !== L) {\n            if (s.reversed) for (B.push(aa), E = L.length - 1; 0 < E; E--) aa += L[E], B.push(aa);else for (E = 0; E < L.length; E++) aa += L[E], B.push(aa);\n            if (s.reversed) for (E = 0; E < L.length; E++) B[E] < V ? (T.push(M), a.push(Y), da = E) : (T.push((B[E] - S + ca * U) / ca), a.push((B[E] - S + fa * X) / fa));else for (E = 0; E < L.length; E++) B[E] < V ? (T.push((B[E] - S + ca * U) / ca), a.push((B[E] - S + fa * X) / fa), da = E) : (T.push(M), a.push(Y));\n\n            for (E = 0; E < L.length - 1; E++) aa = s.reversed ? z[z.length - 1 - E].color ? z[z.length - 1 - E].color : s._colorSet[(z.length - 1 - E) % s._colorSet.length] : z[E].color ? z[E].color : s._colorSet[E % s._colorSet.length], E === da ? R.push({\n              x1: T[E],\n              y1: B[E],\n              x2: a[E],\n              y2: B[E],\n              x3: Y,\n              y3: V,\n              x4: a[E + 1],\n              y4: B[E + 1],\n              x5: T[E + 1],\n              y5: B[E + 1],\n              x6: M,\n              y6: V,\n              id: E,\n              height: B[E + 1] - B[E],\n              color: aa\n            }) : R.push({\n              x1: T[E],\n              y1: B[E],\n              x2: a[E],\n              y2: B[E],\n              x3: a[E + 1],\n              y3: B[E + 1],\n              x4: T[E + 1],\n              y4: B[E + 1],\n              id: E,\n              height: B[E + 1] - B[E],\n              color: aa\n            });\n\n            var ea = 2,\n                F = [],\n                ha = !1,\n                $ = [],\n                ia = [],\n                T = !1;\n            a = a = 0;\n            Da($);\n\n            for (E = 0; E < z.length; E++) z[E].exploded && (T = !0, s.reversed ? $.push(z.length - 1 - E) : $.push(E));\n\n            P.clearRect(u.x1, u.y1, u.width, u.height);\n            P.fillStyle = x.backgroundColor;\n            P.fillRect(u.x1, u.y1, u.width, u.height);\n\n            if (J && s.visible && (b(), h(), \"inside\" !== s.indexLabelPlacement)) {\n              f();\n              r();\n\n              for (E = 0; E < z.length; E++) F[E].isDirty || (a = F[E].textBlock.x + F[E].width, a = (Q - a) / 2, 0 == E && (C = a), C > a && (C = a));\n\n              for (E = 0; E < R.length; E++) R[E].x1 += C, R[E].x2 += C, R[E].x3 += C, R[E].x4 += C, R[E].x5 && (R[E].x5 += C, R[E].x6 += C), F[E].textBlock.x += C;\n            }\n\n            for (E = 0; E < R.length; E++) C = R[E], qa(P, C, s.fillOpacity), ia.push(C.y1);\n\n            w(P);\n            J && s.visible && (\"inside\" === s.indexLabelPlacement || x.animationEnabled || l(P), x.animationEnabled || t());\n            if (!J) for (E = 0; E < z.length; E++) C = s.dataPointIds[E], a = {\n              id: C,\n              objectType: \"dataPoint\",\n              dataPointIndex: E,\n              dataSeriesIndex: 0,\n              funnelSection: R[s.reversed ? z.length - 1 - E : E]\n            }, x._eventManager.objectMap[C] = a;\n            !x.animationEnabled && T ? m(x, -1, 0) : x.animationEnabled && !x.animatedRender && m(x, -1, 0);\n\n            this.funnelPyramidClickHandler = function (a) {\n              var b = -1;\n\n              if (!ha && !x.isAnimating && (n(a.dataSeries.explodeOnClick) || a.dataSeries.explodeOnClick) && (b = s.reversed ? z.length - 1 - a.dataPointIndex : a.dataPointIndex, 0 <= b)) {\n                a = b;\n                if (\"funnel\" === s.type || \"pyramid\" === s.type) s.reversed ? z[z.length - 1 - a].exploded = z[z.length - 1 - a].exploded ? !1 : !0 : z[a].exploded = z[a].exploded ? !1 : !0;\n                m(x, b, 500);\n              }\n            };\n\n            return {\n              source: P,\n              dest: this.plotArea.ctx,\n              animationCallback: function (a, b) {\n                K.fadeInAnimation(a, b);\n                1 <= a && (m(x, -1, 500), w(x.plotArea.ctx || x.ctx));\n              },\n              easingFunction: K.easing.easeInQuad,\n              animationBase: 0\n            };\n          }\n        }\n      }\n    };\n\n    m.prototype.requestAnimFrame = function () {\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) {\n        window.setTimeout(a, 1E3 / 60);\n      };\n    }();\n\n    m.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;\n\n    m.prototype.set = function (a, e, c) {\n      c = \"undefined\" === typeof c ? !0 : c;\n      \"options\" === a ? (this.options = e, c && this.render()) : m.base.set.call(this, a, e, c);\n    };\n\n    m.prototype.exportChart = function (a) {\n      a = \"undefined\" === typeof a ? {} : a;\n      var e = a.format ? a.format : \"png\",\n          c = a.fileName ? a.fileName : this.exportFileName;\n      if (a.toDataURL) return this.canvas.toDataURL(\"image/\" + e);\n      var b = this.canvas;\n\n      if (b && e && c) {\n        c = c + \".\" + e;\n        a = \"image/\" + e;\n        var b = b.toDataURL(a),\n            f = !1,\n            h = document.createElement(\"a\");\n        h.download = c;\n        h.href = b;\n\n        if (\"undefined\" !== typeof Blob && new Blob()) {\n          for (var r = b.replace(/^data:[a-z\\/]*;base64,/, \"\"), r = atob(r), d = new ArrayBuffer(r.length), d = new Uint8Array(d), n = 0; n < r.length; n++) d[n] = r.charCodeAt(n);\n\n          e = new Blob([d.buffer], {\n            type: \"image/\" + e\n          });\n\n          try {\n            window.navigator.msSaveBlob(e, c), f = !0;\n          } catch (k) {\n            h.dataset.downloadurl = [a, h.download, h.href].join(\":\"), h.href = window.URL.createObjectURL(e);\n          }\n        }\n\n        if (!f) try {\n          event = document.createEvent(\"MouseEvents\"), event.initMouseEvent(\"click\", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), h.dispatchEvent ? h.dispatchEvent(event) : h.fireEvent && h.fireEvent(\"onclick\");\n        } catch (l) {\n          e = window.open(), e.document.write(\"<img src='\" + b + \"'></img><div>Please right click on the image and save it to your device</div>\"), e.document.close();\n        }\n      }\n    };\n\n    m.prototype.print = function () {\n      var a = this.exportChart({\n        toDataURL: !0\n      }),\n          e = document.createElement(\"iframe\");\n      e.setAttribute(\"class\", \"canvasjs-chart-print-frame\");\n      O(e, {\n        position: \"absolute\",\n        width: \"100%\",\n        border: \"0px\",\n        margin: \"0px 0px 0px 0px\",\n        padding: \"0px 0px 0px 0px\"\n      });\n      e.style.height = this.height + \"px\";\n\n      this._canvasJSContainer.appendChild(e);\n\n      var c = this,\n          b = e.contentWindow || e.contentDocument.document || e.contentDocument;\n      b.document.open();\n      b.document.write('<!DOCTYPE HTML>\\n<html><body><img src=\"' + a + '\"/><body/></html>');\n      b.document.body && b.document.body.style && (b.document.body.style.margin = \"0px 0px 0px 0px\", b.document.body.style.padding = \"0px 0px 0px 0px\");\n      b.document.close();\n      setTimeout(function () {\n        b.focus();\n        b.print();\n        setTimeout(function () {\n          c._canvasJSContainer.removeChild(e);\n        }, 1E3);\n      }, 500);\n    };\n\n    m.prototype.getPercentAndTotal = function (a, e) {\n      var c = null,\n          b = null,\n          f = c = null;\n      if (0 <= a.type.indexOf(\"stacked\")) b = 0, c = e.x.getTime ? e.x.getTime() : e.x, c in a.plotUnit.yTotals && (b = a.plotUnit.yTotals[c], c = a.plotUnit.yAbsTotals[c], f = isNaN(e.y) ? 0 : 0 === c ? 0 : 100 * (e.y / c));else if (\"pie\" === a.type || \"doughnut\" === a.type || \"funnel\" === a.type || \"pyramid\" === a.type) {\n        for (c = b = 0; c < a.dataPoints.length; c++) isNaN(a.dataPoints[c].y) || (b += a.dataPoints[c].y);\n\n        f = isNaN(e.y) ? 0 : 100 * (e.y / b);\n      }\n      return {\n        percent: f,\n        total: b\n      };\n    };\n\n    m.prototype.replaceKeywordsWithValue = function (a, e, c, b, f) {\n      var h = this;\n      f = \"undefined\" === typeof f ? 0 : f;\n\n      if ((0 <= c.type.indexOf(\"stacked\") || \"pie\" === c.type || \"doughnut\" === c.type || \"funnel\" === c.type || \"pyramid\" === c.type) && (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"))) {\n        var r = \"#percent\",\n            d = \"#total\",\n            n = this.getPercentAndTotal(c, e),\n            d = isNaN(n.total) ? d : n.total,\n            r = isNaN(n.percent) ? r : n.percent;\n\n        do {\n          n = \"\";\n          if (c.percentFormatString) n = c.percentFormatString;else {\n            var n = \"#,##0.\",\n                k = Math.max(Math.ceil(Math.log(1 / Math.abs(r)) / Math.LN10), 2);\n            if (isNaN(k) || !isFinite(k)) k = 2;\n\n            for (var l = 0; l < k; l++) n += \"#\";\n\n            c.percentFormatString = n;\n          }\n          a = a.replace(\"#percent\", fa(r, n, h._cultureInfo));\n          a = a.replace(\"#total\", fa(d, c.yValueFormatString ? c.yValueFormatString : \"#,##0.########\", h._cultureInfo));\n        } while (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"));\n      }\n\n      return a.replace(/\\{.*?\\}|\"[^\"]*\"|'[^']*'/g, function (a) {\n        if ('\"' === a[0] && '\"' === a[a.length - 1] || \"'\" === a[0] && \"'\" === a[a.length - 1]) return a.slice(1, a.length - 1);\n        a = Ga(a.slice(1, a.length - 1));\n        a = a.replace(\"#index\", f);\n        var r = null;\n\n        try {\n          var g = a.match(/(.*?)\\s*\\[\\s*(.*?)\\s*\\]/);\n          g && 0 < g.length && (r = Ga(g[2]), a = Ga(g[1]));\n        } catch (d) {}\n\n        g = null;\n        if (\"color\" === a) return \"waterfall\" === c.type ? e.color ? e.color : 0 < e.y ? c.risingColor : c.fallingColor : \"error\" === c.type ? c.color ? c.color : c._colorSet[r % c._colorSet.length] : e.color ? e.color : c.color ? c.color : c._colorSet[b % c._colorSet.length];\n        if (e.hasOwnProperty(a)) g = e;else if (c.hasOwnProperty(a)) g = c;else return \"\";\n        g = g[a];\n        null !== r && (g = g[r]);\n        return \"x\" === a ? (c.axisX && \"dateTime\" === c.axisX.valueType || \"dateTime\" === c.xValueType || e.x && e.x.getTime) && !c.axisX.logarithmic ? Ca(g, e.xValueFormatString ? e.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : c.xValueFormatString = h.axisX && h.axisX.autoValueFormatString ? h.axisX.autoValueFormatString : \"DD MMM YY\", h._cultureInfo) : fa(g, e.xValueFormatString ? e.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : c.xValueFormatString = \"#,##0.########\", h._cultureInfo) : \"y\" === a ? fa(g, e.yValueFormatString ? e.yValueFormatString : c.yValueFormatString ? c.yValueFormatString : c.yValueFormatString = \"#,##0.########\", h._cultureInfo) : \"z\" === a ? fa(g, e.zValueFormatString ? e.zValueFormatString : c.zValueFormatString ? c.zValueFormatString : c.zValueFormatString = \"#,##0.########\", h._cultureInfo) : g;\n      });\n    };\n\n    pa(P, X);\n\n    P.prototype.setLayout = function () {\n      var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,\n          e = a.layoutManager.getFreeSpace(),\n          c = null,\n          b = 0,\n          f = 0,\n          h = 0,\n          r = 0,\n          d = this.markerMargin = this.chart.options.legend && !n(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;\n      this.height = 0;\n      var m = [],\n          k = [];\n      if (\"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign) this.orientation = \"horizontal\", c = this.verticalAlign, h = this.maxWidth = null !== this.maxWidth ? this.maxWidth : e.width, r = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * e.height;else if (\"center\" === this.verticalAlign) {\n        this.orientation = \"vertical\";\n        if (\"left\" === this.horizontalAlign || \"center\" === this.horizontalAlign || \"right\" === this.horizontalAlign) c = this.horizontalAlign;\n        h = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * e.width;\n        r = this.maxHeight = null !== this.maxHeight ? this.maxHeight : e.height;\n      }\n      this.errorMarkerColor = [];\n\n      for (var l = 0; l < this.dataSeries.length; l++) {\n        var p = this.dataSeries[l];\n\n        if (p.dataPoints && p.dataPoints.length) {\n          if (\"pie\" !== p.type && \"doughnut\" !== p.type && \"funnel\" !== p.type && \"pyramid\" !== p.type) {\n            var q = p.legendMarkerType = p.legendMarkerType ? p.legendMarkerType : \"line\" !== p.type && \"stepLine\" !== p.type && \"spline\" !== p.type && \"scatter\" !== p.type && \"bubble\" !== p.type || !p.markerType ? \"error\" === p.type && p._linkedSeries ? p._linkedSeries.legendMarkerType ? p._linkedSeries.legendMarkerType : U.getDefaultLegendMarker(p._linkedSeries.type) : U.getDefaultLegendMarker(p.type) : p.markerType,\n                g = p.legendText ? p.legendText : this.itemTextFormatter ? this.itemTextFormatter({\n              chart: this.chart,\n              legend: this.options,\n              dataSeries: p,\n              dataPoint: null\n            }) : p.name,\n                v = p.legendMarkerColor = p.legendMarkerColor ? p.legendMarkerColor : p.markerColor ? p.markerColor : \"error\" === p.type ? n(p.whiskerColor) ? p._colorSet[0] : p.whiskerColor : p._colorSet[0],\n                w = p.markerSize || \"line\" !== p.type && \"stepLine\" !== p.type && \"spline\" !== p.type ? 0.75 * this.lineHeight : 0,\n                x = p.legendMarkerBorderColor ? p.legendMarkerBorderColor : p.markerBorderColor,\n                s = p.legendMarkerBorderThickness ? p.legendMarkerBorderThickness : p.markerBorderThickness ? Math.max(1, Math.round(0.2 * w)) : 0;\n            \"error\" === p.type && this.errorMarkerColor.push(v);\n            g = p.legendText = this.chart.replaceKeywordsWithValue(g, p.dataPoints[0], p, l);\n            q = {\n              markerType: q,\n              markerColor: v,\n              text: g,\n              textBlock: null,\n              chartType: p.type,\n              markerSize: w,\n              lineColor: p._colorSet[0],\n              dataSeriesIndex: p.index,\n              dataPointIndex: null,\n              markerBorderColor: x,\n              markerBorderThickness: s\n            };\n            m.push(q);\n          } else for (var z = 0; z < p.dataPoints.length; z++) {\n            var u = p.dataPoints[z],\n                q = u.legendMarkerType ? u.legendMarkerType : p.legendMarkerType ? p.legendMarkerType : U.getDefaultLegendMarker(p.type),\n                g = u.legendText ? u.legendText : p.legendText ? p.legendText : this.itemTextFormatter ? this.itemTextFormatter({\n              chart: this.chart,\n              legend: this.options,\n              dataSeries: p,\n              dataPoint: u\n            }) : u.name ? u.name : \"DataPoint: \" + (z + 1),\n                v = u.legendMarkerColor ? u.legendMarkerColor : p.legendMarkerColor ? p.legendMarkerColor : u.color ? u.color : p.color ? p.color : p._colorSet[z % p._colorSet.length],\n                w = 0.75 * this.lineHeight,\n                x = u.legendMarkerBorderColor ? u.legendMarkerBorderColor : p.legendMarkerBorderColor ? p.legendMarkerBorderColor : u.markerBorderColor ? u.markerBorderColor : p.markerBorderColor,\n                s = u.legendMarkerBorderThickness ? u.legendMarkerBorderThickness : p.legendMarkerBorderThickness ? p.legendMarkerBorderThickness : u.markerBorderThickness || p.markerBorderThickness ? Math.max(1, Math.round(0.2 * w)) : 0,\n                g = this.chart.replaceKeywordsWithValue(g, u, p, z),\n                q = {\n              markerType: q,\n              markerColor: v,\n              text: g,\n              textBlock: null,\n              chartType: p.type,\n              markerSize: w,\n              dataSeriesIndex: l,\n              dataPointIndex: z,\n              markerBorderColor: x,\n              markerBorderThickness: s\n            };\n            (u.showInLegend || p.showInLegend && !1 !== u.showInLegend) && m.push(q);\n          }\n\n          n(p.legendText) && (p.legendText = p.name);\n        }\n      }\n\n      !0 === this.reversed && m.reverse();\n\n      if (0 < m.length) {\n        p = null;\n        g = u = z = 0;\n        u = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, h) : this.itemMaxWidth = Math.min(this.itemWidth, h) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, h) : this.itemMaxWidth = h;\n        w = 0 === w ? 0.75 * this.lineHeight : w;\n        u = (this.itemMaxWidth ? this.itemMaxWidth : u) - (w + d);\n\n        for (l = 0; l < m.length; l++) {\n          q = m[l];\n          v = u;\n          if (\"line\" === q.chartType || \"spline\" === q.chartType || \"stepLine\" === q.chartType) v -= 2 * 0.1 * this.lineHeight;\n          if (!(0 >= r || \"undefined\" === typeof r || 0 >= v || \"undefined\" === typeof v)) if (\"horizontal\" === this.orientation) {\n            q.textBlock = new ja(this.ctx, {\n              x: 0,\n              y: 0,\n              maxWidth: v,\n              maxHeight: this.itemWrap ? r : this.lineHeight,\n              angle: 0,\n              text: q.text,\n              textAlign: \"left\",\n              fontSize: this.fontSize,\n              fontFamily: this.fontFamily,\n              fontWeight: this.fontWeight,\n              fontColor: this.fontColor,\n              fontStyle: this.fontStyle,\n              textBaseline: \"middle\"\n            });\n            q.textBlock.measureText();\n            null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (w + d + (\"line\" === q.chartType || \"spline\" === q.chartType || \"stepLine\" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)));\n            if (!p || p.width + Math.round(q.textBlock.width + w + d + (0 === p.width ? 0 : this.horizontalSpacing) + (\"line\" === q.chartType || \"spline\" === q.chartType || \"stepLine\" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)) > h) p = {\n              items: [],\n              width: 0\n            }, k.push(p), this.height += g, g = 0;\n            g = Math.max(g, q.textBlock.height ? q.textBlock.height : this.lineHeight);\n            q.textBlock.x = p.width;\n            q.textBlock.y = 0;\n            p.width += Math.round(q.textBlock.width + w + d + (0 === p.width ? 0 : this.horizontalSpacing) + (\"line\" === q.chartType || \"spline\" === q.chartType || \"stepLine\" === q.chartType ? 2 * 0.1 * this.lineHeight : 0));\n            p.items.push(q);\n            this.width = Math.max(p.width, this.width);\n          } else q.textBlock = new ja(this.ctx, {\n            x: 0,\n            y: 0,\n            maxWidth: u,\n            maxHeight: !0 === this.itemWrap ? r : 1.5 * this.fontSize,\n            angle: 0,\n            text: q.text,\n            textAlign: \"left\",\n            fontSize: this.fontSize,\n            fontFamily: this.fontFamily,\n            fontWeight: this.fontWeight,\n            fontColor: this.fontColor,\n            fontStyle: this.fontStyle,\n            textBaseline: \"middle\"\n          }), q.textBlock.measureText(), null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (w + d + (\"line\" === q.chartType || \"spline\" === q.chartType || \"stepLine\" === q.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < r - this.lineHeight ? (p = {\n            items: [],\n            width: 0\n          }, k.push(p)) : (p = k[z], z = (z + 1) % k.length), p && (this.height += q.textBlock.height ? q.textBlock.height : this.lineHeight, q.textBlock.x = p.width, q.textBlock.y = 0, p.width += Math.round(q.textBlock.width + w + d + (0 === p.width ? 0 : this.horizontalSpacing) + (\"line\" === q.chartType || \"spline\" === q.chartType || \"stepLine\" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)), p.items.push(q), this.width = Math.max(p.width, this.width));\n        }\n\n        this.height = !1 === this.itemWrap ? k.length * this.lineHeight : this.height + g;\n        this.height = Math.min(r, this.height);\n        this.width = Math.min(h, this.width);\n      }\n\n      \"top\" === this.verticalAlign ? (f = \"left\" === this.horizontalAlign ? e.x1 : \"right\" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, b = e.y1) : \"center\" === this.verticalAlign ? (f = \"left\" === this.horizontalAlign ? e.x1 : \"right\" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, b = e.y1 + e.height / 2 - this.height / 2) : \"bottom\" === this.verticalAlign && (f = \"left\" === this.horizontalAlign ? e.x1 : \"right\" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, b = e.y2 - this.height);\n      this.items = m;\n\n      for (l = 0; l < this.items.length; l++) q = m[l], q.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[q.id] = {\n        id: q.id,\n        objectType: \"legendItem\",\n        legendItemIndex: l,\n        dataSeriesIndex: q.dataSeriesIndex,\n        dataPointIndex: q.dataPointIndex\n      };\n\n      this.markerSize = w;\n      this.rows = k;\n      0 < m.length && a.layoutManager.registerSpace(c, {\n        width: this.width + 2 + 2,\n        height: this.height + 5 + 5\n      });\n      this.bounds = {\n        x1: f,\n        y1: b,\n        x2: f + this.width,\n        y2: b + this.height\n      };\n    };\n\n    P.prototype.render = function () {\n      var a = this.bounds.x1,\n          e = this.bounds.y1,\n          c = this.markerMargin,\n          b = this.maxWidth,\n          f = this.maxHeight,\n          h = this.markerSize,\n          r = this.rows;\n      (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, e, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);\n\n      for (var d = 0, n = 0; n < r.length; n++) {\n        for (var k = r[n], l = 0, p = 0; p < k.items.length; p++) {\n          var q = k.items[p],\n              g = q.textBlock.x + a + (0 === p ? 0.2 * h : this.horizontalSpacing),\n              m = e + d,\n              w = g;\n          this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);\n          this.ctx.save();\n          this.ctx.beginPath();\n          this.ctx.rect(a, e, b, Math.max(f - f % this.lineHeight, 0));\n          this.ctx.clip();\n          if (\"line\" === q.chartType || \"stepLine\" === q.chartType || \"spline\" === q.chartType) this.ctx.strokeStyle = q.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(g - 0.1 * this.lineHeight, m + this.lineHeight / 2), this.ctx.lineTo(g + 0.85 * this.lineHeight, m + this.lineHeight / 2), this.ctx.stroke(), w -= 0.1 * this.lineHeight;\n\n          if (\"error\" === q.chartType) {\n            this.ctx.strokeStyle = this.errorMarkerColor[0];\n            this.ctx.lineWidth = h / 8;\n            this.ctx.beginPath();\n            var v = g - 0.08 * this.lineHeight + 0.1 * this.lineHeight,\n                s = m + 0.15 * this.lineHeight,\n                z = 0.7 * this.lineHeight,\n                u = z + 0.02 * this.lineHeight;\n            this.ctx.moveTo(v, s);\n            this.ctx.lineTo(v + z, s);\n            this.ctx.stroke();\n            this.ctx.beginPath();\n            this.ctx.moveTo(v + z / 2, s);\n            this.ctx.lineTo(v + z / 2, s + u);\n            this.ctx.stroke();\n            this.ctx.beginPath();\n            this.ctx.moveTo(v, s + u);\n            this.ctx.lineTo(v + z, s + u);\n            this.ctx.stroke();\n            this.errorMarkerColor.shift();\n          }\n\n          V.drawMarker(g + h / 2, m + this.lineHeight / 2, this.ctx, q.markerType, \"error\" === q.chartType || \"line\" === q.chartType || \"spline\" === q.chartType ? q.markerSize / 2 : q.markerSize, q.markerColor, q.markerBorderColor, q.markerBorderThickness);\n          q.textBlock.x = g + c + h;\n          if (\"line\" === q.chartType || \"stepLine\" === q.chartType || \"spline\" === q.chartType) q.textBlock.x += 0.1 * this.lineHeight;\n          q.textBlock.y = Math.round(m + this.lineHeight / 2);\n          q.textBlock.render(!0);\n          this.ctx.restore();\n          l = 0 < p ? Math.max(l, q.textBlock.height ? q.textBlock.height : this.lineHeight) : q.textBlock.height ? q.textBlock.height : this.lineHeight;\n          this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);\n          g = W(q.id);\n          this.ghostCtx.fillStyle = g;\n          this.ghostCtx.beginPath();\n          this.ghostCtx.fillRect(w, q.textBlock.y - this.lineHeight / 2, q.textBlock.x + q.textBlock.width - w, q.textBlock.height ? q.textBlock.height : this.lineHeight);\n          q.x1 = this.chart._eventManager.objectMap[q.id].x1 = w;\n          q.y1 = this.chart._eventManager.objectMap[q.id].y1 = q.textBlock.y - this.lineHeight / 2;\n          q.x2 = this.chart._eventManager.objectMap[q.id].x2 = q.textBlock.x + q.textBlock.width;\n          q.y2 = this.chart._eventManager.objectMap[q.id].y2 = q.textBlock.y + (q.textBlock.height ? q.textBlock.height : this.lineHeight) - this.lineHeight / 2;\n        }\n\n        d += l;\n      }\n    };\n\n    pa(U, X);\n\n    U.prototype.getDefaultAxisPlacement = function () {\n      var a = this.type;\n      if (\"column\" === a || \"line\" === a || \"stepLine\" === a || \"spline\" === a || \"area\" === a || \"stepArea\" === a || \"splineArea\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedArea\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stackedArea100\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a) return \"normal\";\n      if (\"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"rangeBar\" === a) return \"xySwapped\";\n      if (\"pie\" === a || \"doughnut\" === a || \"funnel\" === a || \"pyramid\" === a) return \"none\";\n      \"error\" !== a && window.console.log(\"Unknown Chart Type: \" + a);\n      return null;\n    };\n\n    U.getDefaultLegendMarker = function (a) {\n      if (\"column\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stepArea\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeBar\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a) return \"square\";\n      if (\"line\" === a || \"stepLine\" === a || \"spline\" === a || \"pie\" === a || \"doughnut\" === a) return \"circle\";\n      if (\"area\" === a || \"splineArea\" === a || \"stackedArea\" === a || \"stackedArea100\" === a || \"funnel\" === a || \"pyramid\" === a) return \"triangle\";\n      if (\"error\" === a) return \"none\";\n      window.console.log(\"Unknown Chart Type: \" + a);\n      return null;\n    };\n\n    U.prototype.getDataPointAtX = function (a, e) {\n      if (!this.dataPoints || 0 === this.dataPoints.length) return null;\n      var c = {\n        dataPoint: null,\n        distance: Infinity,\n        index: NaN\n      },\n          b = null,\n          f = 0,\n          h = 0,\n          d = 1,\n          n = Infinity,\n          m = 0,\n          k = 0,\n          l = 0;\n      \"none\" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (l = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), l = 1 < l ? Math.min(Math.max((this.dataPoints.length - 1) / l * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (l = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, l = 0 < l ? Math.min(Math.max((this.dataPoints.length - 1) / l * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));\n\n      for (;;) {\n        h = 0 < d ? l + f : l - f;\n\n        if (0 <= h && h < this.dataPoints.length) {\n          var b = this.dataPoints[h],\n              p = this.axisX.logarithmic ? b.x > a ? b.x / a : a / b.x : Math.abs(b.x - a);\n          p < c.distance && (c.dataPoint = b, c.distance = p, c.index = h);\n          b = p;\n          b <= n ? n = b : 0 < d ? m++ : k++;\n          if (1E3 < m && 1E3 < k) break;\n        } else if (0 > l - f && l + f >= this.dataPoints.length) break;\n\n        -1 === d ? (f++, d = 1) : d = -1;\n      }\n\n      return e || (c.dataPoint.x.getTime ? c.dataPoint.x.getTime() : c.dataPoint.x) !== (a.getTime ? a.getTime() : a) ? e && null !== c.dataPoint ? c : null : c;\n    };\n\n    U.prototype.getDataPointAtXY = function (a, e, c) {\n      if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || e < this.chart.plotArea.y1 || e > this.chart.plotArea.y2) return null;\n      c = c || !1;\n      var b = [],\n          f = 0,\n          h = 0,\n          d = 1,\n          m = !1,\n          v = Infinity,\n          k = 0,\n          l = 0,\n          p = 0;\n      if (\"none\" !== this.chart.plotInfo.axisPlacement) if (p = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({\n        x: a,\n        y: e\n      }), this.axisX.logarithmic) var q = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x),\n          p = 1 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * Math.log(p / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;else q = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p = 0 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * (p - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;\n\n      for (;;) {\n        h = 0 < d ? p + f : p - f;\n\n        if (0 <= h && h < this.dataPoints.length) {\n          var q = this.chart._eventManager.objectMap[this.dataPointIds[h]],\n              g = this.dataPoints[h],\n              t = null;\n\n          if (q) {\n            switch (this.type) {\n              case \"column\":\n              case \"stackedColumn\":\n              case \"stackedColumn100\":\n              case \"bar\":\n              case \"stackedBar\":\n              case \"stackedBar100\":\n              case \"rangeColumn\":\n              case \"rangeBar\":\n              case \"waterfall\":\n              case \"error\":\n                a >= q.x1 && a <= q.x2 && e >= q.y1 && e <= q.y2 && (b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y1 - e), Math.abs(q.y2 - e))\n                }), m = !0);\n                break;\n\n              case \"line\":\n              case \"stepLine\":\n              case \"spline\":\n              case \"area\":\n              case \"stepArea\":\n              case \"stackedArea\":\n              case \"stackedArea100\":\n              case \"splineArea\":\n              case \"scatter\":\n                var w = ma(\"markerSize\", g, this) || 4,\n                    x = c ? 20 : w,\n                    t = Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - e, 2));\n                t <= x && b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: t\n                });\n                q = Math.abs(q.x1 - a);\n                q <= v ? v = q : 0 < d ? k++ : l++;\n                t <= w / 2 && (m = !0);\n                break;\n\n              case \"rangeArea\":\n              case \"rangeSplineArea\":\n                w = ma(\"markerSize\", g, this) || 4;\n                x = c ? 20 : w;\n                t = Math.min(Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - e, 2)), Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y2 - e, 2)));\n                t <= x && b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: t\n                });\n                q = Math.abs(q.x1 - a);\n                q <= v ? v = q : 0 < d ? k++ : l++;\n                t <= w / 2 && (m = !0);\n                break;\n\n              case \"bubble\":\n                w = q.size;\n                t = Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - e, 2));\n                t <= w / 2 && (b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: t\n                }), m = !0);\n                break;\n\n              case \"pie\":\n              case \"doughnut\":\n                w = q.center;\n                x = \"doughnut\" === this.type ? q.percentInnerRadius * q.radius : 0;\n                t = Math.sqrt(Math.pow(w.x - a, 2) + Math.pow(w.y - e, 2));\n                t < q.radius && t > x && (t = Math.atan2(e - w.y, a - w.x), 0 > t && (t += 2 * Math.PI), t = Number(((180 * (t / Math.PI) % 360 + 360) % 360).toFixed(12)), w = Number(((180 * (q.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), x = Number(((180 * (q.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === x && 1 < q.endAngle && (x = 360), w >= x && 0 !== g.y && !n(g.y) && (x += 360, t < w && (t += 360)), t > w && t < x && (b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: 0\n                }), m = !0));\n                break;\n\n              case \"funnel\":\n              case \"pyramid\":\n                t = q.funnelSection;\n                e > t.y1 && e < t.y4 && (t.y6 ? e > t.y6 ? (h = t.x6 + (t.x5 - t.x6) / (t.y5 - t.y6) * (e - t.y6), t = t.x3 + (t.x4 - t.x3) / (t.y4 - t.y3) * (e - t.y3)) : (h = t.x1 + (t.x6 - t.x1) / (t.y6 - t.y1) * (e - t.y1), t = t.x2 + (t.x3 - t.x2) / (t.y3 - t.y2) * (e - t.y2)) : (h = t.x1 + (t.x4 - t.x1) / (t.y4 - t.y1) * (e - t.y1), t = t.x2 + (t.x3 - t.x2) / (t.y3 - t.y2) * (e - t.y2)), a > h && a < t && (b.push({\n                  dataPoint: g,\n                  dataPointIndex: q.dataPointIndex,\n                  dataSeries: this,\n                  distance: 0\n                }), m = !0));\n                break;\n\n              case \"boxAndWhisker\":\n                if (a >= q.x1 - q.borderThickness / 2 && a <= q.x2 + q.borderThickness / 2 && e >= q.y4 - q.borderThickness / 2 && e <= q.y1 + q.borderThickness / 2 || Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && e >= q.y1 && e <= q.y4) b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - e), Math.abs(q.y3 - e))\n                }), m = !0;\n                break;\n\n              case \"candlestick\":\n                if (a >= q.x1 - q.borderThickness / 2 && a <= q.x2 + q.borderThickness / 2 && e >= q.y2 - q.borderThickness / 2 && e <= q.y3 + q.borderThickness / 2 || Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && e >= q.y1 && e <= q.y4) b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - e), Math.abs(q.y3 - e))\n                }), m = !0;\n                break;\n\n              case \"ohlc\":\n                if (Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && e >= q.y2 && e <= q.y3 || a >= q.x1 && a <= (q.x2 + q.x1) / 2 && e >= q.y1 - q.borderThickness / 2 && e <= q.y1 + q.borderThickness / 2 || a >= (q.x1 + q.x2) / 2 && a <= q.x2 && e >= q.y4 - q.borderThickness / 2 && e <= q.y4 + q.borderThickness / 2) b.push({\n                  dataPoint: g,\n                  dataPointIndex: h,\n                  dataSeries: this,\n                  distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - e), Math.abs(q.y3 - e))\n                }), m = !0;\n            }\n\n            if (m || 1E3 < k && 1E3 < l) break;\n          }\n        } else if (0 > p - f && p + f >= this.dataPoints.length) break;\n\n        -1 === d ? (f++, d = 1) : d = -1;\n      }\n\n      a = null;\n\n      for (e = 0; e < b.length; e++) a ? b[e].distance <= a.distance && (a = b[e]) : a = b[e];\n\n      return a;\n    };\n\n    U.prototype.getMarkerProperties = function (a, e, c, b) {\n      var f = this.dataPoints,\n          h = f[a].markerColor ? f[a].markerColor : this.markerColor ? this.markerColor : f[a].color ? f[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length],\n          d = f[a].markerBorderColor ? f[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null,\n          m = n(f[a].markerBorderThickness) ? this.markerBorderThickness ? this.markerBorderThickness : null : f[a].markerBorderThickness,\n          t = f[a].markerType ? f[a].markerType : this.markerType;\n      a = n(f[a].markerSize) ? this.markerSize : f[a].markerSize;\n      return {\n        x: e,\n        y: c,\n        ctx: b,\n        type: t,\n        size: a,\n        color: h,\n        borderColor: d,\n        borderThickness: m\n      };\n    };\n\n    pa(C, X);\n\n    C.prototype.createExtraLabelsForLog = function (a) {\n      a = (a || 0) + 1;\n\n      if (!(5 < a)) {\n        var e = this.logLabelValues[0] || this.intervalStartPosition;\n\n        if (Math.log(this.range) / Math.log(e / this.viewportMinimum) < this.noTicks - 1) {\n          for (var c = C.getNiceNumber((e - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), b = Math.ceil(this.viewportMinimum / c) * c; b < e; b += c) b < this.viewportMinimum || this.logLabelValues.push(b);\n\n          this.logLabelValues.sort(Sa);\n          this.createExtraLabelsForLog(a);\n        }\n      }\n    };\n\n    C.prototype.createLabels = function () {\n      var a,\n          e,\n          c = 0,\n          b = 0,\n          f,\n          h = 0,\n          d = 0,\n          b = 0,\n          b = this.interval,\n          m = 0,\n          t,\n          k = 0.6 * this.chart.height,\n          l;\n      a = !1;\n      var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],\n          q = p.length ? n(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;\n\n      if (\"axisX\" !== this.type || \"dateTime\" !== this.valueType || this.logarithmic) {\n        f = this.viewportMaximum;\n\n        if (this.labels) {\n          a = Math.ceil(b);\n\n          for (var b = Math.ceil(this.intervalStartPosition), g = !1, c = b; c < this.viewportMaximum; c += a) if (this.labels[c]) g = !0;else {\n            g = !1;\n            break;\n          }\n\n          g && (this.interval = a, this.intervalStartPosition = b);\n        }\n\n        if (this.logarithmic && !this.equidistantInterval) for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), b = 0, g = q; b < this.logLabelValues.length; b++) if (c = this.logLabelValues[b], c < this.viewportMinimum) b++;else {\n          for (; g < p.length && c > p[g].endValue; g++);\n\n          a = g < p.length && c >= p[g].startValue && c <= p[g].endValue;\n          l = c;\n          a || (a = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.options,\n            value: l,\n            label: this.labels[l] ? this.labels[l] : null\n          }) : \"axisX\" === this.type && this.labels[l] ? this.labels[l] : fa(l, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {\n            x: 0,\n            y: 0,\n            maxWidth: h,\n            maxHeight: d,\n            angle: this.labelAngle,\n            text: this.prefix + a + this.suffix,\n            backgroundColor: this.labelBackgroundColor,\n            borderColor: this.labelBorderColor,\n            cornerRadius: this.labelCornerRadius,\n            textAlign: this.labelTextAlign,\n            fontSize: this.labelFontSize,\n            fontFamily: this.labelFontFamily,\n            fontWeight: this.labelFontWeight,\n            fontColor: this.labelFontColor,\n            fontStyle: this.labelFontStyle,\n            textBaseline: \"middle\",\n            borderThickness: 0\n          }), this._labels.push({\n            position: l,\n            textBlock: a,\n            effectiveHeight: null\n          }));\n        }\n        g = q;\n\n        for (c = this.intervalStartPosition; c <= f; c = parseFloat(1E-12 > this.interval ? this.logarithmic && this.equidistantInterval ? c * Math.pow(this.logarithmBase, this.interval) : c + this.interval : (this.logarithmic && this.equidistantInterval ? c * Math.pow(this.logarithmBase, this.interval) : c + this.interval).toFixed(12))) {\n          for (; g < p.length && c > p[g].endValue; g++);\n\n          a = g < p.length && c >= p[g].startValue && c <= p[g].endValue;\n          l = c;\n          a || (a = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.options,\n            value: l,\n            label: this.labels[l] ? this.labels[l] : null\n          }) : \"axisX\" === this.type && this.labels[l] ? this.labels[l] : fa(l, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {\n            x: 0,\n            y: 0,\n            maxWidth: h,\n            maxHeight: d,\n            angle: this.labelAngle,\n            text: this.prefix + a + this.suffix,\n            textAlign: this.labelTextAlign,\n            backgroundColor: this.labelBackgroundColor,\n            borderColor: this.labelBorderColor,\n            borderThickness: this.labelBorderThickness,\n            cornerRadius: this.labelCornerRadius,\n            fontSize: this.labelFontSize,\n            fontFamily: this.labelFontFamily,\n            fontWeight: this.labelFontWeight,\n            fontColor: this.labelFontColor,\n            fontStyle: this.labelFontStyle,\n            textBaseline: \"middle\"\n          }), this._labels.push({\n            position: l,\n            textBlock: a,\n            effectiveHeight: null\n          }));\n        }\n      } else for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), f = Ya(new Date(this.viewportMaximum), this.interval, this.intervalType), g = q, c = this.intervalStartPosition; c < f; Ya(c, b, this.intervalType)) {\n        for (a = c.getTime(); g < p.length && a > p[g].endValue; g++);\n\n        l = a;\n        a = g < p.length && a >= p[g].startValue && a <= p[g].endValue;\n        a || (a = this.labelFormatter ? this.labelFormatter({\n          chart: this.chart,\n          axis: this.options,\n          value: new Date(l),\n          label: this.labels[l] ? this.labels[l] : null\n        }) : \"axisX\" === this.type && this.labels[l] ? this.labels[l] : Ca(l, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {\n          x: 0,\n          y: 0,\n          maxWidth: h,\n          backgroundColor: this.labelBackgroundColor,\n          borderColor: this.labelBorderColor,\n          borderThickness: this.labelBorderThickness,\n          cornerRadius: this.labelCornerRadius,\n          maxHeight: d,\n          angle: this.labelAngle,\n          text: this.prefix + a + this.suffix,\n          textAlign: this.labelTextAlign,\n          fontSize: this.labelFontSize,\n          fontFamily: this.labelFontFamily,\n          fontWeight: this.labelFontWeight,\n          fontColor: this.labelFontColor,\n          fontStyle: this.labelFontStyle,\n          textBaseline: \"middle\"\n        }), this._labels.push({\n          position: l,\n          textBlock: a,\n          effectiveHeight: null,\n          breaksLabelType: void 0\n        }));\n      }\n\n      if (\"bottom\" === this._position || \"top\" === this._position) m = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * L[this.intervalType + \"Duration\"] * this.interval, h = \"undefined\" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (d = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);else if (\"left\" === this._position || \"right\" === this._position) m = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * L[this.intervalType + \"Duration\"] * this.interval, this.chart.panEnabled || (h = \"undefined\" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), d = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;\n\n      for (b = 0; b < this._labels.length; b++) {\n        a = this._labels[b].textBlock;\n        a.maxWidth = h;\n        a.maxHeight = d;\n        var A = a.measureText();\n        t = A.height;\n      }\n\n      f = [];\n      q = p = 0;\n      if (this.labelAutoFit || this.options.labelAutoFit) if (n(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), \"bottom\" === this._position || \"top\" === this._position) {\n        if (h = 0.9 * m >> 0, q = 0, !this.chart.panEnabled && 1 <= this._labels.length) {\n          this.sessionVariables.labelFontSize = this.labelFontSize;\n          this.sessionVariables.labelMaxWidth = h;\n          this.sessionVariables.labelMaxHeight = d;\n          this.sessionVariables.labelAngle = this.labelAngle;\n          this.sessionVariables.labelWrap = this.labelWrap;\n\n          for (c = 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {\n            a = this._labels[c].textBlock;\n\n            for (var w, g = a.text.split(\" \"), b = 0; b < g.length; b++) l = g[b], this.ctx.font = a.fontStyle + \" \" + a.fontWeight + \" \" + a.fontSize + \"px \" + a.fontFamily, l = this.ctx.measureText(l), l.width > q && (w = c, q = l.width);\n          }\n\n          c = 0;\n\n          for (c = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {\n            a = this._labels[c].textBlock;\n            A = a.measureText();\n\n            for (g = c + 1; g < this._labels.length; g++) if (!this._labels[g].breaksLabelType) {\n              e = this._labels[g].textBlock;\n              e = e.measureText();\n              break;\n            }\n\n            f.push(a.height);\n            this.sessionVariables.labelMaxHeight = Math.max.apply(Math, f);\n            Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n            Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n            b = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n            if (n(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle) {\n              if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : Math.min((b - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), l = (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !n(this.options.labelWrap)) this.labelWrap ? n(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, q), l), this.sessionVariables.labelWrap = this.labelWrap, e && A.width + e.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle) : n(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = h, e && A.width + e.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = l)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelWrap = this.labelWrap);else {\n                if (n(this.options.labelWrap)) if (!n(this.options.labelMaxWidth)) this.options.labelMaxWidth < h ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d);else if (!n(e)) if (b = A.width + e.width >> 0, g = this.labelFontSize, q < h) b - 2 * h > p && (p = b - 2 * h, b >= 2 * h && b < 2.2 * h ? (this.sessionVariables.labelMaxWidth = h, n(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a.measureText()), this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 2.2 * h && b < 2.8 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = l, this.sessionVariables.labelFontSize = g) : b >= 2.8 * h && b < 3.2 * h ? (this.sessionVariables.labelMaxWidth = Math.max(h, q), this.sessionVariables.labelWrap = !0, n(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 3.2 * h && b < 3.6 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = l, this.sessionVariables.labelFontSize = this.labelFontSize) : b > 3.6 * h && b < 5 * h ? (n(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a.measureText()), this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = l) : b > 5 * h && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelFontSize = g, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = this.labelAngle));else if (w === c && (0 === w && q + this._labels[w + 1].textBlock.measureText().width - 2 * h > p || w === this._labels.length - 1 && q + this._labels[w - 1].textBlock.measureText().width - 2 * h > p || 0 < w && w < this._labels.length - 1 && q + this._labels[w + 1].textBlock.measureText().width - 2 * h > p && q + this._labels[w - 1].textBlock.measureText().width - 2 * h > p)) p = 0 === w ? q + this._labels[w + 1].textBlock.measureText().width - 2 * h : q + this._labels[w - 1].textBlock.measureText().width - 2 * h, this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = l;else if (0 === p) for (this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, q), l), A = a.measureText(), b < this._labels.length - 1 && (g = b + 1, e = this._labels[g].textBlock, e.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, q), l), e = e.measureText(), A.width + e.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25));\n              }\n            } else (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : Math.min((b - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), l = 0 != this.labelAngle ? (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : h, this.sessionVariables.labelMaxHeight = this.labelWrap ? (k - l * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, n(this.options.labelWrap)) ? n(this.options.labelWrap) && (this.labelWrap && !n(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : l, this.sessionVariables.labelMaxHeight = d) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = l, this.sessionVariables.labelMaxHeight = b < 0.9 * m ? 0.9 * m : b, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : l) : (n(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : l, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = d);\n          }\n\n          for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n        } else for (c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = n(this.options.labelMaxWidth) ? n(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = h : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = n(this.options.labelFontSize) ? n(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = n(this.options.labelAngle) ? n(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = n(this.options.labelWrap) ? n(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = n(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = d : this.sessionVariables.labelMaxHeight, a.measureText();\n      } else if (\"left\" === this._position || \"right\" === this._position) if (h = n(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, d = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {\n        this.sessionVariables.labelFontSize = this.labelFontSize;\n        this.sessionVariables.labelMaxWidth = h;\n        this.sessionVariables.labelMaxHeight = d;\n        this.sessionVariables.labelAngle = n(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;\n        this.sessionVariables.labelWrap = this.labelWrap;\n\n        for (c = 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {\n          a = this._labels[c].textBlock;\n          A = a.measureText();\n\n          for (g = c + 1; g < this._labels.length; g++) if (!this._labels[g].breaksLabelType) {\n            e = this._labels[g].textBlock;\n            e = e.measureText();\n            break;\n          }\n\n          f.push(a.height);\n          this.sessionVariables.labelMaxHeight = Math.max.apply(Math, f);\n          b = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n          Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n          Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n          n(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? n(this.options.labelWrap) ? n(this.options.labelWrap) && (n(this.options.labelMaxWidth) ? n(e) || (m = A.height + e.height >> 0, m - 2 * d > q && (q = m - 2 * d, m >= 2 * d && m < 2.4 * d ? (n(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : m >= 2.4 * d && m < 2.8 * d ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : m >= 2.8 * d && m < 3.2 * d ? (this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelWrap = !0, n(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = n(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : m >= 3.2 * d && m < 3.6 * d ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : m > 3.6 * d && m < 10 * d ? (n(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = n(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : m > 10 * d && m < 50 * d && (n(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = n(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelAngle = n(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = d) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? h : Math.min((b - d * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), d), n(this.options.labelWrap)) ? n(this.options.labelWrap) && (this.labelWrap && !n(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : b, n(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : b, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = h) : (this.sessionVariables.labelMaxHeight = d, n(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);\n        }\n\n        for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n      } else for (n(this.chart.stockChart) || this.chart.isNavigator || (this.sessionVariables.labelMaxHeight = d), c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = n(this.options.labelMaxWidth) ? n(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = h : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = n(this.options.labelFontSize) ? n(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = n(this.options.labelAngle) ? n(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = n(this.options.labelWrap) ? n(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = n(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = d : this.sessionVariables.labelMaxHeight, a.measureText();\n\n      for (c = 0; c < this.stripLines.length; c++) {\n        var h = this.stripLines[c],\n            x;\n\n        if (\"outside\" === h.labelPlacement) {\n          d = this.sessionVariables.labelMaxWidth;\n          if (\"bottom\" === this._position || \"top\" === this._position) n(h.options.labelWrap) && !n(this.sessionVariables.stripLineLabelMaxHeight) ? x = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = x = h.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;\n          if (\"left\" === this._position || \"right\" === this._position) n(h.options.labelWrap) && !n(this.sessionVariables.stripLineLabelMaxHeight) ? x = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = x = h.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;\n          n(h.labelBackgroundColor) && (h.labelBackgroundColor = \"#EEEEEE\");\n        } else d = \"bottom\" === this._position || \"top\" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, x = n(h.options.labelWrap) || h.labelWrap ? \"bottom\" === this._position || \"top\" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, n(h.labelBackgroundColor) && (n(h.startValue) && 0 !== h.startValue ? h.labelBackgroundColor = v ? \"transparent\" : null : h.labelBackgroundColor = \"#EEEEEE\");\n\n        h.labelFontSize = \"outside\" === h.labelPlacement && n(h.options.labelFontSize) ? this.labelFontSize : h.labelFontSize;\n        h.labelFontFamily = \"outside\" === h.labelPlacement && n(h.options.labelFontFamily) ? this.labelFontFamily : h.labelFontFamily;\n        h.labelFontWeight = \"outside\" === h.labelPlacement && n(h.options.labelFontWeight) ? this.labelFontWeight : h.labelFontWeight;\n        h.labelFontStyle = \"outside\" === h.labelPlacement && n(h.options.labelFontStyle) ? this.labelFontStyle : h.labelFontStyle;\n        a = new ja(this.ctx, {\n          x: 0,\n          y: 0,\n          backgroundColor: h.labelBackgroundColor,\n          borderColor: h.labelBorderColor,\n          borderThickness: h.labelBorderThickness,\n          cornerRadius: h.labelCornerRadius,\n          maxWidth: h.options.labelMaxWidth ? h.options.labelMaxWidth : d,\n          maxHeight: x,\n          angle: this.labelAngle,\n          text: h.labelFormatter ? h.labelFormatter({\n            chart: this.chart,\n            axis: this,\n            stripLine: h\n          }) : h.label,\n          textAlign: h.labelTextAlign,\n          fontSize: h.labelFontSize,\n          fontFamily: h.labelFontFamily,\n          fontWeight: h.labelFontWeight,\n          fontColor: h.labelFontColor || h.color,\n          fontStyle: h.labelFontStyle,\n          textBaseline: \"middle\"\n        });\n\n        this._stripLineLabels.push({\n          position: h.value,\n          textBlock: a,\n          effectiveHeight: null,\n          stripLine: h\n        });\n      }\n    };\n\n    C.prototype.createLabelsAndCalculateWidth = function () {\n      var a = 0,\n          e = 0;\n      this._labels = [];\n      this._stripLineLabels = [];\n      var c = this.chart.isNavigator ? 0 : 5;\n\n      if (\"left\" === this._position || \"right\" === this._position) {\n        this.createLabels();\n        if (\"inside\" != this.labelPlacement || \"inside\" === this.labelPlacement && 0 < this._index) for (e = 0; e < this._labels.length; e++) {\n          var b = this._labels[e].textBlock,\n              b = b.measureText(),\n              f = 0,\n              f = 0 === this.labelAngle ? b.width : b.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + b.height * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n          a < f && (this.labelEffectiveWidth = a = f);\n          this._labels[e].effectiveWidth = f;\n        }\n\n        for (e = 0; e < this._stripLineLabels.length; e++) \"outside\" === this._stripLineLabels[e].stripLine.labelPlacement && this._stripLineLabels[e].stripLine.value >= this.viewportMinimum && this._stripLineLabels[e].stripLine.value <= this.viewportMaximum && (b = this._stripLineLabels[e].textBlock, b = b.measureText(), f = 0 === this.labelAngle ? b.width : b.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + b.height * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), \"inside\" === this.tickPlacement && (f += this.tickLength), \"inside\" === this.labelPlacement && (a += 0 < this._index ? f : 0), a < f && (a = f), this.stripLineLabelEffectiveWidth = this._stripLineLabels[e].effectiveWidth = f);\n      }\n\n      return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + (\"inside\" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + c;\n    };\n\n    C.prototype.createLabelsAndCalculateHeight = function () {\n      var a = 0;\n      this._labels = [];\n      this._stripLineLabels = [];\n      var e,\n          c = 0,\n          b = this.chart.isNavigator ? 0 : 5;\n\n      if (\"bottom\" === this._position || \"top\" === this._position) {\n        this.createLabels();\n        if (\"inside\" != this.labelPlacement || \"inside\" === this.labelPlacement && 0 < this._index) for (c = 0; c < this._labels.length; c++) {\n          e = this._labels[c].textBlock;\n          e = e.measureText();\n          var f = 0,\n              f = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + e.height * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n          a < f && (this.labelEffectiveHeight = a = f);\n          this._labels[c].effectiveHeight = f;\n        }\n\n        for (c = 0; c < this._stripLineLabels.length; c++) \"outside\" === this._stripLineLabels[c].stripLine.labelPlacement && this._stripLineLabels[c].stripLine.value >= this.viewportMinimum && this._stripLineLabels[c].stripLine.value <= this.viewportMaximum && (e = this._stripLineLabels[c].textBlock, e = e.measureText(), f = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + e.height * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), \"inside\" === this.tickPlacement && (f += this.tickLength), \"inside\" === this.labelPlacement && (a += 0 < this._index ? f : 0), a < f && (a = f), this.stripLineLabelEffectiveHeight = this._stripLineLabels[c].effectiveHeight = f);\n      }\n\n      return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + (\"inside\" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + b;\n    };\n\n    C.setLayout = function (a, e, c, b, f, h) {\n      var d,\n          m,\n          t,\n          k,\n          l = a[0] ? a[0].chart : e[0].chart,\n          p = l.isNavigator ? 0 : 10,\n          q = l._axes;\n      if (a && 0 < a.length) for (var g = 0; g < a.length; g++) a[g] && a[g].calculateAxisParameters();\n      if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateAxisParameters();\n      if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].calculateAxisParameters();\n      if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].calculateAxisParameters();\n\n      for (g = 0; g < q.length; g++) if (q[g] && q[g].scaleBreaks && q[g].scaleBreaks._appliedBreaks.length) for (var v = q[g].scaleBreaks._appliedBreaks, w = 0; w < v.length && !(v[w].startValue > q[g].viewportMaximum); w++) v[w].endValue < q[g].viewportMinimum || (n(q[g].scaleBreaks.firstBreakIndex) && (q[g].scaleBreaks.firstBreakIndex = w), v[w].startValue >= q[g].viewPortMinimum && (q[g].scaleBreaks.lastBreakIndex = w));\n\n      for (var x = w = 0, s = 0, z = 0, u = 0, A = 0, B = 0, C, G, H = m = 0, J, K, L, v = J = K = L = !1, g = 0; g < q.length; g++) q[g] && q[g].title && (q[g]._titleTextBlock = new ja(q[g].ctx, {\n        text: q[g].title,\n        fontSize: q[g].titleFontSize,\n        fontFamily: q[g].titleFontFamily,\n        fontWeight: q[g].titleFontWeight,\n        fontColor: q[g].titleFontColor,\n        fontStyle: q[g].titleFontStyle,\n        borderColor: q[g].titleBorderColor,\n        borderThickness: q[g].titleBorderThickness,\n        backgroundColor: q[g].titleBackgroundColor,\n        cornerRadius: q[g].titleCornerRadius,\n        textBaseline: \"middle\",\n        textAlign: q[g].titleTextAlign\n      }));\n\n      for (g = 0; g < q.length; g++) if (q[g].title) switch (q[g]._position) {\n        case \"left\":\n          q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || h.height;\n          q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * h.width : 1.5 * q[g].titleFontSize;\n          q[g]._titleTextBlock.angle = -90;\n          break;\n\n        case \"right\":\n          q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || h.height;\n          q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * h.width : 1.5 * q[g].titleFontSize;\n          q[g]._titleTextBlock.angle = 90;\n          break;\n\n        default:\n          q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || h.width, q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * h.height : 1.5 * q[g].titleFontSize, q[g]._titleTextBlock.angle = 0;\n      }\n\n      if (\"normal\" === f) {\n        for (var z = [], u = [], A = [], B = [], N = [], Q = [], O = [], P = []; 4 > w;) {\n          var E = 0,\n              W = 0,\n              S = 0,\n              U = 0,\n              X = f = 0,\n              M = 0,\n              $ = 0,\n              V = 0,\n              Y = 0,\n              R = 0,\n              aa = 0;\n          if (c && 0 < c.length) for (A = [], g = R = 0; g < c.length; g++) A.push(Math.ceil(c[g] ? c[g].createLabelsAndCalculateWidth() : 0)), R += A[g], M += c[g] && !l.isNavigator ? c[g].margin : 0;else A.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));\n          O.push(A);\n          if (b && 0 < b.length) for (B = [], g = aa = 0; g < b.length; g++) B.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateWidth() : 0)), aa += B[g], $ += b[g] ? b[g].margin : 0;else B.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));\n          P.push(B);\n          d = Math.round(h.x1 + R + M);\n          t = Math.round(h.x2 - aa - $ > l.width - p ? l.width - p : h.x2 - aa - $);\n          if (a && 0 < a.length) for (z = [], g = V = 0; g < a.length; g++) a[g] && (a[g].lineCoordinates = {}), a[g].lineCoordinates.width = Math.abs(t - d), a[g].title && (a[g]._titleTextBlock.maxWidth = 0 < a[g].titleMaxWidth && a[g].titleMaxWidth < a[g].lineCoordinates.width ? a[g].titleMaxWidth : a[g].lineCoordinates.width), z.push(Math.ceil(a[g] ? a[g].createLabelsAndCalculateHeight() : 0)), V += z[g], f += a[g] && !l.isNavigator ? a[g].margin : 0;else z.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));\n          N.push(z);\n          if (e && 0 < e.length) for (u = [], g = Y = 0; g < e.length; g++) e[g] && (e[g].lineCoordinates = {}), e[g].lineCoordinates.width = Math.abs(t - d), e[g].title && (e[g]._titleTextBlock.maxWidth = 0 < e[g].titleMaxWidth && e[g].titleMaxWidth < e[g].lineCoordinates.width ? e[g].titleMaxWidth : e[g].lineCoordinates.width), u.push(Math.ceil(e[g] ? e[g].createLabelsAndCalculateHeight() : 0)), Y += u[g], X += e[g] && !l.isNavigator ? e[g].margin : 0;else u.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateHeight() : 0));\n          Q.push(u);\n          if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g] && (a[g].lineCoordinates.x1 = d, t = Math.round(h.x2 - aa - $ > l.width - p ? l.width - p : h.x2 - aa - $), a[g]._labels && 1 < a[g]._labels.length && (m = k = 0, k = a[g]._labels[1], m = \"dateTime\" === a[g].valueType ? a[g]._labels[a[g]._labels.length - 2] : a[g]._labels[a[g]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), s = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle))), !a[g] || !a[g].labelAutoFit || n(C) || n(G) || l.isNavigator || l.stockChart || (m = 0, 0 < a[g].labelAngle ? G + s > t && (m += 0 < a[g].labelAngle ? G + s - t - aa : 0) : 0 > a[g].labelAngle ? C - x < d && C - x < a[g].viewportMinimum && (H = d - (M + a[g].tickLength + A + C - x + a[g].labelFontSize / 2)) : 0 === a[g].labelAngle && (G + s > t && (m = G + s / 2 - t - aa), C - x < d && C - x < a[g].viewportMinimum && (H = d - M - a[g].tickLength - A - C + x / 2)), a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 < a[g].labelAngle && 0 < m ? t -= m : a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 > a[g].labelAngle && 0 < H ? d += H : a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 === a[g].labelAngle && (0 < H && (d += H), 0 < m && (t -= m))), l.panEnabled ? V = n(l.sessionVariables.axisX.height) || l.stockChart ? l.sessionVariables.axisX.height = V : l.sessionVariables.axisX.height : l.sessionVariables.axisX.height = V, m = Math.round(h.y2 - V - f + E), k = Math.round(h.y2), a[g].lineCoordinates.x2 = t, a[g].lineCoordinates.width = t - d, a[g].lineCoordinates.y1 = m, a[g].lineCoordinates.y2 = m, \"inside\" === a[g].labelPlacement && 0 < g && (a[g].lineCoordinates.y1 = a[0].lineCoordinates.y2 + E + (a[g].labelEffectiveHeight || 0), a[g].lineCoordinates.y2 = a[g].lineCoordinates.y1 + a[g].lineThickness / 2), \"inside\" === a[g].tickPlacement && 0 < g && (a[g].lineCoordinates.y1 += a[g].tickLength, a[g].lineCoordinates.y2 = a[g].lineCoordinates.y1 + a[g].lineThickness / 2), a[g].bounds = {\n            x1: d,\n            y1: m,\n            x2: t,\n            y2: k - (V + f - z[g] - E),\n            width: t - d\n          }, a[g].bounds.height = a[g].bounds.y2 - a[g].bounds.y1), E += z[g] + a[g].margin;\n          if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].lineCoordinates.x1 = Math.round(h.x1 + R + M), e[g].lineCoordinates.x2 = Math.round(h.x2 - aa - $ > l.width - p ? l.width - p : h.x2 - aa - $), e[g].lineCoordinates.width = Math.abs(t - d), e[g]._labels && 1 < e[g]._labels.length && (k = e[g]._labels[1], m = \"dateTime\" === e[g].valueType ? e[g]._labels[e[g]._labels.length - 2] : e[g]._labels[e[g]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), s = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle))), l.panEnabled ? Y = n(l.sessionVariables.axisX2.height) || l.stockChart ? l.sessionVariables.axisX2.height = Y : l.sessionVariables.axisX2.height : l.sessionVariables.axisX2.height = Y, m = Math.round(h.y1), k = e[g].lineCoordinates.y1 = m + Y + X - W, e[g].lineCoordinates.y2 = m, \"inside\" === e[g].labelPlacement && 0 < g && (e[g].lineCoordinates.y1 = e[0].lineCoordinates.y1 - W - (e[g].labelEffectiveHeight || 0) - 5), \"inside\" === e[g].tickPlacement && 0 < g && (e[g].lineCoordinates.y1 -= e[g].tickLength), e[g].bounds = {\n            x1: d,\n            y1: m + (Y + X - (\"inside\" === e[g].labelPlacement && 0 === g ? u[g] - 5 : u[g]) - W),\n            x2: t,\n            y2: k,\n            width: t - d\n          }, e[g].bounds.height = e[g].bounds.y2 - e[g].bounds.y1, W += (\"inside\" === e[g].labelPlacement && 0 === g ? u[g] - 5 : u[g]) + e[g].margin;\n          if (c && 0 < c.length) for (g = 0; g < c.length; g++) M = l.isNavigator ? 0 : 10, c[g] && (d = Math.round(a[0] ? a[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), M = c[g]._labels && 0 < c[g]._labels.length ? c[g]._labels[c[g]._labels.length - 1].textBlock.height / 2 : p, m = Math.round(h.y1 + Y + X < Math.max(M, p) ? Math.max(M, p) : h.y1 + Y + X), t = Math.round(a[0] ? a[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), M = 0 < a.length ? 0 : c[g]._labels && 0 < c[g]._labels.length ? c[g]._labels[0].textBlock.height / 2 : p, k = Math.round(h.y2 - V - f - M), c[g].lineCoordinates = {\n            x1: d - S,\n            y1: m,\n            x2: t - S,\n            y2: k,\n            height: Math.abs(k - m)\n          }, \"inside\" === c[g].labelPlacement && 0 < g && (c[g].lineCoordinates.x1 = c[0].lineCoordinates.x1 - S - (c[g].labelEffectiveWidth || 0) - 5, c[g].lineCoordinates.x2 = c[g].lineCoordinates.x1 + c[g].lineThickness / 2), \"inside\" === c[g].tickPlacement && 0 < g && (c[g].lineCoordinates.x1 -= c[g].tickLength, c[g].lineCoordinates.x2 = c[g].lineCoordinates.x1 + c[g].lineThickness / 2), c[g].bounds = {\n            x1: d - ((\"inside\" === c[g].labelPlacement && 0 === g ? A[g] - 5 : A[g]) + S),\n            y1: m,\n            x2: t - S,\n            y2: k,\n            height: k - m\n          }, c[g].bounds.width = c[g].bounds.x2 - c[g].bounds.x1, c[g].title && (c[g]._titleTextBlock.maxWidth = 0 < c[g].titleMaxWidth && c[g].titleMaxWidth < c[g].lineCoordinates.height ? c[g].titleMaxWidth : c[g].lineCoordinates.height), S += (\"inside\" === c[g].labelPlacement && 0 === g ? A[g] - 5 : A[g]) + c[g].margin);\n          if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g] && (d = Math.round(a[0] ? a[0].lineCoordinates.x2 : e[0].lineCoordinates.x2), t = Math.round(d), M = b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[b[g]._labels.length - 1].textBlock.height / 2 : 0, m = Math.round(h.y1 + Y + X < Math.max(M, p) ? Math.max(M, p) : h.y1 + Y + X), M = 0 < a.length ? 0 : b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[0].textBlock.height / 2 : 0, k = Math.round(h.y2 - (V + f + M)), b[g].lineCoordinates = {\n            x1: d + U,\n            y1: m,\n            x2: d + U,\n            y2: k,\n            height: Math.abs(k - m)\n          }, \"inside\" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.x1 = b[0].lineCoordinates.x2 + U + (b[g].labelEffectiveWidth || 0) + 5, b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), \"inside\" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.x1 += b[g].tickLength, b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), b[g].bounds = {\n            x1: d + U,\n            y1: m,\n            x2: t + ((\"inside\" === b[g].labelPlacement && 0 === g ? B[g] - 5 : B[g]) + U),\n            y2: k,\n            height: k - m\n          }, b[g].bounds.width = b[g].bounds.x2 - b[g].bounds.x1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.height ? b[g].titleMaxWidth : b[g].lineCoordinates.height), U += (\"inside\" === b[g].labelPlacement && 0 === g ? B[g] - 5 : B[g]) + b[g].margin);\n          if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g] && (a[g].calculateValueToPixelConversionParameters(), a[g].calculateBreaksSizeInValues(), a[g]._labels && 1 < a[g]._labels.length && (C = (a[g].logarithmic ? Math.log(a[g]._labels[1].position / a[g].viewportMinimum) / a[g].conversionParameters.lnLogarithmBase : a[g]._labels[1].position - a[g].viewportMinimum) * Math.abs(a[g].conversionParameters.pixelPerUnit) + a[g].lineCoordinates.x1, d = a[g]._labels[a[g]._labels.length - (\"dateTime\" === a[g].valueType ? 2 : 1)].position, d = a[g].getApparentDifference(a[g].viewportMinimum, d), G = a[g].logarithmic ? (1 < d ? Math.log(d) / a[g].conversionParameters.lnLogarithmBase * Math.abs(a[g].conversionParameters.pixelPerUnit) : 0) + a[g].lineCoordinates.x1 : (0 < d ? d * Math.abs(a[g].conversionParameters.pixelPerUnit) : 0) + a[g].lineCoordinates.x1));\n          if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateValueToPixelConversionParameters(), e[g].calculateBreaksSizeInValues(), e[g]._labels && 1 < e[g]._labels.length && (C = (e[g].logarithmic ? Math.log(e[g]._labels[1].position / e[g].viewportMinimum) / e[g].conversionParameters.lnLogarithmBase : e[g]._labels[1].position - e[g].viewportMinimum) * Math.abs(e[g].conversionParameters.pixelPerUnit) + e[g].lineCoordinates.x1, d = e[g]._labels[e[g]._labels.length - (\"dateTime\" === e[g].valueType ? 2 : 1)].position, d = e[g].getApparentDifference(e[g].viewportMinimum, d), G = e[g].logarithmic ? (1 < d ? Math.log(d) / e[g].conversionParameters.lnLogarithmBase * Math.abs(e[g].conversionParameters.pixelPerUnit) : 0) + e[g].lineCoordinates.x1 : (0 < d ? d * Math.abs(e[g].conversionParameters.pixelPerUnit) : 0) + e[g].lineCoordinates.x1);\n\n          for (g = 0; g < q.length; g++) \"axisY\" === q[g].type && (q[g].calculateValueToPixelConversionParameters(), q[g].calculateBreaksSizeInValues());\n\n          if (0 < w) {\n            if (a && 0 < a.length) for (g = 0; g < a.length; g++) v = N[w - 1][g] === N[w][g] ? !0 : !1;else v = !0;\n            if (e && 0 < e.length) for (g = 0; g < e.length; g++) J = Q[w - 1][g] === Q[w][g] ? !0 : !1;else J = !0;\n            if (c && 0 < c.length) for (g = 0; g < c.length; g++) K = O[w - 1][g] === O[w][g] ? !0 : !1;else K = !0;\n            if (b && 0 < b.length) for (g = 0; g < b.length; g++) L = P[w - 1][g] === P[w][g] ? !0 : !1;else L = !0;\n          }\n\n          if (v && J && K && L) break;\n          w++;\n        }\n\n        if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g].calculateStripLinesThicknessInValues(), a[g].calculateBreaksInPixels();\n        if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateStripLinesThicknessInValues(), e[g].calculateBreaksInPixels();\n        if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].calculateStripLinesThicknessInValues(), c[g].calculateBreaksInPixels();\n        if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].calculateStripLinesThicknessInValues(), b[g].calculateBreaksInPixels();\n      } else {\n        p = [];\n        C = [];\n        H = [];\n        x = [];\n        G = [];\n        s = [];\n        N = [];\n\n        for (Q = []; 4 > w;) {\n          V = U = S = $ = M = X = f = P = O = E = Y = 0;\n          if (a && 0 < a.length) for (H = [], g = U = 0; g < a.length; g++) H.push(Math.ceil(a[g] ? a[g].createLabelsAndCalculateWidth() : 0)), U += H[g], f += a[g] && !l.isNavigator ? a[g].margin : 0;else H.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));\n          N.push(H);\n          if (e && 0 < e.length) for (x = [], g = V = 0; g < e.length; g++) x.push(Math.ceil(e[g] ? e[g].createLabelsAndCalculateWidth() : 0)), V += x[g], X += e[g] ? e[g].margin : 0;else x.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateWidth() : 0));\n          Q.push(x);\n          if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].lineCoordinates = {}, d = Math.round(h.x1 + U + f), t = Math.round(h.x2 - V - X > l.width - 10 ? l.width - 10 : h.x2 - V - X), c[g].labelAutoFit && !n(z) && (0 < !a.length && (d = 0 > c[g].labelAngle ? Math.max(d, z) : 0 === c[g].labelAngle ? Math.max(d, z / 2) : d), 0 < !e.length && (t = 0 < c[g].labelAngle ? t - u / 2 : 0 === c[g].labelAngle ? t - u / 2 : t)), c[g].lineCoordinates.x1 = d, c[g].lineCoordinates.x2 = t, c[g].lineCoordinates.width = Math.abs(t - d), c[g].title && (c[g]._titleTextBlock.maxWidth = 0 < c[g].titleMaxWidth && c[g].titleMaxWidth < c[g].lineCoordinates.width ? c[g].titleMaxWidth : c[g].lineCoordinates.width);\n          if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].lineCoordinates = {}, d = Math.round(h.x1 + U + f), t = Math.round(h.x2 - V - X > b[g].chart.width - 10 ? b[g].chart.width - 10 : h.x2 - V - X), b[g] && b[g].labelAutoFit && !n(A) && (0 < !a.length && (d = 0 < b[g].labelAngle ? Math.max(d, A) : 0 === b[g].labelAngle ? Math.max(d, A / 2) : d), 0 < !e.length && (t -= B / 2)), b[g].lineCoordinates.x1 = d, b[g].lineCoordinates.x2 = t, b[g].lineCoordinates.width = Math.abs(t - d), b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width);\n          if (c && 0 < c.length) for (p = [], g = S = 0; g < c.length; g++) p.push(Math.ceil(c[g] ? c[g].createLabelsAndCalculateHeight() : 0)), S += p[g] + c[g].margin, M += c[g].margin;else p.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));\n          G.push(p);\n          if (b && 0 < b.length) for (C = [], g = 0; g < b.length; g++) C.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateHeight() : 0)), $ += b[g].margin;else C.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));\n          s.push(C);\n          if (c && 0 < c.length) for (g = 0; g < c.length; g++) 0 < c[g]._labels.length && (k = c[g]._labels[0], m = c[g]._labels[c[g]._labels.length - 1], z = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)));\n          if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g] && 0 < b[g]._labels.length && (k = b[g]._labels[0], m = b[g]._labels[b[g]._labels.length - 1], A = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), B = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - m.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)));\n          if (l.panEnabled) for (g = 0; g < c.length; g++) p[g] = n(l.sessionVariables.axisY[g].height) ? l.sessionVariables.axisY[g].height = p[g] : l.sessionVariables.axisY[g].height;else for (g = 0; g < c.length; g++) l.sessionVariables.axisY[g].height = p[g];\n          if (c && 0 < c.length) for (g = c.length - 1; 0 <= g; g--) m = Math.round(h.y2), k = Math.round(h.y2 > c[g].chart.height ? c[g].chart.height : h.y2), c[g].lineCoordinates.y1 = m - (p[g] + c[g].margin + Y), c[g].lineCoordinates.y2 = m - (p[g] + c[g].margin + Y), \"inside\" === c[g].labelPlacement && 0 < g && (c[g].lineCoordinates.y1 = c[g].lineCoordinates.y1 + p[g] - (c[g]._titleTextBlock ? c[g]._titleTextBlock.height : 0) - c[g].tickLength - (c[g].stripLineLabelEffectiveHeight || 0) - 5, c[g].lineCoordinates.y2 = c[g].lineCoordinates.y1 + c[g].lineThickness / 2), \"inside\" === c[g].tickPlacement && 0 < g && (c[g].lineCoordinates.y1 += c[g].tickLength, c[g].lineCoordinates.y2 = c[g].lineCoordinates.y1 + c[g].lineThickness / 2), c[g].bounds = {\n            x1: d,\n            y1: m - (p[g] + Y + c[g].margin),\n            x2: t,\n            y2: k - (Y + c[g].margin),\n            width: t - d,\n            height: p[g]\n          }, c[g].title && (c[g]._titleTextBlock.maxWidth = 0 < c[g].titleMaxWidth && c[g].titleMaxWidth < c[g].lineCoordinates.width ? c[g].titleMaxWidth : c[g].lineCoordinates.width), Y += p[g] + c[g].margin;\n          if (b && 0 < b.length) for (g = b.length - 1; 0 <= g; g--) b[g] && (m = Math.round(h.y1), k = Math.round(h.y1 + (C[g] + b[g].margin + E)), b[g].lineCoordinates.y1 = k, b[g].lineCoordinates.y2 = k, \"inside\" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.y1 = k - C[g] + (b[g]._titleTextBlock ? b[g]._titleTextBlock.height : 0) + b[g].tickLength + (b[g].stripLineLabelEffectiveHeight || 0), b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), \"inside\" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.y1 -= b[g].tickLength, b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), b[g].bounds = {\n            x1: d,\n            y1: m + (b[g].margin + E),\n            x2: t,\n            y2: k,\n            width: t - d\n          }, b[g].bounds.height = b[g].bounds.y2 - b[g].bounds.y1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width), E += C[g] + b[g].margin);\n          if (a && 0 < a.length) for (g = 0; g < a.length; g++) {\n            M = a[g]._labels && 0 < a[g]._labels.length ? a[g]._labels[0].textBlock.fontSize / 2 : 0;\n            d = Math.round(h.x1 + f);\n            m = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1) : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1;\n            t = Math.round(h.x1 + U + f);\n            k = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y1 : h.y2 - S > l.height - Math.max(M, 10) ? l.height - Math.max(M, 10) : h.y2 - S) : h.y2 > l.height - Math.max(M, 10) ? l.height - Math.max(M, 10) : h.y2;\n            if (c && 0 < c.length) for (M = 0; M < c.length; M++) c[M] && c[M].labelAutoFit && (t = c[M].lineCoordinates.x1, d = 0 > c[M].labelAngle || 0 === c[M].labelAngle ? t - U : d);\n            if (b && 0 < b.length) for (M = 0; M < b.length; M++) b[M] && b[M].labelAutoFit && (t = b[M].lineCoordinates.x1, d = t - U);\n            a[g].lineCoordinates = {\n              x1: t - O,\n              y1: m,\n              x2: t - O,\n              y2: k,\n              height: Math.abs(k - m)\n            };\n            \"inside\" === a[g].labelPlacement && 0 < g && (a[g].lineCoordinates.x1 = a[g].lineCoordinates.x1 - (H[g] - (a[g]._titleTextBlock ? a[g]._titleTextBlock.height : 0)) + a[g].tickLength + (a[g].stripLineLabelEffectiveWidth || 0), a[g].lineCoordinates.x2 = a[g].lineCoordinates.x1 + a[g].lineThickness / 2);\n            \"inside\" === a[g].tickPlacement && 0 < g && (a[g].lineCoordinates.x1 -= a[g].tickLength, a[g].lineCoordinates.x2 = a[g].lineCoordinates.x1 + a[g].lineThickness / 2);\n            a[g].bounds = {\n              x1: t - (H[g] + O),\n              y1: m,\n              x2: t - O,\n              y2: k,\n              height: k - m\n            };\n            a[g].bounds.width = a[g].bounds.x2 - a[g].bounds.x1;\n            a[g].title && (a[g]._titleTextBlock.maxWidth = 0 < a[g].titleMaxWidth && a[g].titleMaxWidth < a[g].lineCoordinates.height ? a[g].titleMaxWidth : a[g].lineCoordinates.height);\n            a[g].calculateValueToPixelConversionParameters();\n            a[g].calculateBreaksSizeInValues();\n            O += H[g] + a[g].margin;\n          }\n          if (e && 0 < e.length) for (g = 0; g < e.length; g++) {\n            M = e[g]._labels && 0 < e[g]._labels.length ? e[g]._labels[0].textBlock.fontSize / 2 : 0;\n            d = Math.round(h.x1 - f);\n            m = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1) : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1;\n            t = Math.round(h.x2 - V - X);\n            k = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y1 : h.y2 - S > l.height - Math.max(M, 10) ? l.height - Math.max(M, 10) : h.y2 - S) : h.y2 > l.height - Math.max(M, 10) ? l.height - Math.max(M, 10) : h.y2;\n            if (c && 0 < c.length) for (M = 0; M < c.length; M++) c[M] && c[M].labelAutoFit && (t = 0 > c[M].labelAngle ? Math.max(t, z) : 0 === c[M].labelAngle ? Math.max(t, z / 2) : t, d = 0 > c[M].labelAngle || 0 === c[M].labelAngle ? t - V : d);\n            if (b && 0 < b.length) for (M = 0; M < b.length; M++) b[M] && b[M].labelAutoFit && (t = b[M].lineCoordinates.x2, d = t - V);\n            e[g].lineCoordinates = {\n              x1: t + P,\n              y1: m,\n              x2: t + P,\n              y2: k,\n              height: Math.abs(k - m)\n            };\n            \"inside\" === e[g].labelPlacement && 0 < g && (e[g].lineCoordinates.x1 = e[g].lineCoordinates.x1 + (x[g] - (e[g]._titleTextBlock ? e[g]._titleTextBlock.height : 0) - 2) - e[g].tickLength - (e[g].stripLineLabelEffectiveWidth || 0), e[g].lineCoordinates.x2 = e[g].lineCoordinates.x1 + e[g].lineThickness / 2);\n            \"inside\" === e[g].tickPlacement && 0 < g && (e[g].lineCoordinates.x1 += e[g].tickLength, e[g].lineCoordinates.x2 = e[g].lineCoordinates.x1 + e[g].lineThickness / 2);\n            e[g].bounds = {\n              x1: e[g].lineCoordinates.x1,\n              y1: m,\n              x2: t + x[g] + P,\n              y2: k,\n              width: t - d,\n              height: k - m\n            };\n            e[g].bounds.width = e[g].bounds.x2 - e[g].bounds.x1;\n            e[g].title && (e[g]._titleTextBlock.maxWidth = 0 < e[g].titleMaxWidth && e[g].titleMaxWidth < e[g].lineCoordinates.height ? e[g].titleMaxWidth : e[g].lineCoordinates.height);\n            e[g].calculateValueToPixelConversionParameters();\n            e[g].calculateBreaksSizeInValues();\n            P += x[g] + e[g].margin;\n          }\n\n          for (g = 0; g < q.length; g++) \"axisY\" === q[g].type && (q[g].calculateValueToPixelConversionParameters(), q[g].calculateBreaksSizeInValues());\n\n          if (0 < w) {\n            if (a && 0 < a.length) for (g = 0; g < a.length; g++) v = N[w - 1][g] === N[w][g] ? !0 : !1;else v = !0;\n            if (e && 0 < e.length) for (g = 0; g < e.length; g++) J = Q[w - 1][g] === Q[w][g] ? !0 : !1;else J = !0;\n            if (c && 0 < c.length) for (g = 0; g < c.length; g++) K = G[w - 1][g] === G[w][g] ? !0 : !1;else K = !0;\n            if (b && 0 < b.length) for (g = 0; g < b.length; g++) L = s[w - 1][g] === s[w][g] ? !0 : !1;else L = !0;\n          }\n\n          if (v && J && K && L) break;\n          w++;\n        }\n\n        if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].calculateStripLinesThicknessInValues(), c[g].calculateBreaksInPixels();\n        if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].calculateStripLinesThicknessInValues(), b[g].calculateBreaksInPixels();\n        if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g].calculateStripLinesThicknessInValues(), a[g].calculateBreaksInPixels();\n        if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateStripLinesThicknessInValues(), e[g].calculateBreaksInPixels();\n      }\n    };\n\n    C.render = function (a, e, c, b, f) {\n      var h = a[0] ? a[0].chart : e[0].chart;\n      f = h.ctx;\n      h.alignVerticalAxes && h.alignVerticalAxes();\n      f.save();\n      f.beginPath();\n      a && a.length && f.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[a.length - 1].bounds.y2);\n      e && e.length && f.rect(5, e[e.length - 1].bounds.y1, e[0].chart.width - 10, e[0].bounds.y2);\n      f.clip();\n      if (a && 0 < a.length) for (var d = 0; d < a.length; d++) a[d].renderLabelsTicksAndTitle();\n      if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderLabelsTicksAndTitle();\n      f.restore();\n      if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderLabelsTicksAndTitle();\n      if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderLabelsTicksAndTitle();\n      h.preparePlotArea();\n      h = h.plotArea;\n      f.save();\n      f.beginPath();\n      f.rect(h.x1, h.y1, Math.abs(h.x2 - h.x1), Math.abs(h.y2 - h.y1));\n      f.clip();\n      if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderStripLinesOfThicknessType(\"value\");\n      if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderStripLinesOfThicknessType(\"value\");\n      if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderStripLinesOfThicknessType(\"value\");\n      if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderStripLinesOfThicknessType(\"value\");\n      if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderInterlacedColors();\n      if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderInterlacedColors();\n      if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderInterlacedColors();\n      if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderInterlacedColors();\n      f.restore();\n      if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderGrid(), v && (a[d].createMask(), a[d].renderBreaksBackground());\n      if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderGrid(), v && (e[d].createMask(), e[d].renderBreaksBackground());\n      if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderGrid(), v && (c[d].createMask(), c[d].renderBreaksBackground());\n      if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderGrid(), v && (b[d].createMask(), b[d].renderBreaksBackground());\n      if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderAxisLine();\n      if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderAxisLine();\n      if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderAxisLine();\n      if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderAxisLine();\n      if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderStripLinesOfThicknessType(\"pixel\");\n      if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderStripLinesOfThicknessType(\"pixel\");\n      if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderStripLinesOfThicknessType(\"pixel\");\n      if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderStripLinesOfThicknessType(\"pixel\");\n    };\n\n    C.prototype.calculateStripLinesThicknessInValues = function () {\n      for (var a = 0; a < this.stripLines.length; a++) if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {\n        var e = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue),\n            c = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue),\n            b = this.getApparentDifference(e, c);\n        this.stripLines[a].value = this.convertPixelToValue(Math.abs(this.convertValueToPixel(e) + this.convertValueToPixel(c)) / 2);\n        this.stripLines[a].thickness = b;\n        this.stripLines[a]._thicknessType = \"value\";\n      }\n    };\n\n    C.prototype.calculateBreaksSizeInValues = function () {\n      for (var a = \"left\" === this._position || \"right\" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), b = this.scaleBreaks && !n(this.scaleBreaks.options.spacing), f, h = 0; h < e.length; h++) f = b || !n(e[h].options.spacing), e[h].spacing = Ua(e[h].spacing, a, 8, f ? 0.1 * a : 8, f ? 0 : 3) << 0, e[h].size = 0 > e[h].spacing ? 0 : Math.abs(e[h].spacing / c), this.logarithmic && (e[h].size = Math.pow(this.logarithmBase, e[h].size));\n    };\n\n    C.prototype.calculateBreaksInPixels = function () {\n      if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {\n        var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\n        a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);\n\n        for (var e = 0; e < a.length && !(a[e].startValue > this.conversionParameters.maximum); e++) a[e].endValue < this.conversionParameters.minimum || (n(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = e), a[e].startValue >= this.conversionParameters.minimum && (a[e].startPixel = this.convertValueToPixel(a[e].startValue), this.scaleBreaks.lastBreakIndex = e), a[e].endValue <= this.conversionParameters.maximum && (a[e].endPixel = this.convertValueToPixel(a[e].endValue)));\n      }\n    };\n\n    C.prototype.renderLabelsTicksAndTitle = function () {\n      var a = this,\n          e = !1,\n          c = 0,\n          b = 0,\n          f = 1,\n          h = 0;\n      0 !== this.labelAngle && 360 !== this.labelAngle && (f = 1.2);\n\n      if (\"undefined\" === typeof this.options.interval) {\n        if (\"bottom\" === this._position || \"top\" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\n          for (var c = [], f = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, d, n = this.viewportMaximum, m = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {\n            p = this._labels[k];\n            if (p.position < this.viewportMinimum) break;\n            p.position > this.viewportMaximum || !(k === this._labels.length - 1 || d < Math.log(n / p.position) * m / f) || (c.push(p), n = p.position, d = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\n          }\n\n          this._labels = c;\n        } else {\n          for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (d = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += d);\n\n          c > this.lineCoordinates.width * f && this.labelAutoFit && (e = !0);\n        }\n        if (\"left\" === this._position || \"right\" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\n          for (var c = [], l, n = this.viewportMaximum, m = this.lineCoordinates.height / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {\n            p = this._labels[k];\n            if (p.position < this.viewportMinimum) break;\n            p.position > this.viewportMaximum || !(k === this._labels.length - 1 || l < Math.log(n / p.position) * m) || (c.push(p), n = p.position, l = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\n          }\n\n          this._labels = c;\n        } else {\n          for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (l = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += l);\n\n          b > this.lineCoordinates.height * f && this.labelAutoFit && (e = !0);\n        }\n      }\n\n      this.logarithmic && !this.equidistantInterval && this.labelAutoFit && this._labels.sort(function (a, b) {\n        return a.position - b.position;\n      });\n      var k = 0,\n          p,\n          q;\n\n      if (\"bottom\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, q.y << 0), this.ctx.lineTo(b, q.y + this.tickLength << 0), this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === p.textBlock.angle ? (q.x -= p.textBlock.width / 2, q.y = \"inside\" === this.labelPlacement ? q.y - ((\"inside\" === this.tickPlacement ? this.tickLength : 0) + p.textBlock.height - p.textBlock.fontSize / 2) : q.y + (\"inside\" === this.tickPlacement ? 0 : this.tickLength) + p.textBlock.fontSize / 2 + 5) : 0 > this.labelAngle ? (q.x -= \"inside\" === this.labelPlacement ? 0 : p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle), q.y = \"inside\" === this.labelPlacement ? q.y - (\"inside\" === this.tickPlacement ? this.tickLength : 0) - (p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) : q.y + (\"inside\" === this.tickPlacement ? 0 : this.tickLength) + 5 + Math.abs(p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - p.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle))) : (q.x -= \"inside\" === this.labelPlacement ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, q.y = \"inside\" === this.labelPlacement ? q.y - (\"inside\" === this.tickPlacement ? this.tickLength : 0) - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - (p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) : q.y + (\"inside\" === this.tickPlacement ? 0 : this.tickLength) + 5 + Math.abs(p.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle))), p.textBlock.x = q.x, p.textBlock.y = q.y));\n\n        \"inside\" === this.tickPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n            a.ctx.lineWidth = a.tickThickness;\n            a.ctx.strokeStyle = a.tickColor;\n            var b = 1 === a.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0;\n            a.ctx.save();\n            a.ctx.beginPath();\n            a.ctx.moveTo(b, q.y << 0);\n            a.ctx.lineTo(b, q.y - a.tickLength << 0);\n            a.ctx.stroke();\n            a.ctx.restore();\n          }\n        }, this);\n        this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height + this._titleTextBlock.fontSize / 2 - 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      } else if (\"top\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, q.y << 0), this.ctx.lineTo(b, q.y - this.tickLength << 0), this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === p.textBlock.angle ? (q.x -= p.textBlock.width / 2, q.y = \"inside\" === this.labelPlacement ? q.y + this.labelFontSize / 2 + (\"inside\" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - ((\"inside\" === this.tickPlacement ? 0 : this.tickLength) + p.textBlock.height - p.textBlock.fontSize / 2)) : 0 > this.labelAngle ? (q.x -= \"inside\" === this.labelPlacement ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, q.y = \"inside\" === this.labelPlacement ? q.y + (\"inside\" === this.tickPlacement ? this.tickLength : 0) + 5 - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + p.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle) : q.y - (\"inside\" === this.tickPlacement ? 0 : this.tickLength) - 2 - (p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle)) : (q.x -= \"inside\" === this.labelPlacement ? 0 : p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle), q.y = \"inside\" === this.labelPlacement ? q.y + (\"inside\" === this.tickPlacement ? this.tickLength : 0) + 5 + p.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle) : q.y - (\"inside\" === this.tickPlacement ? 0 : this.tickLength) - 2 - ((p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle))), p.textBlock.x = q.x, p.textBlock.y = q.y));\n\n        \"inside\" === this.tickPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n            a.ctx.lineWidth = a.tickThickness;\n            a.ctx.strokeStyle = a.tickColor;\n            var b = 1 === a.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0;\n            a.ctx.save();\n            a.ctx.beginPath();\n            a.ctx.moveTo(b, q.y << 0);\n            a.ctx.lineTo(b, q.y + a.tickLength << 0);\n            a.ctx.stroke();\n            a.ctx.restore();\n          }\n        }, this);\n        this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + this._titleTextBlock.fontSize / 2 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      } else if (\"left\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, b), this.ctx.lineTo(q.x - this.tickLength << 0, b), this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p.textBlock.y = q.y, p.textBlock.x = \"inside\" === this.labelPlacement ? q.x + (\"inside\" === this.tickPlacement ? this.tickLength : 0) + 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - (\"inside\" === this.tickPlacement ? 0 : this.tickLength) - 5) : 0 > this.labelAngle ? (p.textBlock.y = \"inside\" === this.labelPlacement ? q.y : q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = \"inside\" === this.labelPlacement ? q.x - p.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) + (\"inside\" === this.tickPlacement ? this.tickLength : 0) + 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (\"inside\" === this.tickPlacement ? 0 : this.tickLength) - 5) : (p.textBlock.y = \"inside\" === this.labelPlacement ? q.y : q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = \"inside\" === this.labelPlacement ? q.x + (p.textBlock.height - p.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) + (\"inside\" === this.tickPlacement ? this.tickLength : 0) + 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - p.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) - (\"inside\" === this.tickPlacement ? 0 : this.tickLength) - 5)));\n\n        \"inside\" === this.tickPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n            a.ctx.lineWidth = a.tickThickness;\n            a.ctx.strokeStyle = a.tickColor;\n            var b = 1 === a.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0;\n            a.ctx.save();\n            a.ctx.beginPath();\n            a.ctx.moveTo(q.x << 0, b);\n            a.ctx.lineTo(q.x + a.tickLength << 0, b);\n            a.ctx.stroke();\n            a.ctx.restore();\n          }\n        }, this);\n        this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + this._titleTextBlock.fontSize / 2 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      } else if (\"right\" === this._position) {\n        for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, b), this.ctx.lineTo(q.x + this.tickLength << 0, b), this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p.textBlock.y = q.y, p.textBlock.x = \"inside\" === this.labelPlacement ? q.x - p.textBlock.width - (\"inside\" === this.tickPlacement ? this.tickLength : 0) - 5 : q.x + (\"inside\" === this.tickPlacement ? 0 : this.tickLength) + 5) : 0 > this.labelAngle ? (p.textBlock.y = \"inside\" === this.labelPlacement ? q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : q.y, p.textBlock.x = \"inside\" === this.labelPlacement ? q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (\"inside\" === this.tickPlacement ? this.tickLength : 0) - 5 : q.x - p.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) + (\"inside\" === this.tickPlacement ? 0 : this.tickLength) + 5) : (p.textBlock.y = \"inside\" === this.labelPlacement ? q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : q.y, p.textBlock.x = \"inside\" === this.labelPlacement ? q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - p.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) - (\"inside\" === this.tickPlacement ? this.tickLength : 0) - 5 : q.x + (p.textBlock.height - p.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) + (\"inside\" === this.tickPlacement ? 0 : this.tickLength) + 5)));\n\n        \"inside\" === this.tickPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n          for (k = 0; k < a._labels.length; k++) if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\n            a.ctx.lineWidth = a.tickThickness;\n            a.ctx.strokeStyle = a.tickColor;\n            var b = 1 === a.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0;\n            a.ctx.save();\n            a.ctx.beginPath();\n            a.ctx.moveTo(q.x << 0, b);\n            a.ctx.lineTo(q.x - a.tickLength << 0, b);\n            a.ctx.stroke();\n            a.ctx.restore();\n          }\n        }, this);\n        this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - this._titleTextBlock.fontSize / 2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n      }\n\n      h = 0;\n      if (\"inside\" === this.labelPlacement) this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n        for (k = 0; k < a._labels.length; k++) p = a._labels[k], p.position < a.viewportMinimum || p.position > a.viewportMaximum || e && 0 !== h++ % 2 && a.labelAutoFit || (a.ctx.save(), a.ctx.beginPath(), p.textBlock.render(!0), a.ctx.restore());\n      }, this);else for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || p.position > this.viewportMaximum || e && 0 !== h++ % 2 && this.labelAutoFit || p.textBlock.render(!0);\n    };\n\n    C.prototype.renderInterlacedColors = function () {\n      var a = this.chart.plotArea.ctx,\n          e,\n          c,\n          b = this.chart.plotArea,\n          f = 0;\n      e = !0;\n      if ((\"bottom\" === this._position || \"top\" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, f = 0; f < this._labels.length; f++) e ? (e = this.getPixelCoordinatesOnAxis(this._labels[f].position), c = f + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[f + 1].position), a.fillRect(Math.min(c.x, e.x), b.y1, Math.abs(c.x - e.x), Math.abs(b.y1 - b.y2)), e = !1) : e = !0;else if ((\"left\" === this._position || \"right\" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, f = 0; f < this._labels.length; f++) e ? (c = this.getPixelCoordinatesOnAxis(this._labels[f].position), e = f + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[f + 1].position), a.fillRect(b.x1, Math.min(c.y, e.y), Math.abs(b.x1 - b.x2), Math.abs(e.y - c.y)), e = !1) : e = !0;\n      a.beginPath();\n    };\n\n    C.prototype.renderStripLinesOfThicknessType = function (a) {\n      if (this.stripLines && 0 < this.stripLines.length && a) {\n        var e = this,\n            c,\n            b,\n            f = 0,\n            h = 0,\n            d = !1;\n        b = !1;\n\n        for (var m = [], t = [], k = !1, f = 0; f < this.stripLines.length; f++) {\n          var l = this.stripLines[f];\n          l._thicknessType === a && (\"pixel\" === a && (l.value < this.viewportMinimum || l.value > this.viewportMaximum || n(l.value) || isNaN(this.range)) || \"value\" === a && (l.startValue <= this.viewportMinimum && l.endValue <= this.viewportMinimum || l.startValue >= this.viewportMaximum && l.endValue >= this.viewportMaximum || n(l.startValue) || n(l.endValue) || isNaN(this.range)) || m.push(l));\n        }\n\n        for (f = 0; f < this._stripLineLabels.length; f++) if (l = this.stripLines[f], c = this._stripLineLabels[f], !(c.position < this.viewportMinimum || c.position > this.viewportMaximum || isNaN(this.range))) if (b = this.getPixelCoordinatesOnAxis(c.position), \"outside\" === c.stripLine.labelPlacement) {\n          l && (this.ctx.strokeStyle = l.color, this.ctx.lineWidth = \"pixel\" === l._thicknessType ? l.thickness : this.tickThickness);\n\n          if (\"bottom\" === this._position) {\n            var p = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + 0.5 : b.x << 0;\n            this.ctx.beginPath();\n            this.ctx.moveTo(p, b.y << 0);\n            this.ctx.lineTo(p, b.y + this.tickLength << 0);\n            this.ctx.stroke();\n            0 === this.labelAngle ? (b.x -= c.textBlock.width / 2, b.y += this.tickLength + c.textBlock.fontSize / 2 + 5) : (b.x -= 0 > this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, b.y += this.tickLength + 5 + (0 > this.labelAngle ? Math.abs(c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - c.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle)) : Math.abs(c.textBlock.fontSize / 2 * Math.cos(Math.PI / 180 * this.labelAngle))));\n          } else \"top\" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + 0.5 : b.x << 0, this.ctx.beginPath(), this.ctx.moveTo(p, b.y << 0), this.ctx.lineTo(p, b.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (b.x -= c.textBlock.width / 2, b.y -= this.tickLength + c.textBlock.height - c.textBlock.fontSize / 2) : (b.x -= 0 < this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, b.y -= this.tickLength + 2 + (0 < this.labelAngle ? (c.textBlock.height - c.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : (c.textBlock.height - c.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle)))) : \"left\" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + 0.5 : b.y << 0, this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, p), this.ctx.lineTo(b.x - this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? b.x = b.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (b.y -= c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), b.x -= this.tickLength + 5 + (0 < this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + c.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle) : c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - (c.textBlock.height - c.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle)))) : \"right\" === this._position && (p = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + 0.5 : b.y << 0, this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, p), this.ctx.lineTo(b.x + this.tickLength << 0, p), this.ctx.stroke(), b.x = 0 === this.labelAngle ? b.x + this.tickLength + 5 : this.tickLength + 5 + (0 < this.labelAngle ? b.x + (c.textBlock.height - c.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) : b.x - c.textBlock.fontSize / 2 * Math.sin(Math.PI / 180 * this.labelAngle)));\n\n          c.textBlock.x = b.x;\n          c.textBlock.y = b.y;\n          t.push(c);\n        } else l._thicknessType === a && (c.textBlock.angle = -90, \"bottom\" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.height - 3, c.textBlock.measureText(), b.x - c.textBlock.height - l.thickness / 2 > this.chart.plotArea.x1 ? n(l.startValue) ? b.x -= c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : (c.textBlock.angle = 90, n(l.startValue) ? b.x += c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2), b.y = -90 === c.textBlock.angle ? \"near\" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : \"center\" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y1 + c.textBlock.width + 3 : \"near\" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - c.textBlock.width - 3 : \"center\" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : \"top\" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.height - 3, c.textBlock.measureText(), b.x - c.textBlock.height - l.thickness / 2 > this.chart.plotArea.x1 ? n(l.startValue) ? b.x -= c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : (c.textBlock.angle = 90, n(l.startValue) ? b.x += c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2), b.y = -90 === c.textBlock.angle ? \"near\" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + c.textBlock.width + 3 : \"center\" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : \"near\" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : \"center\" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y2 - c.textBlock.width - 3) : \"left\" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.width - 3, c.textBlock.angle = 0, c.textBlock.measureText(), b.y - c.textBlock.height - l.thickness / 2 > this.chart.plotArea.y1 ? n(l.startValue) ? b.y -= c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : n(l.startValue) ? b.y += c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.y += c.textBlock.height / 2 - c.textBlock.fontSize + 3, b.x = \"near\" === c.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : \"center\" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x2 - c.textBlock.width - 3) : \"right\" === this._position && (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.width - 3, c.textBlock.angle = 0, c.textBlock.measureText(), b.y - c.textBlock.height - l.thickness / 2 > this.chart.plotArea.y1 ? n(l.startValue) ? b.y -= c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : n(l.startValue) ? b.y += c.textBlock.height - c.textBlock.fontSize / 2 + l.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3, b.x = \"near\" === c.stripLine.labelAlign ? this.chart.plotArea.x2 - c.textBlock.width - 3 : \"center\" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x1 + 3), c.textBlock.x = b.x, c.textBlock.y = b.y, t.push(c));\n\n        if (!k) {\n          b = !1;\n          this.ctx.save();\n          this.ctx.beginPath();\n          this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n          this.ctx.clip();\n\n          for (f = 0; f < m.length; f++) l = m[f], l.showOnTop ? d || (d = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n            this.ctx.save();\n            this.ctx.beginPath();\n            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n            this.ctx.clip();\n\n            for (h = 0; h < m.length; h++) l = m[h], l.showOnTop && l.render();\n\n            this.ctx.restore();\n          }, l)) : l.render();\n\n          for (f = 0; f < t.length; f++) c = t[f], c.stripLine.showOnTop ? b || (b = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n            for (h = 0; h < t.length; h++) c = t[h], \"inside\" === c.stripLine.labelPlacement && c.stripLine.showOnTop && (e.ctx.save(), e.ctx.beginPath(), e.ctx.rect(e.chart.plotArea.x1, e.chart.plotArea.y1, e.chart.plotArea.width, e.chart.plotArea.height), e.ctx.clip(), c.textBlock.render(!0), e.ctx.restore());\n          }, c.textBlock)) : \"inside\" === c.stripLine.labelPlacement && c.textBlock.render(!0);\n\n          this.ctx.restore();\n          k = !0;\n        }\n\n        if (k) for (b = !1, f = 0; f < t.length; f++) c = t[f], \"outside\" === c.stripLine.labelPlacement && c.textBlock.render(!0);\n      }\n    };\n\n    C.prototype.renderBreaksBackground = function () {\n      this.chart._breaksCanvas && this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());\n    };\n\n    C.prototype.createMask = function () {\n      if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {\n        var a = this.scaleBreaks._appliedBreaks;\n        v ? (this.maskCanvas = ua(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext(\"2d\")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);\n        this.maskCtx.save();\n        this.maskCtx.beginPath();\n        this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n        this.maskCtx.clip();\n\n        for (var e = 0; e < a.length; e++) a[e].endValue < this.viewportMinimum || a[e].startValue > this.viewportMaximum || isNaN(this.range) || a[e].render(this.maskCtx);\n\n        this.maskCtx.restore();\n      }\n    };\n\n    C.prototype.renderCrosshair = function (a, e) {\n      isFinite(this.minimum) && isFinite(this.maximum) && this.crosshair.render(a, e);\n    };\n\n    C.prototype.showCrosshair = function (a) {\n      n(a) || a < this.viewportMinimum || a > this.viewportMaximum || (\"top\" === this._position || \"bottom\" === this._position ? this.crosshair.render(this.convertValueToPixel(a), null, a) : this.crosshair.render(null, this.convertValueToPixel(a), a));\n    };\n\n    C.prototype.renderGrid = function () {\n      if (this.gridThickness && 0 < this.gridThickness) {\n        var a = this.chart.ctx;\n        a.save();\n        var e,\n            c = this.chart.plotArea;\n        a.lineWidth = this.gridThickness;\n        a.strokeStyle = this.gridColor;\n        a.setLineDash && a.setLineDash(G(this.gridDashType, this.gridThickness));\n        if (\"bottom\" === this._position || \"top\" === this._position) for (b = 0; b < this._labels.length; b++) this._labels[b].position < this.viewportMinimum || this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType || (a.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[b].position), e = 1 === a.lineWidth % 2 ? (e.x << 0) + 0.5 : e.x << 0, a.moveTo(e, c.y1 << 0), a.lineTo(e, c.y2 << 0), a.stroke());else if (\"left\" === this._position || \"right\" === this._position) for (var b = 0; b < this._labels.length; b++) this._labels[b].position < this.viewportMinimum || this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType || (a.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[b].position), e = 1 === a.lineWidth % 2 ? (e.y << 0) + 0.5 : e.y << 0, a.moveTo(c.x1 << 0, e), a.lineTo(c.x2 << 0, e), a.stroke());\n        a.restore();\n      }\n    };\n\n    C.prototype.renderAxisLine = function () {\n      var a = this.chart.ctx,\n          e = v ? this.chart._preRenderCtx : a,\n          c = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)),\n          b = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)),\n          f,\n          h;\n      e.save();\n\n      if (\"bottom\" === this._position || \"top\" === this._position) {\n        if (this.lineThickness) {\n          this.reversed ? (f = this.lineCoordinates.x2, h = this.lineCoordinates.x1) : (f = this.lineCoordinates.x1, h = this.lineCoordinates.x2);\n          e.lineWidth = this.lineThickness;\n          e.strokeStyle = this.lineColor ? this.lineColor : \"black\";\n          e.setLineDash && e.setLineDash(G(this.lineDashType, this.lineThickness));\n          var d = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;\n          e.beginPath();\n          if (this.scaleBreaks && !n(this.scaleBreaks.firstBreakIndex)) if (n(this.scaleBreaks.lastBreakIndex)) f = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;else for (var m = this.scaleBreaks.firstBreakIndex; m <= this.scaleBreaks.lastBreakIndex; m++) e.moveTo(f, d), e.lineTo(this.scaleBreaks._appliedBreaks[m].startPixel + c, d), f = this.scaleBreaks._appliedBreaks[m].endPixel + b;\n          f && (e.moveTo(f, d), e.lineTo(h, d));\n          e.stroke();\n        }\n      } else if ((\"left\" === this._position || \"right\" === this._position) && this.lineThickness) {\n        this.reversed ? (f = this.lineCoordinates.y1, h = this.lineCoordinates.y2) : (f = this.lineCoordinates.y2, h = this.lineCoordinates.y1);\n        e.lineWidth = this.lineThickness;\n        e.strokeStyle = this.lineColor;\n        e.setLineDash && e.setLineDash(G(this.lineDashType, this.lineThickness));\n        d = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;\n        e.beginPath();\n        if (this.scaleBreaks && !n(this.scaleBreaks.firstBreakIndex)) if (n(this.scaleBreaks.lastBreakIndex)) f = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;else for (m = this.scaleBreaks.firstBreakIndex; m <= this.scaleBreaks.lastBreakIndex; m++) e.moveTo(d, f), e.lineTo(d, this.scaleBreaks._appliedBreaks[m].startPixel + b), f = this.scaleBreaks._appliedBreaks[m].endPixel + c;\n        f && (e.moveTo(d, f), e.lineTo(d, h));\n        e.stroke();\n      }\n\n      v && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), e.clearRect(0, 0, this.chart.width, this.chart.height));\n      e.restore();\n    };\n\n    C.prototype.getPixelCoordinatesOnAxis = function (a) {\n      var e = {};\n      if (\"bottom\" === this._position || \"top\" === this._position) e.x = this.convertValueToPixel(a), e.y = this.lineCoordinates.y1;\n      if (\"left\" === this._position || \"right\" === this._position) e.y = this.convertValueToPixel(a), e.x = this.lineCoordinates.x2;\n      return e;\n    };\n\n    C.prototype.convertPixelToValue = function (a) {\n      if (\"undefined\" === typeof a) return null;\n      var e = 0,\n          c = 0,\n          b,\n          e = !0,\n          f = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],\n          c = \"number\" === typeof a ? a : \"left\" === this._position || \"right\" === this._position ? a.y : a.x;\n\n      if (this.logarithmic) {\n        a = b = Math.pow(this.logarithmBase, (c - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);\n        if (c <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed) for (c = 0; c < f.length; c++) {\n          if (!(f[c].endValue < this.conversionParameters.minimum)) if (e) {\n            if (f[c].startValue < this.conversionParameters.minimum) {\n              if (1 < f[c].size && this.conversionParameters.minimum * Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size)) < f[c].endValue) {\n                a = Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size));\n                break;\n              } else a *= f[c].endValue / this.conversionParameters.minimum / Math.pow(f[c].size, Math.log(f[c].endValue / this.conversionParameters.minimum) / Math.log(f[c].endValue / f[c].startValue)), b /= Math.pow(f[c].size, Math.log(f[c].endValue / this.conversionParameters.minimum) / Math.log(f[c].endValue / f[c].startValue));\n\n              e = !1;\n            } else if (b > f[c].startValue / this.conversionParameters.minimum) {\n              b /= f[c].startValue / this.conversionParameters.minimum;\n\n              if (b < f[c].size) {\n                a *= Math.pow(f[c].endValue / f[c].startValue, 1 === f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) / b;\n                break;\n              } else a *= f[c].endValue / f[c].startValue / f[c].size;\n\n              b /= f[c].size;\n              e = !1;\n            } else break;\n          } else if (b > f[c].startValue / f[c - 1].endValue) {\n            b /= f[c].startValue / f[c - 1].endValue;\n\n            if (b < f[c].size) {\n              a *= Math.pow(f[c].endValue / f[c].startValue, 1 === f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) / b;\n              break;\n            } else a *= f[c].endValue / f[c].startValue / f[c].size;\n\n            b /= f[c].size;\n          } else break;\n        } else for (c = f.length - 1; 0 <= c; c--) if (!(f[c].startValue > this.conversionParameters.minimum)) if (e) {\n          if (f[c].endValue > this.conversionParameters.minimum) {\n            if (1 < f[c].size && this.conversionParameters.minimum * Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size)) > f[c].startValue) {\n              a = Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size));\n              break;\n            } else a *= f[c].startValue / this.conversionParameters.minimum * Math.pow(f[c].size, Math.log(f[c].startValue / this.conversionParameters.minimum) / Math.log(f[c].endValue / f[c].startValue)) * b, b *= Math.pow(f[c].size, Math.log(this.conversionParameters.minimum / f[c].startValue) / Math.log(f[c].endValue / f[c].startValue));\n\n            e = !1;\n          } else if (b < f[c].endValue / this.conversionParameters.minimum) {\n            b /= f[c].endValue / this.conversionParameters.minimum;\n\n            if (b > 1 / f[c].size) {\n              a *= Math.pow(f[c].endValue / f[c].startValue, 1 >= f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) * b;\n              break;\n            } else a /= f[c].endValue / f[c].startValue / f[c].size;\n\n            b *= f[c].size;\n            e = !1;\n          } else break;\n        } else if (b < f[c].endValue / f[c + 1].startValue) {\n          b /= f[c].endValue / f[c + 1].startValue;\n\n          if (b > 1 / f[c].size) {\n            a *= Math.pow(f[c].endValue / f[c].startValue, 1 >= f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) * b;\n            break;\n          } else a /= f[c].endValue / f[c].startValue / f[c].size;\n\n          b *= f[c].size;\n        } else break;\n        e = a * this.viewportMinimum;\n      } else {\n        a = b = (c - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;\n        if (c <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed) for (c = 0; c < f.length; c++) {\n          if (!(f[c].endValue < this.conversionParameters.minimum)) if (e) {\n            if (f[c].startValue < this.conversionParameters.minimum) {\n              if (f[c].size && this.conversionParameters.minimum + b * (f[c].endValue - f[c].startValue) / f[c].size < f[c].endValue) {\n                a = 0 >= f[c].size ? 0 : b * (f[c].endValue - f[c].startValue) / f[c].size;\n                break;\n              } else a += f[c].endValue - this.conversionParameters.minimum - f[c].size * (f[c].endValue - this.conversionParameters.minimum) / (f[c].endValue - f[c].startValue), b -= f[c].size * (f[c].endValue - this.conversionParameters.minimum) / (f[c].endValue - f[c].startValue);\n\n              e = !1;\n            } else if (b > f[c].startValue - this.conversionParameters.minimum) {\n              b -= f[c].startValue - this.conversionParameters.minimum;\n\n              if (b < f[c].size) {\n                a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) - b;\n                break;\n              } else a += f[c].endValue - f[c].startValue - f[c].size;\n\n              b -= f[c].size;\n              e = !1;\n            } else break;\n          } else if (b > f[c].startValue - f[c - 1].endValue) {\n            b -= f[c].startValue - f[c - 1].endValue;\n\n            if (b < f[c].size) {\n              a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) - b;\n              break;\n            } else a += f[c].endValue - f[c].startValue - f[c].size;\n\n            b -= f[c].size;\n          } else break;\n        } else for (c = f.length - 1; 0 <= c; c--) if (!(f[c].startValue > this.conversionParameters.minimum)) if (e) {\n          if (f[c].endValue > this.conversionParameters.minimum) {\n            if (f[c].size && this.conversionParameters.minimum + b * (f[c].endValue - f[c].startValue) / f[c].size > f[c].startValue) {\n              a = 0 >= f[c].size ? 0 : b * (f[c].endValue - f[c].startValue) / f[c].size;\n              break;\n            } else a += f[c].startValue - this.conversionParameters.minimum + f[c].size * (this.conversionParameters.minimum - f[c].startValue) / (f[c].endValue - f[c].startValue), b += f[c].size * (this.conversionParameters.minimum - f[c].startValue) / (f[c].endValue - f[c].startValue), e = !1;\n          } else if (b < f[c].endValue - this.conversionParameters.minimum) {\n            b -= f[c].endValue - this.conversionParameters.minimum;\n\n            if (b > -1 * f[c].size) {\n              a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) + b;\n              break;\n            } else a -= f[c].endValue - f[c].startValue - f[c].size;\n\n            b += f[c].size;\n            e = !1;\n          } else break;\n        } else if (b < f[c].endValue - f[c + 1].startValue) {\n          b -= f[c].endValue - f[c + 1].startValue;\n\n          if (b > -1 * f[c].size) {\n            a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) + b;\n            break;\n          } else a -= f[c].endValue - f[c].startValue - f[c].size;\n\n          b += f[c].size;\n        } else break;\n        e = this.conversionParameters.minimum + a;\n      }\n\n      return e;\n    };\n\n    C.prototype.convertValueToPixel = function (a) {\n      a = this.getApparentDifference(this.conversionParameters.minimum, a, a);\n      return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : \"axisX\" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5;\n    };\n\n    C.prototype.getApparentDifference = function (a, e, c, b) {\n      var f = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\n\n      if (this.logarithmic) {\n        c = n(c) ? e / a : c;\n\n        for (var h = 0; h < f.length && !(e < f[h].startValue); h++) a > f[h].endValue || (a <= f[h].startValue && e >= f[h].endValue ? c = c / f[h].endValue * f[h].startValue * f[h].size : a >= f[h].startValue && e >= f[h].endValue ? c = c / f[h].endValue * a * Math.pow(f[h].size, Math.log(f[h].endValue / a) / Math.log(f[h].endValue / f[h].startValue)) : a <= f[h].startValue && e <= f[h].endValue ? c = c / e * f[h].startValue * Math.pow(f[h].size, Math.log(e / f[h].startValue) / Math.log(f[h].endValue / f[h].startValue)) : !b && a > f[h].startValue && e < f[h].endValue && (c = a * Math.pow(f[h].size, Math.log(e / a) / Math.log(f[h].endValue / f[h].startValue))));\n      } else for (c = n(c) ? Math.abs(e - a) : c, h = 0; h < f.length && !(e < f[h].startValue); h++) a > f[h].endValue || (a <= f[h].startValue && e >= f[h].endValue ? c = c - f[h].endValue + f[h].startValue + f[h].size : a > f[h].startValue && e >= f[h].endValue ? c = c - f[h].endValue + a + f[h].size * (f[h].endValue - a) / (f[h].endValue - f[h].startValue) : a <= f[h].startValue && e < f[h].endValue ? c = c - e + f[h].startValue + f[h].size * (e - f[h].startValue) / (f[h].endValue - f[h].startValue) : !b && a > f[h].startValue && e < f[h].endValue && (c = a + f[h].size * (e - a) / (f[h].endValue - f[h].startValue)));\n\n      return c;\n    };\n\n    C.prototype.setViewPortRange = function (a, e) {\n      this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, e);\n      this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, e);\n    };\n\n    C.prototype.getXValueAt = function (a) {\n      if (!a) return null;\n      var e = null;\n      \"left\" === this._position ? e = this.convertPixelToValue(a.y) : \"bottom\" === this._position && (e = this.convertPixelToValue(a.x));\n      return e;\n    };\n\n    C.prototype.calculateValueToPixelConversionParameters = function (a) {\n      a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\n      var e = {\n        pixelPerUnit: null,\n        minimum: null,\n        reference: null\n      },\n          c = this.lineCoordinates.width,\n          b = this.lineCoordinates.height,\n          c = \"bottom\" === this._position || \"top\" === this._position ? c : b,\n          b = Math.abs(this.range);\n      if (this.logarithmic) for (var f = 0; f < a.length && !(this.viewportMaximum < a[f].startValue); f++) this.viewportMinimum > a[f].endValue || (this.viewportMinimum >= a[f].startValue && this.viewportMaximum <= a[f].endValue ? c = 0 : this.viewportMinimum <= a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b / a[f].endValue * a[f].startValue, c = 0 < a[f].spacing.toString().indexOf(\"%\") ? c * (1 - parseFloat(a[f].spacing) / 100) : c - Math.min(a[f].spacing, 0.1 * c)) : this.viewportMinimum > a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b / a[f].endValue * this.viewportMinimum, c = 0 < a[f].spacing.toString().indexOf(\"%\") ? c * (1 - parseFloat(a[f].spacing) / 100 * Math.log(a[f].endValue / this.viewportMinimum) / Math.log(a[f].endValue / a[f].startValue)) : c - Math.min(a[f].spacing, 0.1 * c) * Math.log(a[f].endValue / this.viewportMinimum) / Math.log(a[f].endValue / a[f].startValue)) : this.viewportMinimum <= a[f].startValue && this.viewportMaximum < a[f].endValue && (b = b / this.viewportMaximum * a[f].startValue, c = 0 < a[f].spacing.toString().indexOf(\"%\") ? c * (1 - parseFloat(a[f].spacing) / 100 * Math.log(this.viewportMaximum / a[f].startValue) / Math.log(a[f].endValue / a[f].startValue)) : c - Math.min(a[f].spacing, 0.1 * c) * Math.log(this.viewportMaximum / a[f].startValue) / Math.log(a[f].endValue / a[f].startValue)));else for (f = 0; f < a.length && !(this.viewportMaximum < a[f].startValue); f++) this.viewportMinimum > a[f].endValue || (this.viewportMinimum >= a[f].startValue && this.viewportMaximum <= a[f].endValue ? c = 0 : this.viewportMinimum <= a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b - a[f].endValue + a[f].startValue, c = 0 < a[f].spacing.toString().indexOf(\"%\") ? c * (1 - parseFloat(a[f].spacing) / 100) : c - Math.min(a[f].spacing, 0.1 * c)) : this.viewportMinimum > a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b - a[f].endValue + this.viewportMinimum, c = 0 < a[f].spacing.toString().indexOf(\"%\") ? c * (1 - parseFloat(a[f].spacing) / 100 * (a[f].endValue - this.viewportMinimum) / (a[f].endValue - a[f].startValue)) : c - Math.min(a[f].spacing, 0.1 * c) * (a[f].endValue - this.viewportMinimum) / (a[f].endValue - a[f].startValue)) : this.viewportMinimum <= a[f].startValue && this.viewportMaximum < a[f].endValue && (b = b - this.viewportMaximum + a[f].startValue, c = 0 < a[f].spacing.toString().indexOf(\"%\") ? c * (1 - parseFloat(a[f].spacing) / 100 * (this.viewportMaximum - a[f].startValue) / (a[f].endValue - a[f].startValue)) : c - Math.min(a[f].spacing, 0.1 * c) * (this.viewportMaximum - a[f].startValue) / (a[f].endValue - a[f].startValue)));\n      e.minimum = this.viewportMinimum;\n      e.maximum = this.viewportMaximum;\n      e.range = b;\n      if (\"bottom\" === this._position || \"top\" === this._position) this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? -1 : 1) * c * e.lnLogarithmBase / Math.log(Math.abs(b))) : e.pixelPerUnit = (this.reversed ? -1 : 1) * c / Math.abs(b), e.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;\n      if (\"left\" === this._position || \"right\" === this._position) this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? 1 : -1) * c * e.lnLogarithmBase / Math.log(Math.abs(b))) : e.pixelPerUnit = (this.reversed ? 1 : -1) * c / Math.abs(b), e.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;\n      this.conversionParameters = e;\n    };\n\n    C.prototype.calculateAxisParameters = function () {\n      if (this.logarithmic) this.calculateLogarithmicAxisParameters();else {\n        var a = this.chart.layoutManager.getFreeSpace(),\n            e = !1,\n            c = !1;\n        \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);\n        var a = \"axisX\" === this.type ? \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 62 : 70 : \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 : 40,\n            b = 4;\n        \"axisX\" === this.type && (b = 600 > this.maxWidth ? 8 : 6);\n        var a = Math.max(b, Math.floor(this.maxWidth / a)),\n            f,\n            h,\n            d,\n            b = 0;\n        !n(this.options.viewportMinimum) && !n(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum && (this.viewportMinimum = this.viewportMaximum = null);\n        if (n(this.options.viewportMinimum) && !n(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum)) this.viewportMinimum = this.sessionVariables.newViewportMinimum;else if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;\n        if (n(this.options.viewportMaximum) && !n(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum)) this.viewportMaximum = this.sessionVariables.newViewportMaximum;else if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;\n        if (this.scaleBreaks) for (b = 0; b < this.scaleBreaks._appliedBreaks.length; b++) if ((!n(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue || !n(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[b].startValue || !n(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue) && (!n(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue || !n(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[b].endValue || !n(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue)) {\n          this.scaleBreaks._appliedBreaks.splice(b, 1);\n\n          break;\n        }\n\n        if (\"axisX\" === this.type) {\n          if (this.dataSeries && 0 < this.dataSeries.length) for (f = 0; f < this.dataSeries.length; f++) \"dateTime\" === this.dataSeries[f].xValueType && (c = !0);\n          f = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;\n          h = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;\n          0 === h - f && (b = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, h += b, f -= b);\n          Infinity !== this.dataInfo.minDiff ? d = this.dataInfo.minDiff : 1 < h - f ? d = 0.5 * Math.abs(h - f) : (d = 1, c && (e = !0));\n        } else \"axisY\" === this.type && (f = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, h = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(f) || isFinite(h) ? isFinite(f) ? isFinite(h) || (h = f) : f = h : (h = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, f = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === f && 0 === h ? (h += 9, f = 0) : 0 === h - f ? (b = Math.min(Math.abs(0.01 * Math.abs(h)), 5), h += b, f -= b) : f > h ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(h, f, null, !0)), 5), 0 <= h ? f = h - b : h = isFinite(f) ? f + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(f, h, null, !0)), 0.05), 0 !== h && (h += b), 0 !== f && (f -= b)), d = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < h - f ? 0.5 * Math.abs(h - f) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < f && (f = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > h && (h = 0));\n\n        b = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? f : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? h : this.viewportMaximum, null, !0);\n\n        if (\"axisX\" === this.type && c) {\n          this.valueType = \"dateTime\";\n          this.intervalType || (b / 1 <= a ? (this.interval = 1, this.intervalType = \"millisecond\") : b / 2 <= a ? (this.interval = 2, this.intervalType = \"millisecond\") : b / 5 <= a ? (this.interval = 5, this.intervalType = \"millisecond\") : b / 10 <= a ? (this.interval = 10, this.intervalType = \"millisecond\") : b / 20 <= a ? (this.interval = 20, this.intervalType = \"millisecond\") : b / 50 <= a ? (this.interval = 50, this.intervalType = \"millisecond\") : b / 100 <= a ? (this.interval = 100, this.intervalType = \"millisecond\") : b / 200 <= a ? (this.interval = 200, this.intervalType = \"millisecond\") : b / 250 <= a ? (this.interval = 250, this.intervalType = \"millisecond\") : b / 300 <= a ? (this.interval = 300, this.intervalType = \"millisecond\") : b / 400 <= a ? (this.interval = 400, this.intervalType = \"millisecond\") : b / 500 <= a ? (this.interval = 500, this.intervalType = \"millisecond\") : b / (1 * L.secondDuration) <= a ? (this.interval = 1, this.intervalType = \"second\") : b / (2 * L.secondDuration) <= a ? (this.interval = 2, this.intervalType = \"second\") : b / (5 * L.secondDuration) <= a ? (this.interval = 5, this.intervalType = \"second\") : b / (10 * L.secondDuration) <= a ? (this.interval = 10, this.intervalType = \"second\") : b / (15 * L.secondDuration) <= a ? (this.interval = 15, this.intervalType = \"second\") : b / (20 * L.secondDuration) <= a ? (this.interval = 20, this.intervalType = \"second\") : b / (30 * L.secondDuration) <= a ? (this.interval = 30, this.intervalType = \"second\") : b / (1 * L.minuteDuration) <= a ? (this.interval = 1, this.intervalType = \"minute\") : b / (2 * L.minuteDuration) <= a ? (this.interval = 2, this.intervalType = \"minute\") : b / (5 * L.minuteDuration) <= a ? (this.interval = 5, this.intervalType = \"minute\") : b / (10 * L.minuteDuration) <= a ? (this.interval = 10, this.intervalType = \"minute\") : b / (15 * L.minuteDuration) <= a ? (this.interval = 15, this.intervalType = \"minute\") : b / (20 * L.minuteDuration) <= a ? (this.interval = 20, this.intervalType = \"minute\") : b / (30 * L.minuteDuration) <= a ? (this.interval = 30, this.intervalType = \"minute\") : b / (1 * L.hourDuration) <= a ? (this.interval = 1, this.intervalType = \"hour\") : b / (2 * L.hourDuration) <= a ? (this.interval = 2, this.intervalType = \"hour\") : b / (3 * L.hourDuration) <= a ? (this.interval = 3, this.intervalType = \"hour\") : b / (6 * L.hourDuration) <= a ? (this.interval = 6, this.intervalType = \"hour\") : b / (1 * L.dayDuration) <= a ? (this.interval = 1, this.intervalType = \"day\") : b / (2 * L.dayDuration) <= a ? (this.interval = 2, this.intervalType = \"day\") : b / (4 * L.dayDuration) <= a ? (this.interval = 4, this.intervalType = \"day\") : b / (1 * L.weekDuration) <= a ? (this.interval = 1, this.intervalType = \"week\") : b / (2 * L.weekDuration) <= a ? (this.interval = 2, this.intervalType = \"week\") : b / (3 * L.weekDuration) <= a ? (this.interval = 3, this.intervalType = \"week\") : b / (1 * L.monthDuration) <= a ? (this.interval = 1, this.intervalType = \"month\") : b / (2 * L.monthDuration) <= a ? (this.interval = 2, this.intervalType = \"month\") : b / (3 * L.monthDuration) <= a ? (this.interval = 3, this.intervalType = \"month\") : b / (6 * L.monthDuration) <= a ? (this.interval = 6, this.intervalType = \"month\") : (this.interval = b / (1 * L.yearDuration) <= a ? 1 : b / (2 * L.yearDuration) <= a ? 2 : b / (4 * L.yearDuration) <= a ? 4 : Math.floor(C.getNiceNumber(b / (a - 1), !0) / L.yearDuration), this.intervalType = \"year\"));\n          if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = f - d / 2;\n          if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = h + d / 2;\n          e ? this.autoValueFormatString = \"MMM DD YYYY HH:mm\" : \"year\" === this.intervalType ? this.autoValueFormatString = \"YYYY\" : \"month\" === this.intervalType ? this.autoValueFormatString = \"MMM YYYY\" : \"week\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"day\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"hour\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"minute\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"second\" === this.intervalType ? this.autoValueFormatString = \"hh:mm:ss TT\" : \"millisecond\" === this.intervalType && (this.autoValueFormatString = \"fff'ms'\");\n          this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);\n        } else {\n          this.intervalType = \"number\";\n          b = C.getNiceNumber(b, !1);\n          this.interval = this.options && 0 < this.options.interval ? this.options.interval : C.getNiceNumber(b / (a - 1), !0);\n          if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = \"axisX\" === this.type ? f - d / 2 : Math.floor(f / this.interval) * this.interval;\n          if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = \"axisX\" === this.type ? h + d / 2 : Math.ceil(h / this.interval) * this.interval;\n          0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && \"undefined\" === typeof this.options.interval && (this.interval = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\n        }\n\n        if (null === this.minimum || null === this.maximum) if (\"axisX\" === this.type ? (f = null !== this.minimum ? this.minimum : this.dataInfo.min, h = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === h - f && (b = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, h += b, f -= b), d = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < h - f ? 0.5 * Math.abs(h - f) : 1) : \"axisY\" === this.type && (f = null !== this.minimum ? this.minimum : this.dataInfo.min, h = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(f) || isFinite(h) ? 0 === f && 0 === h ? (h += 9, f = 0) : 0 === h - f ? (b = Math.min(Math.abs(0.01 * Math.abs(h)), 5), h += b, f -= b) : f > h ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(h, f, null, !0)), 5), 0 <= h ? f = h - b : h = isFinite(f) ? f + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(f, h, null, !0)), 0.05), 0 !== h && (h += b), 0 !== f && (f -= b)) : (h = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, f = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), d = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < h - f ? 0.5 * Math.abs(h - f) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < f && (f = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > h && (h = 0)), Math.abs(this.getApparentDifference(f, h, null, !0)), \"axisX\" === this.type && c) {\n          this.valueType = \"dateTime\";\n          if (null === this.minimum || isNaN(this.minimum)) this.minimum = f - d / 2, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);\n          if (null === this.maximum || isNaN(this.maximum)) this.maximum = h + d / 2, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);\n        } else this.intervalType = this.valueType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? f - d / 2 : Math.floor(f / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = \"axisX\" === this.type ? h + d / 2 : Math.ceil(h / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));\n        n(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));\n        n(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\n        this.range = this.viewportMaximum - this.viewportMinimum;\n        this.intervalStartPosition = \"axisX\" === this.type && c ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;\n        this.valueFormatString || (this.valueFormatString = C.generateValueFormatString(this.range, 2));\n      }\n    };\n\n    C.prototype.calculateLogarithmicAxisParameters = function () {\n      var a = this.chart.layoutManager.getFreeSpace(),\n          e = Math.log(this.logarithmBase),\n          c;\n      \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);\n      var a = \"axisX\" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3),\n          b,\n          f,\n          h,\n          d;\n      d = 1;\n      if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;\n      if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;\n      if (this.scaleBreaks) for (d = 0; d < this.scaleBreaks._appliedBreaks.length; d++) if ((!n(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[d].startValue || !n(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[d].startValue || !n(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[d].startValue) && (!n(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[d].endValue || !n(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[d].endValue || !n(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[d].endValue)) {\n        this.scaleBreaks._appliedBreaks.splice(d, 1);\n\n        break;\n      }\n      \"axisX\" === this.type ? (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === f / b && (d = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), f *= d, b /= d), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= b && !isFinite(f) ? (f = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, b = 1) : 0 >= b ? b = f : isFinite(f) || (f = b), 1 === b && 1 === f ? (f *= this.logarithmBase - 1 / this.logarithmBase, b = 1) : 1 === f / b ? (d = Math.min(f * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), f *= d, b /= d) : b > f ? (d = Math.min(b / f * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= f ? b = f / d : f = b * d) : (d = Math.min(f / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== f && (f *= d), 1 !== b && (b /= d)), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < b && (b = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > f && (f = 1));\n      d = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? f : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);\n      var m = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? f : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);\n      this.intervalType = \"number\";\n      d = Math.pow(this.logarithmBase, C.getNiceNumber(Math.abs(Math.log(d) / e), !1));\n      this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = C.getNiceExponent(Math.log(d) / e / (a - 1), !0), c = C.getNiceNumber(m / (a - 1), !0));\n      if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = \"axisX\" === this.type ? b / Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / e / this.interval));\n      if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = \"axisX\" === this.type ? f * Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(f) / e / this.interval));\n      1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && \"undefined\" === typeof this.options.interval && (this.interval = C.getNiceExponent(Math.ceil(Math.log(d) / e) / (a - 1)), c = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\n      if (null === this.minimum || null === this.maximum) \"axisX\" === this.type ? (b = null !== this.minimum ? this.minimum : this.dataInfo.min, f = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === f / b && (d = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), f *= d, b /= d), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (b = null !== this.minimum ? this.minimum : this.dataInfo.min, f = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(b) || isFinite(f) ? 1 === b && 1 === f ? (f *= this.logarithmBase, b /= this.logarithmBase) : 1 === f / b ? (d = Math.pow(this.logarithmBase, this.interval), f *= d, b /= d) : b > f ? (d = Math.min(0.01 * (b / f), 5), 1 <= f ? b = f / d : f = b * d) : (d = Math.min(f / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== f && (f *= d), 1 !== b && (b /= d)) : (f = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, b = 1), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < b && (b = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > f && (f = 1)), this.intervalType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? b / Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / e / this.interval)), n(null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? \"undefined\" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum) || (this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? \"undefined\" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum))), null === this.maximum && (this.maximum = \"axisX\" === this.type ? f * Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(f) / e / this.interval)), n(null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? \"undefined\" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum) || (this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? \"undefined\" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum))), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));\n      this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);\n      this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);\n      this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);\n      b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (e * this.interval) + 0.2) * this.interval);\n      this.range = this.viewportMaximum / this.viewportMinimum;\n      this.noTicks = a;\n\n      if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {\n        for (e = Math.floor(this.viewportMinimum / c + 0.5) * c; e < this.viewportMinimum;) e += c;\n\n        this.equidistantInterval = !1;\n        this.intervalStartPosition = e;\n        this.interval = c;\n      } else this.options.interval || (c = Math.ceil(this.interval), this.range > this.interval && (this.interval = c, b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (e * this.interval) + 0.2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = b;\n\n      if (!this.valueFormatString && (this.valueFormatString = \"#,##0.##\", 1 > this.viewportMinimum)) {\n        e = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;\n        if (isNaN(e) || !isFinite(e)) e = 2;\n        if (2 < e) for (d = 0; d < e - 2; d++) this.valueFormatString += \"#\";\n      }\n    };\n\n    C.generateValueFormatString = function (a, e) {\n      var c = \"#,##0.\",\n          b = e;\n      1 > a && (b += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(b) || !isFinite(b)) && (b = e);\n\n      for (var f = 0; f < b; f++) c += \"#\";\n\n      return c;\n    };\n\n    C.getNiceExponent = function (a, e) {\n      var c = Math.floor(Math.log(a) / Math.LN10),\n          b = a / Math.pow(10, c),\n          b = 0 > c ? 1 >= b ? 1 : 5 >= b ? 5 : 10 : Math.max(Math.floor(b), 1);\n      return -20 > c ? Number(b * Math.pow(10, c)) : Number((b * Math.pow(10, c)).toFixed(20));\n    };\n\n    C.getNiceNumber = function (a, e) {\n      var c = Math.floor(Math.log(a) / Math.LN10),\n          b = a / Math.pow(10, c),\n          b = e ? 1.5 > b ? 1 : 3 > b ? 2 : 7 > b ? 5 : 10 : 1 >= b ? 1 : 2 >= b ? 2 : 5 >= b ? 5 : 10;\n      return -20 > c ? Number(b * Math.pow(10, c)) : Number((b * Math.pow(10, c)).toFixed(20));\n    };\n\n    C.prototype.getLabelStartPoint = function () {\n      var a = L[this.intervalType + \"Duration\"] * this.interval,\n          a = new Date(Math.floor(this.viewportMinimum / a) * a);\n      if (\"millisecond\" !== this.intervalType) if (\"second\" === this.intervalType) 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));else if (\"minute\" === this.intervalType) {\n        if (0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"hour\" === this.intervalType) {\n        if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"day\" === this.intervalType) {\n        if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"week\" === this.intervalType) {\n        if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else if (\"month\" === this.intervalType) {\n        if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n      } else \"year\" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));\n      return a;\n    };\n\n    pa(ea, X);\n    pa(ca, X);\n\n    ca.prototype.createUserOptions = function (a) {\n      if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\n        var e = 0;\n        this.parent.options._isPlaceholder && this.parent.createUserOptions();\n        this.options._isPlaceholder || (Da(this.parent[this.optionsName]), e = this.parent.options[this.optionsName].indexOf(this.options));\n        this.options = \"undefined\" === typeof a ? {} : a;\n        this.parent.options[this.optionsName][e] = this.options;\n      }\n    };\n\n    ca.prototype.render = function (a) {\n      if (0 !== this.spacing || 0 !== this.options.lineThickness && (\"undefined\" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {\n        var e = this.ctx,\n            c = this.ctx.globalAlpha;\n        this.ctx = a || this.ctx;\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n        this.ctx.clip();\n        var b = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue),\n            f = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);\n        this.ctx.strokeStyle = this.lineColor;\n        this.ctx.fillStyle = this.color;\n        this.ctx.beginPath();\n        this.ctx.globalAlpha = 1;\n        W(this.id);\n        var d, r, m, n, k, l;\n        a = Math.max(this.spacing, 3);\n        var p = Math.max(0, this.lineThickness);\n        this.ctx.lineWidth = p;\n        this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, p));\n        if (\"bottom\" === this.scaleBreaks.parent._position || \"top\" === this.scaleBreaks.parent._position) {\n          if (b = 1 === p % 2 ? (b.x << 0) + 0.5 : b.x << 0, r = 1 === p % 2 ? (f.x << 0) + 0.5 : f.x << 0, \"top\" === this.scaleBreaks.parent._position ? (f = this.chart.plotArea.y1, m = this.chart.plotArea.y2 + p / 2 + 0.5 << 0) : (f = this.chart.plotArea.y2, m = this.chart.plotArea.y1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = {\n            x1: b - p / 2,\n            y1: f,\n            x2: r + p / 2,\n            y2: m\n          }, this.ctx.moveTo(b, f), \"straight\" === this.type || \"top\" === this.scaleBreaks.parent._position && 0 >= a || \"bottom\" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(b, m), this.ctx.lineTo(r, m), this.ctx.lineTo(r, f);else if (\"wavy\" === this.type) {\n            n = b;\n            k = f;\n            d = 0.5;\n            l = (m - k) / a / 3;\n\n            for (var q = 0; q < l; q++) this.ctx.bezierCurveTo(n + d * a, k + a, n + d * a, k + 2 * a, n, k + 3 * a), k += 3 * a, d *= -1;\n\n            this.ctx.bezierCurveTo(n + d * a, k + a, n + d * a, k + 2 * a, n, k + 3 * a);\n            n = r;\n            d *= -1;\n            this.ctx.lineTo(n, k);\n\n            for (q = 0; q < l; q++) this.ctx.bezierCurveTo(n + d * a, k - a, n + d * a, k - 2 * a, n, k - 3 * a), k -= 3 * a, d *= -1;\n          } else {\n            if (\"zigzag\" === this.type) {\n              d = -1;\n              k = f + a;\n              n = b + a;\n              l = (m - k) / a / 2;\n\n              for (q = 0; q < l; q++) this.ctx.lineTo(n, k), n += 2 * d * a, k += 2 * a, d *= -1;\n\n              this.ctx.lineTo(n, k);\n              n += r - b;\n\n              for (q = 0; q < l + 1; q++) this.ctx.lineTo(n, k), n += 2 * d * a, k -= 2 * a, d *= -1;\n\n              this.ctx.lineTo(n + d * a, k + a);\n            }\n          }\n        } else if (\"left\" === this.scaleBreaks.parent._position || \"right\" === this.scaleBreaks.parent._position) if (f = 1 === p % 2 ? (f.y << 0) + 0.5 : f.y << 0, m = 1 === p % 2 ? (b.y << 0) + 0.5 : b.y << 0, \"left\" === this.scaleBreaks.parent._position ? (b = this.chart.plotArea.x1, r = this.chart.plotArea.x2 + p / 2 + 0.5 << 0) : (b = this.chart.plotArea.x2, r = this.chart.plotArea.x1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = {\n          x1: b,\n          y1: f - p / 2,\n          x2: r,\n          y2: m + p / 2\n        }, this.ctx.moveTo(b, f), \"straight\" === this.type || \"left\" === this.scaleBreaks.parent._position && 0 >= a || \"right\" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(r, f), this.ctx.lineTo(r, m), this.ctx.lineTo(b, m);else if (\"wavy\" === this.type) {\n          n = b;\n          k = f;\n          d = 0.5;\n          l = (r - n) / a / 3;\n\n          for (q = 0; q < l; q++) this.ctx.bezierCurveTo(n + a, k + d * a, n + 2 * a, k + d * a, n + 3 * a, k), n += 3 * a, d *= -1;\n\n          this.ctx.bezierCurveTo(n + a, k + d * a, n + 2 * a, k + d * a, n + 3 * a, k);\n          k = m;\n          d *= -1;\n          this.ctx.lineTo(n, k);\n\n          for (q = 0; q < l; q++) this.ctx.bezierCurveTo(n - a, k + d * a, n - 2 * a, k + d * a, n - 3 * a, k), n -= 3 * a, d *= -1;\n        } else if (\"zigzag\" === this.type) {\n          d = 1;\n          k = f - a;\n          n = b + a;\n          l = (r - n) / a / 2;\n\n          for (q = 0; q < l; q++) this.ctx.lineTo(n, k), k += 2 * d * a, n += 2 * a, d *= -1;\n\n          this.ctx.lineTo(n, k);\n          k += m - f;\n\n          for (q = 0; q < l + 1; q++) this.ctx.lineTo(n, k), k += 2 * d * a, n -= 2 * a, d *= -1;\n\n          this.ctx.lineTo(n + a, k + d * a);\n        }\n        0 < p && this.ctx.stroke();\n        this.ctx.closePath();\n        this.ctx.globalAlpha = this.fillOpacity;\n        this.ctx.globalCompositeOperation = \"destination-over\";\n        this.ctx.fill();\n        this.ctx.restore();\n        this.ctx.globalAlpha = c;\n        this.ctx = e;\n      }\n    };\n\n    pa(Q, X);\n\n    Q.prototype.createUserOptions = function (a) {\n      if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\n        var e = 0;\n        this.parent.options._isPlaceholder && this.parent.createUserOptions();\n        this.options._isPlaceholder || (Da(this.parent.stripLines), e = this.parent.options.stripLines.indexOf(this.options));\n        this.options = \"undefined\" === typeof a ? {} : a;\n        this.parent.options.stripLines[e] = this.options;\n      }\n    };\n\n    Q.prototype.render = function () {\n      this.ctx.save();\n      var a = this.parent.getPixelCoordinatesOnAxis(this.value),\n          e = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : Math.abs(this.parent.convertValueToPixel(this.endValue) - this.parent.convertValueToPixel(this.startValue)));\n\n      if (0 < e) {\n        var c = null === this.opacity ? 1 : this.opacity;\n        this.ctx.strokeStyle = this.color;\n        this.ctx.beginPath();\n        var b = this.ctx.globalAlpha;\n        this.ctx.globalAlpha = c;\n        W(this.id);\n        var f, d, n, m;\n        this.ctx.lineWidth = e;\n        this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, e));\n        if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) f = d = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, n = this.chart.plotArea.y1, m = this.chart.plotArea.y2, this.bounds = {\n          x1: f - e / 2,\n          y1: n,\n          x2: d + e / 2,\n          y2: m\n        };else if (\"left\" === this.parent._position || \"right\" === this.parent._position) n = m = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, f = this.chart.plotArea.x1, d = this.chart.plotArea.x2, this.bounds = {\n          x1: f,\n          y1: n - e / 2,\n          x2: d,\n          y2: m + e / 2\n        };\n        this.ctx.moveTo(f, n);\n        this.ctx.lineTo(d, m);\n        this.ctx.stroke();\n        this.ctx.globalAlpha = b;\n      }\n\n      this.ctx.restore();\n    };\n\n    pa(da, X);\n\n    da.prototype.showAt = function (a) {\n      if (!this.enabled) return !1;\n      var e = this.chart,\n          c = !1;\n      e.resetOverlayedCanvas();\n      e.clearedOverlayedCanvas = this.parent.type;\n      this.chart.renderCrosshairs(this.parent);\n      if (\"xySwapped\" === e.plotInfo.axisPlacement) {\n        if (\"bottom\" === this.parent._position) for (var b = 0; b < e.axisY.length; b++) this.parent === e.axisY[b] && (e.axisY[b]._crosshairValue = a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? a : null);else if (\"top\" === this.parent._position) for (b = 0; b < e.axisY2.length; b++) this.parent === e.axisY2[b] && (e.axisY2[b]._crosshairValue = a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? a : null);else if (\"left\" === this.parent._position) for (b = 0; b < e.axisX.length; b++) this.parent === e.axisX[b] && (e.axisX[b]._crosshairValue = a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? a : null);else {\n          if (\"right\" === this.parent._position) for (b = 0; b < e.axisX2.length; b++) this.parent === e.axisX2[b] && (e.axisX2[b]._crosshairValue = a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? a : null);\n        }\n      } else if (\"bottom\" === this.parent._position) for (b = 0; b < e.axisX.length; b++) this.parent === e.axisX[b] && (e.axisX[b]._crosshairValue = a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? a : null);else if (\"top\" === this.parent._position) for (b = 0; b < e.axisX2.length; b++) this.parent === e.axisX2[b] && (e.axisX2[b]._crosshairValue = a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? a : null);else if (\"left\" === this.parent._position) for (b = 0; b < e.axisY.length; b++) this.parent === e.axisY[b] && (e.axisY[b]._crosshairValue = a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? a : null);else if (\"right\" === this.parent._position) for (b = 0; b < e.axisY2.length; b++) this.parent === e.axisY2[b] && (e.axisY2[b]._crosshairValue = a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? a : null);\n\n      for (b = 0; b < e.axisX.length; b++) a = e.axisX[b]._crosshairValue, e.axisX[b].crosshair && e.axisX[b].crosshair.enabled && !n(a) && a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum && (e.axisX[b].showCrosshair(a), e.axisX[b].crosshair._updatedValue = a, this === e.axisX[b].crosshair && (c = !0));\n\n      for (b = 0; b < e.axisX2.length; b++) a = e.axisX2[b]._crosshairValue, e.axisX2[b].crosshair && e.axisX2[b].crosshair.enabled && !n(a) && a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum && (e.axisX2[b].showCrosshair(a), e.axisX2[b].crosshair._updatedValue = a, this === e.axisX2[b].crosshair && (c = !0));\n\n      for (b = 0; b < e.axisY.length; b++) a = e.axisY[b]._crosshairValue, e.axisY[b].crosshair && e.axisY[b].crosshair.enabled && !n(a) && a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum && (e.axisY[b].showCrosshair(a), e.axisY[b].crosshair._updatedValue = a, this === e.axisY[b].crosshair && (c = !0));\n\n      for (b = 0; b < e.axisY2.length; b++) a = e.axisY2[b]._crosshairValue, e.axisY2[b].crosshair && e.axisY2[b].crosshair.enabled && !n(a) && a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum && (e.axisY2[b].showCrosshair(a), e.axisY2[b].crosshair._updatedValue = a, this === e.axisY2[b].crosshair && (c = !0));\n\n      this.chart.toolTip && this.chart.toolTip._entries && this.chart.toolTip.highlightObjects(this.chart.toolTip._entries);\n      return c;\n    };\n\n    da.prototype.hide = function () {\n      this.chart.resetOverlayedCanvas();\n      this.chart.renderCrosshairs(this.parent);\n      this._hidden = !0;\n    };\n\n    da.prototype.render = function (a, e, c) {\n      var b,\n          f,\n          d,\n          r,\n          m = null,\n          t = null,\n          k = null,\n          l = \"\";\n      this.valueFormatString || (\"dateTime\" === this.parent.valueType ? this.valueFormatString = this.parent.valueFormatString : (k = 0, k = \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0), this.valueFormatString = C.generateValueFormatString(this.parent.range, k)));\n      var p = null === this.opacity ? 1 : this.opacity,\n          q = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness),\n          g = this.chart.overlaidCanvasCtx,\n          v = g.globalAlpha;\n      g.beginPath();\n      g.strokeStyle = this.color;\n      g.lineWidth = q;\n      g.save();\n      this.labelFontSize = Math.abs(n(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize);\n      this.labelMaxWidth = n(this.options.labelMaxWidth) ? 0.3 * this.chart.width : this.labelMaxWidth;\n      this.labelMaxHeight = n(this.options.labelWrap) || this.labelWrap ? 0.3 * this.chart.height : 2 * this.labelFontSize;\n      0 < q && g.setLineDash && g.setLineDash(G(this.lineDashType, q));\n      k = new ja(g, {\n        x: 0,\n        y: 0,\n        padding: {\n          top: 2,\n          right: 3,\n          bottom: 2,\n          left: 4\n        },\n        backgroundColor: this.labelBackgroundColor,\n        borderColor: this.labelBorderColor,\n        borderThickness: this.labelBorderThickness,\n        cornerRadius: this.labelCornerRadius,\n        maxWidth: this.labelMaxWidth,\n        maxHeight: this.labelMaxHeight,\n        angle: this.labelAngle,\n        text: l,\n        textAlign: this.labelTextAlign,\n        fontSize: this.labelFontSize,\n        fontFamily: this.labelFontFamily,\n        fontWeight: this.labelFontWeight,\n        fontColor: this.labelFontColor,\n        fontStyle: this.labelFontStyle,\n        textBaseline: \"middle\"\n      });\n\n      if (this.snapToDataPoint) {\n        var w = 0,\n            l = [];\n\n        if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\n          var x = null;\n          if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) w = this.parent.dataSeries[0].axisX.convertPixelToValue({\n            y: e\n          });else if (\"left\" === this.parent._position || \"right\" === this.parent._position) w = this.parent.convertPixelToValue({\n            y: e\n          });\n\n          for (var s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (x.dataSeries = this.parent.dataSeries[s], null !== x.dataPoint.y && x.dataSeries.visible && l.push(x));\n\n          x = null;\n          if (0 === l.length) return;\n          l.sort(function (a, b) {\n            return a.distance - b.distance;\n          });\n          var z = x = 0;\n          yPercent = cumulativeY = 0;\n\n          for (var w = Infinity, u, s = 0; s < l.length; s++) {\n            if (\"rangeBar\" === l[s].dataSeries.type || \"error\" === l[s].dataSeries.type) {\n              if (l[s].dataPoint.y) for (var A = 0; A < l[s].dataPoint.y.length; A++) z = Math.abs(a - this.parent.convertValueToPixel(l[s].dataPoint.y[A])), z <= w && (w = z, x = s);\n            } else \"stackedBar\" === l[s].dataSeries.type ? (cumulativeY = l[s].dataSeries.dataPointEOs[l[s].index].cumulativeY, z = Math.abs(a - this.parent.convertValueToPixel(cumulativeY)), z <= w && (w = z, x = s)) : \"stackedBar100\" === l[s].dataSeries.type ? (z = l[0].dataPoint.x.getTime ? l[0].dataPoint.x.getTime() : l[0].dataPoint.x, n(u) && (u = Math.abs(a - this.parent.convertValueToPixel(100 * (l[0].dataSeries.dataPointEOs[l[0].index].cumulativeY / l[0].dataSeries.plotUnit.dataPointYSums[z])))), cumulativeY = l[s].dataSeries.dataPointEOs[l[s].index].cumulativeY, z = l[s].dataPoint.x.getTime ? l[s].dataPoint.x.getTime() : l[s].dataPoint.x, yPercent = 100 * (cumulativeY / l[s].dataSeries.plotUnit.dataPointYSums[z]), z = Math.abs(a - this.parent.convertValueToPixel(yPercent)), z <= u && (u = z, x = s)) : (z = Math.abs(a - this.parent.convertValueToPixel(l[s].dataPoint.y)), z <= w && (w = z, x = s));\n\n            n(u) || (w = Math.min(w, u));\n          }\n\n          u = l[x];\n          s = 0;\n\n          if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n            if (\"rangeBar\" === u.dataSeries.type || \"error\" === u.dataSeries.type) {\n              w = Math.abs(a - this.parent.convertValueToPixel(u.dataPoint.y[0]));\n\n              for (l = 0; l < u.dataPoint.y.length; l++) z = Math.abs(a - this.parent.convertValueToPixel(u.dataPoint.y[l])), z < w && (w = z, s = l);\n\n              m = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0) + 0.5 : this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0;\n              this.value = u.dataPoint.y[s];\n              k.text = this.labelFormatter ? this.labelFormatter({\n                chart: this.chart,\n                axis: this.parent.options,\n                crosshair: this.options,\n                value: u.dataPoint.y[s]\n              }) : n(this.options.label) ? fa(n(c) ? u.dataPoint.y[s] : c, this.valueFormatString, this.chart._cultureInfo) : this.label;\n            } else \"stackedBar\" === u.dataSeries.type ? (w = Math.abs(a - this.parent.convertValueToPixel(l[0].dataPoint.y)), cumulativeY = u.dataSeries.dataPointEOs[u.index].cumulativeY, m = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(cumulativeY) << 0) + 0.5 : this.parent.convertValueToPixel(cumulativeY) << 0, this.value = cumulativeY, k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: cumulativeY\n            }) : n(this.options.label) ? fa(n(c) ? cumulativeY : c, this.valueFormatString, this.chart._cultureInfo) : this.label) : \"stackedBar100\" === u.dataSeries.type ? (w = Math.abs(a - this.parent.convertValueToPixel(l[0].dataPoint.y)), cumulativeY = u.dataSeries.dataPointEOs[u.index].cumulativeY, z = u.dataPoint.x.getTime ? u.dataPoint.x.getTime() : u.dataPoint.x, yPercent = 100 * (cumulativeY / u.dataSeries.plotUnit.dataPointYSums[z]), m = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(yPercent) << 0) + 0.5 : this.parent.convertValueToPixel(yPercent) << 0, this.value = yPercent, k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: yPercent\n            }) : n(this.options.label) ? fa(n(c) ? yPercent : c, this.valueFormatString, this.chart._cultureInfo) : this.label) : (m = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(u.dataPoint.y) << 0, this.value = u.dataPoint.y, k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: u.dataPoint.y\n            }) : n(this.options.label) ? fa(n(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label);\n\n            b = f = m;\n            d = this.chart.plotArea.y1;\n            r = this.chart.plotArea.y2;\n            this.bounds = {\n              x1: b - q / 2,\n              y1: d,\n              x2: f + q / 2,\n              y2: r\n            };\n            k.x = b - k.measureText().width / 2;\n            k.x + k.width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.width : k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);\n            k.y = this.parent.lineCoordinates.y2 + (\"top\" === this.parent._position ? -k.height + this.parent.tickLength : k.fontSize / 2) + 2;\n            k.y + k.height > this.chart.bounds.y2 ? k.y = this.chart.bounds.y2 - k.height : k.y < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1);\n          } else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n            d = r = t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(u.dataPoint.x) << 0;\n            b = this.chart.plotArea.x1;\n            f = this.chart.plotArea.x2;\n            this.bounds = {\n              x1: b,\n              y1: d - q / 2,\n              x2: f,\n              y2: r + q / 2\n            };\n            s = !1;\n            if (this.parent.labels) for (w = Math.ceil(this.parent.interval), l = 0; l < this.parent.viewportMaximum; l += w) if (this.parent.labels[l]) s = !0;else {\n              s = !1;\n              break;\n            }\n\n            if (s) {\n              if (\"axisX\" === this.parent.type) for (w = this.parent.convertPixelToValue({\n                y: e\n              }), x = null, s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (k.text = this.labelFormatter ? this.labelFormatter({\n                chart: this.chart,\n                axis: this.parent.options,\n                crosshair: this.options,\n                value: u.dataPoint.x\n              }) : n(this.options.label) ? x.dataPoint.label : this.label);\n            } else k.text = \"dateTime\" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: u.dataPoint.x\n            }) : n(this.options.label) ? fa(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: u.dataPoint.x\n            }) : n(this.options.label) ? Ca(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;\n\n            this.value = u.dataPoint.x;\n            k.y = r + k.fontSize / 2 - k.measureText().height / 2 + 2;\n            k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);\n            \"left\" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : \"right\" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);\n          }\n        } else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n          w = this.parent.convertPixelToValue({\n            x: a\n          });\n\n          for (s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (x.dataSeries = this.parent.dataSeries[s], null !== x.dataPoint.y && x.dataSeries.visible && l.push(x));\n\n          if (0 === l.length) return;\n          l.sort(function (a, b) {\n            return a.distance - b.distance;\n          });\n          u = l[0];\n          b = f = m = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(u.dataPoint.x) << 0;\n          d = this.chart.plotArea.y1;\n          r = this.chart.plotArea.y2;\n          this.bounds = {\n            x1: b - q / 2,\n            y1: d,\n            x2: f + q / 2,\n            y2: r\n          };\n          s = !1;\n          if (this.parent.labels) for (w = Math.ceil(this.parent.interval), l = 0; l < this.parent.viewportMaximum; l += w) if (this.parent.labels[l]) s = !0;else {\n            s = !1;\n            break;\n          }\n\n          if (s) {\n            if (\"axisX\" === this.parent.type) for (w = this.parent.convertPixelToValue({\n              x: a\n            }), x = null, s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: u.dataPoint.x\n            }) : n(this.options.label) ? x.dataPoint.label : this.label);\n          } else k.text = \"dateTime\" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: u.dataPoint.x\n          }) : n(this.options.label) ? fa(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: u.dataPoint.x\n          }) : n(this.options.label) ? Ca(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;\n\n          this.value = u.dataPoint.x;\n          k.x = b - k.measureText().width / 2;\n          k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);\n          k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);\n          \"bottom\" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : \"top\" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);\n        } else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n          !n(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (w = this.parent.dataSeries[0].axisX.convertPixelToValue({\n            x: a\n          }));\n\n          for (s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (x.dataSeries = this.parent.dataSeries[s], null !== x.dataPoint.y && x.dataSeries.visible && l.push(x));\n\n          if (0 === l.length) return;\n          l.sort(function (a, b) {\n            return a.distance - b.distance;\n          });\n          z = x = 0;\n          w = Infinity;\n\n          for (s = 0; s < l.length; s++) {\n            if (\"rangeColumn\" === l[s].dataSeries.type || \"rangeArea\" === l[s].dataSeries.type || \"error\" === l[s].dataSeries.type || \"rangeSplineArea\" === l[s].dataSeries.type || \"candlestick\" === l[s].dataSeries.type || \"ohlc\" === l[s].dataSeries.type || \"boxAndWhisker\" === l[s].dataSeries.type) {\n              if (l[s].dataPoint.y) for (A = 0; A < l[s].dataPoint.y.length; A++) z = Math.abs(e - this.parent.convertValueToPixel(l[s].dataPoint.y[A])), z <= w && (w = z, x = s);\n            } else \"stackedColumn\" === l[s].dataSeries.type ? (b = l[s].dataSeries.dataPointEOs[l[s].index].cumulativeY, z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= w && (w = z, x = s)) : \"stackedArea\" === l[s].dataSeries.type ? (b = l[s].dataSeries.dataPointEOs[l[s].index].cumulativeY, z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= w && (w = z, x = s)) : \"stackedColumn100\" === l[s].dataSeries.type || \"stackedArea100\" === l[s].dataSeries.type ? (z = l[0].dataPoint.x.getTime ? l[0].dataPoint.x.getTime() : l[0].dataPoint.x, n(u) && (u = Math.abs(e - this.parent.convertValueToPixel(100 * (l[0].dataSeries.dataPointEOs[l[0].index].cumulativeY / l[0].dataSeries.plotUnit.dataPointYSums[z])))), \"stackedColumn100\" === l[s].dataSeries.type ? (t = l[s].dataSeries.dataPointEOs[l[s].index].cumulativeY, z = l[s].dataPoint.x.getTime ? l[s].dataPoint.x.getTime() : l[s].dataPoint.x, b = 100 * (t / l[s].dataSeries.plotUnit.dataPointYSums[z]), z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= u && (u = z, x = s)) : \"stackedArea100\" === l[s].dataSeries.type && (t = l[s].dataSeries.dataPointEOs[l[s].index].cumulativeY, z = l[s].dataPoint.x.getTime ? l[s].dataPoint.x.getTime() : l[s].dataPoint.x, b = 100 * (t / l[s].dataSeries.plotUnit.dataPointYSums[z]), z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= u && (u = z, x = s))) : \"waterfall\" === l[s].dataSeries.type ? (z = Math.abs(e - this.parent.convertValueToPixel(l[s].dataSeries.dataPointEOs[l[s].index].cumulativeSum)), z <= w && (u = w = z, x = s)) : (z = Math.abs(e - this.parent.convertValueToPixel(l[s].dataPoint.y)), z <= w && (w = z, x = s));\n\n            n(u) || (w = Math.min(w, u));\n          }\n\n          u = l[x];\n          s = 0;\n\n          if (\"rangeColumn\" === u.dataSeries.type || \"rangeArea\" === u.dataSeries.type || \"error\" === u.dataSeries.type || \"rangeSplineArea\" === u.dataSeries.type || \"candlestick\" === u.dataSeries.type || \"ohlc\" === u.dataSeries.type || \"boxAndWhisker\" === u.dataSeries.type) {\n            w = Math.abs(e - this.parent.convertValueToPixel(u.dataPoint.y[0]));\n\n            for (l = 0; l < u.dataPoint.y.length; l++) z = Math.abs(e - this.parent.convertValueToPixel(u.dataPoint.y[l])), z < w && (w = z, s = l);\n\n            t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0) + 0.5 : this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0;\n            k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: u.dataPoint.y[s]\n            }) : n(this.options.label) ? fa(n(c) ? u.dataPoint.y[s] : c, this.valueFormatString, this.chart._cultureInfo) : this.label;\n            this.value = u.dataPoint.y[s];\n          } else \"stackedColumn\" === u.dataSeries.type ? (b = u.dataSeries.dataPointEOs[u.index].cumulativeY, t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: b\n          }) : n(this.options.label) ? fa(n(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : \"stackedArea\" === u.dataSeries.type ? (b = u.dataSeries.dataPointEOs[u.index].cumulativeY, t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: b\n          }) : n(this.options.label) ? fa(n(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : \"stackedColumn100\" === u.dataSeries.type ? (t = u.dataSeries.dataPointEOs[u.index].cumulativeY, z = u.dataPoint.x.getTime ? u.dataPoint.x.getTime() : u.dataPoint.x, b = 100 * (t / u.dataSeries.plotUnit.dataPointYSums[z]), t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: b\n          }) : n(this.options.label) ? fa(n(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : \"stackedArea100\" === u.dataSeries.type ? (t = u.dataSeries.dataPointEOs[u.index].cumulativeY, z = u.dataPoint.x.getTime ? u.dataPoint.x.getTime() : u.dataPoint.x, b = 100 * (t / u.dataSeries.plotUnit.dataPointYSums[z]), t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + 0.5 : this.parent.convertValueToPixel(b) << 0, k.text = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: b\n          }) : n(this.options.label) ? fa(n(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = b) : \"waterfall\" === u.dataSeries.type ? (t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataSeries.dataPointEOs[u.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(u.dataSeries.dataPointEOs[u.index].cumulativeSum) << 0, k.text = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: u.dataSeries.dataPointEOs[u.index].cumulativeSum\n          }) : n(this.options.label) ? fa(n(c) ? u.dataSeries.dataPointEOs[u.index].cumulativeSum : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = u.dataSeries.dataPointEOs[u.index].cumulativeSum) : (t = 1 === g.lineWidth % 2 ? (n(a) ? e : this.parent.convertValueToPixel(u.dataPoint.y) << 0) + 0.5 : n(a) ? e : this.parent.convertValueToPixel(u.dataPoint.y) << 0, k.text = this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: n(c) ? u.dataPoint.y : c\n          }) : n(this.options.label) ? fa(n(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = u.dataPoint.y);\n\n          d = r = t;\n          b = this.chart.plotArea.x1;\n          f = this.chart.plotArea.x2;\n          this.bounds = {\n            x1: b,\n            y1: d - q / 2,\n            x2: f,\n            y2: r + q / 2\n          };\n          k.y = r + k.fontSize / 2 - k.measureText().height / 2 + 2;\n          k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);\n          \"left\" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : \"right\" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);\n        }\n\n        l = null;\n        g.globalAlpha = p;\n        if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) \"top\" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1 + k.fontSize / 2), \"bottom\" === this.parent._position && this.parent.lineCoordinates.y2 - k.fontSize / 2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2), this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < q && (g.moveTo(b, d), g.lineTo(f, r), g.stroke(), this._hidden = !1);\n        if (\"left\" === this.parent._position || \"right\" === this.parent._position) \"left\" === this.parent._position && k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), \"right\" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.measureText().width), this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < q && (g.moveTo(b, d), g.lineTo(f, r), g.stroke(), this._hidden = !1);\n      } else {\n        if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) b = f = m = 1 === g.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, d = this.chart.plotArea.y1, r = this.chart.plotArea.y2, this.bounds = {\n          x1: b - q / 2,\n          y1: d,\n          x2: f + q / 2,\n          y2: r\n        };else if (\"left\" === this.parent._position || \"right\" === this.parent._position) d = r = t = 1 === g.lineWidth % 2 ? (e << 0) + 0.5 : e << 0, b = this.chart.plotArea.x1, f = this.chart.plotArea.x2, this.bounds = {\n          x1: b,\n          y1: d - q / 2,\n          x2: f,\n          y2: r + q / 2\n        };\n        if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\n          if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n            s = !1;\n            if (this.parent.labels) for (w = Math.ceil(this.parent.interval), l = 0; l < this.parent.viewportMaximum; l += w) if (this.parent.labels[l]) s = !0;else {\n              s = !1;\n              break;\n            }\n\n            if (s) {\n              if (\"axisX\" === this.parent.type) for (w = this.parent.convertPixelToValue({\n                y: e\n              }), x = null, s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (k.text = this.labelFormatter ? this.labelFormatter({\n                chart: this.chart,\n                axis: this.parent.options,\n                crosshair: this.options,\n                value: n(c) ? this.parent.convertPixelToValue(a) : c\n              }) : n(this.options.label) ? x.dataPoint.label : this.label);\n            } else k.text = \"dateTime\" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: n(c) ? this.parent.convertPixelToValue(e) : c\n            }) : n(this.options.label) ? fa(n(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: n(c) ? this.parent.convertPixelToValue(e) : c\n            }) : n(this.options.label) ? Ca(n(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label;\n\n            k.y = e + k.fontSize / 2 - k.measureText().height / 2 + 2;\n            k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);\n            \"left\" === this.parent._position ? k.x = this.parent.lineCoordinates.x1 - k.measureText().width : \"right\" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);\n          } else {\n            if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: n(c) ? this.parent.convertPixelToValue(a) : c\n            }) : n(this.options.label) ? fa(n(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label, k.x = b - k.measureText().width / 2, k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width), k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), \"bottom\" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : \"top\" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);\n          }\n        } else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n          s = !1;\n          l = \"\";\n          if (this.parent.labels) for (w = Math.ceil(this.parent.interval), l = 0; l < this.parent.viewportMaximum; l += w) if (this.parent.labels[l]) s = !0;else {\n            s = !1;\n            break;\n          }\n\n          if (s) {\n            if (\"axisX\" === this.parent.type) for (w = this.parent.convertPixelToValue({\n              x: a\n            }), x = null, s = 0; s < this.parent.dataSeries.length; s++) (x = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= x.index && (k.text = this.labelFormatter ? this.labelFormatter({\n              chart: this.chart,\n              axis: this.parent.options,\n              crosshair: this.options,\n              value: n(c) ? this.parent.convertPixelToValue(a) : c\n            }) : n(this.options.label) ? n(c) ? x.dataPoint.label : c : this.label);\n          } else k.text = \"dateTime\" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: n(c) ? 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : \"\" : c\n          }) : n(this.options.label) ? fa(n(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({\n            chart: this.chart,\n            axis: this.parent.options,\n            crosshair: this.options,\n            value: n(c) ? this.parent.convertPixelToValue(a) : c\n          }) : n(this.options.label) ? Ca(n(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label;\n\n          k.x = b - k.measureText().width / 2;\n          k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);\n          k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);\n          \"bottom\" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : \"top\" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);\n        } else if (\"left\" === this.parent._position || \"right\" === this.parent._position) k.text = this.labelFormatter ? this.labelFormatter({\n          chart: this.chart,\n          axis: this.parent.options,\n          crosshair: this.options,\n          value: n(c) ? this.parent.convertPixelToValue(e) : c\n        }) : n(this.options.label) ? fa(n(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label, k.y = e + k.fontSize / 2 - k.measureText().height / 2 + 2, k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2), \"left\" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : \"right\" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);\n        \"left\" === this.parent._position && k.x < this.chart.bounds.x1 ? k.x = this.chart.bounds.x1 : \"right\" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.measureText().width : \"top\" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 : \"bottom\" === this.parent._position && this.parent.lineCoordinates.y2 - k.fontSize / 2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2);\n        g.globalAlpha = p;\n        0 < q && (g.moveTo(b, d), g.lineTo(f, r), g.stroke(), this._hidden = !1);\n        this.value = \"bottom\" === this.parent._position || \"top\" === this.parent._position ? this.parent.convertPixelToValue(a) : this.parent.convertPixelToValue(e);\n      }\n\n      if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) this._updatedValue = this.parent.convertPixelToValue(m);\n      if (\"left\" === this.parent._position || \"right\" === this.parent._position) this._updatedValue = this.parent.convertPixelToValue(t);\n      this._textBlock = k;\n      this._label = c;\n      n(c) || this.renderLabel();\n      g.restore();\n      g.globalAlpha = v;\n    };\n\n    da.prototype.renderLabel = function () {\n      this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && (n(this._textBlock) || n(this._textBlock.text) || !(\"number\" === typeof this._textBlock.text.valueOf() || 0 < this._textBlock.text.length) || this._hidden || this._textBlock.render(!0), n(this._label) && this.dispatchEvent(\"updated\", {\n        chart: this.chart,\n        crosshair: this.options,\n        axis: this.parent,\n        value: this.value\n      }, this.parent));\n    };\n\n    pa(na, X);\n\n    na.prototype._updateOptions = function () {\n      this.updateOption(\"enabled\");\n      this.updateOption(\"shared\");\n      this.updateOption(\"animationEnabled\");\n      this.updateOption(\"content\");\n      this.updateOption(\"contentFormatter\");\n      this.updateOption(\"reversed\");\n      this.updateOption(\"backgroundColor\");\n      this.updateOption(\"borderColor\");\n      this.updateOption(\"borderThickness\");\n      this.updateOption(\"cornerRadius\");\n      this.updateOption(\"fontSize\");\n      this.updateOption(\"fontColor\");\n      this.updateOption(\"fontFamily\");\n      this.updateOption(\"fontWeight\");\n      this.updateOption(\"fontStyle\");\n    };\n\n    na.prototype._initialize = function () {\n      this.updateOption(\"updated\");\n      this.updateOption(\"hidden\");\n\n      if (this.enabled) {\n        this.container = document.createElement(\"div\");\n        this.container.setAttribute(\"class\", \"canvasjs-chart-tooltip\");\n        this.container.style.position = \"absolute\";\n        this.container.style.height = \"auto\";\n        this.container.style.boxShadow = \"1px 1px 2px 2px rgba(0,0,0,0.1)\";\n        this.container.style.zIndex = \"1000\";\n        this.container.style.pointerEvents = \"none\";\n        this.container.style.display = \"none\";\n        var a = document.createElement(\"div\");\n        a.style.width = \"auto\";\n        a.style.height = \"auto\";\n        a.style.minWidth = \"50px\";\n        a.style.lineHeight = \"normal\";\n        a.style.margin = \"0px 0px 0px 0px\";\n        a.style.padding = \"5px\";\n        a.style.fontFamily = \"Calibri, Arial, Georgia, serif\";\n        a.style.fontWeight = \"normal\";\n        a.style.fontStyle = v ? \"italic\" : \"normal\";\n        a.style.fontSize = \"14px\";\n        a.style.color = \"#000000\";\n        a.style.textShadow = \"1px 1px 1px rgba(0, 0, 0, 0.1)\";\n        a.style.textAlign = \"left\";\n        a.style.border = \"2px solid gray\";\n        a.style.background = v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\";\n        a.style.textIndent = \"0px\";\n        a.style.whiteSpace = \"nowrap\";\n        a.style.borderRadius = \"5px\";\n        a.style.MozUserSelect = \"none\";\n        a.style.WebkitUserSelect = \"none\";\n        a.style.msUserSelect = \"none\";\n        a.style.userSelect = \"none\";\n        v || (a.style.filter = \"alpha(opacity = 90)\", a.style.filter = \"progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666')\");\n        a.innerText = \"Sample Tooltip\";\n        this.container.appendChild(a);\n        this.contentDiv = this.container.firstChild;\n        this.container.style.borderRadius = this.contentDiv.style.borderRadius;\n\n        this.chart._canvasJSContainer.appendChild(this.container);\n      }\n    };\n\n    na.prototype.mouseMoveHandler = function (a, e) {\n      this._lastUpdated && 4 > new Date().getTime() - this._lastUpdated || (this._lastUpdated = new Date().getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, e), this.enabled && this._updatedEventParameters && !isNaN(this._prevX) && !isNaN(this._prevY) && this.dispatchEvent(\"updated\", this._updatedEventParameters, this));\n    };\n\n    na.prototype._updateToolTip = function (a, e, c) {\n      c = \"undefined\" === typeof c ? !0 : c;\n\n      this._updateOptions();\n\n      this.container || this._initialize();\n      this.enabled || this.hide();\n\n      if (!this.chart.disableToolTip) {\n        if (\"undefined\" === typeof a || \"undefined\" === typeof e) {\n          if (isNaN(this._prevX) || isNaN(this._prevY)) return;\n          a = this._prevX;\n          e = this._prevY;\n        } else this._prevX = a, this._prevY = e;\n\n        var b = null,\n            f = null,\n            d = [],\n            r = 0;\n\n        if (this.shared && this.enabled && \"none\" !== this.chart.plotInfo.axisPlacement) {\n          var m = [];\n          if (this.chart.axisX) for (var t = 0; t < this.chart.axisX.length; t++) {\n            for (var r = \"xySwapped\" === this.chart.plotInfo.axisPlacement ? this.chart.axisX[t].convertPixelToValue({\n              y: e\n            }) : this.chart.axisX[t].convertPixelToValue({\n              x: a\n            }), k = null, b = 0; b < this.chart.axisX[t].dataSeries.length; b++) (k = this.chart.axisX[t].dataSeries[b].getDataPointAtX(r, c)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[t].dataSeries[b], null !== k.dataPoint.y && k.dataSeries.visible && m.push(k));\n\n            k = null;\n          }\n          if (this.chart.axisX2) for (t = 0; t < this.chart.axisX2.length; t++) {\n            r = \"xySwapped\" === this.chart.plotInfo.axisPlacement ? this.chart.axisX2[t].convertPixelToValue({\n              y: e\n            }) : this.chart.axisX2[t].convertPixelToValue({\n              x: a\n            });\n            k = null;\n\n            for (b = 0; b < this.chart.axisX2[t].dataSeries.length; b++) (k = this.chart.axisX2[t].dataSeries[b].getDataPointAtX(r, c)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[t].dataSeries[b], null !== k.dataPoint.y && k.dataSeries.visible && m.push(k));\n\n            k = null;\n          }\n          if (0 === m.length) return;\n          m.sort(function (a, b) {\n            return a.dataSeries.axisX.logarithmic || b.dataSeries.axisX.logarithmic ? a.distance - b.distance : a.distance / a.dataSeries.axisX.range - b.distance / b.dataSeries.axisX.range;\n          });\n          c = m[0];\n\n          for (b = 0; b < m.length; b++) m[b].dataPoint.x.valueOf() === c.dataPoint.x.valueOf() && d.push(m[b]);\n\n          m = null;\n        } else {\n          if (b = this.chart.getDataPointAtXY(a, e, c)) this.currentDataPointIndex = b.dataPointIndex, this.currentSeriesIndex = b.dataSeries.index;else if (v) {\n            if (b = ab(a, e, this.chart._eventManager.ghostCtx), 0 < b && \"undefined\" !== typeof this.chart._eventManager.objectMap[b]) {\n              b = this.chart._eventManager.objectMap[b];\n              if (\"legendItem\" === b.objectType) return;\n              this.currentSeriesIndex = b.dataSeriesIndex;\n              this.currentDataPointIndex = 0 <= b.dataPointIndex ? b.dataPointIndex : -1;\n            } else this.currentDataPointIndex = -1;\n          } else this.currentDataPointIndex = -1;\n\n          if (0 <= this.currentSeriesIndex) {\n            f = this.chart.data[this.currentSeriesIndex];\n            k = {};\n            if (0 <= this.currentDataPointIndex) b = f.dataPoints[this.currentDataPointIndex], k.dataSeries = f, k.dataPoint = b, k.index = this.currentDataPointIndex, k.distance = Math.abs(b.x - r), \"waterfall\" === f.type && (k.cumulativeSumYStartValue = f.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, k.cumulativeSum = f.dataPointEOs[this.currentDataPointIndex].cumulativeSum);else if (this.enabled && f && (\"line\" === f.type || \"stepLine\" === f.type || \"spline\" === f.type || \"area\" === f.type || \"stepArea\" === f.type || \"splineArea\" === f.type || \"stackedArea\" === f.type || \"stackedArea100\" === f.type || \"rangeArea\" === f.type || \"rangeSplineArea\" === f.type || \"candlestick\" === f.type || \"ohlc\" === f.type || \"boxAndWhisker\" === f.type)) r = f.axisX.convertPixelToValue({\n              x: a\n            }), k = f.getDataPointAtX(r, c), n(k) || (k.dataSeries = f, this.currentDataPointIndex = k.index, b = k.dataPoint);else {\n              \"toolTip\" === this.chart.clearedOverlayedCanvas && (this.chart.resetOverlayedCanvas(), this.chart.clearedOverlayedCanvas = null);\n              return;\n            }\n            if (!n(k) && !n(k.dataPoint) && !n(k.dataPoint.y)) if (k.dataSeries.axisY) {\n              if (0 < k.dataPoint.y.length) {\n                for (b = c = 0; b < k.dataPoint.y.length; b++) k.dataPoint.y[b] < k.dataSeries.axisY.viewportMinimum ? c-- : k.dataPoint.y[b] > k.dataSeries.axisY.viewportMaximum && c++;\n\n                c < k.dataPoint.y.length && c > -k.dataPoint.y.length && d.push(k);\n              } else \"column\" === f.type || \"bar\" === f.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && d.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && d.push(k) : \"bubble\" === f.type ? (c = this.chart._eventManager.objectMap[f.dataPointIds[k.index]].size / 2, k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - c && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + c && d.push(k)) : \"waterfall\" === f.type ? (c = 0, k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? c-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && c++, k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? c-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && c++, 2 > c && -2 < c && d.push(k)) : (0 <= k.dataSeries.type.indexOf(\"100\") || \"stackedColumn\" === f.type || \"stackedBar\" === f.type || k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && d.push(k);\n            } else d.push(k);\n          }\n        }\n\n        if (0 < d.length) {\n          if (this.highlightObjects(d), this.enabled) {\n            c = \"\";\n            c = this.getToolTipInnerHTML({\n              entries: d\n            });\n\n            if (null !== c) {\n              this.contentDiv.innerHTML = c;\n              if (this.isToolTipDefinedInData && n(this.options.content) && n(this.options.contentFormatter)) for (r = this.contentDiv.getElementsByTagName(\"span\"), b = 0; b < r.length; b++) r[b] && (r[b].style.color = r[b].getAttribute(\"data-color\"));\n              r = !1;\n              \"none\" === this.container.style.display && (r = !0, this.container.style.display = \"block\");\n\n              try {\n                this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", this.borderColor = \"waterfall\" === d[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : d[0].dataPoint.color ? d[0].dataPoint.color : 0 < d[0].dataPoint.y ? d[0].dataSeries.risingColor : d[0].dataSeries.fallingColor : \"error\" === d[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : d[0].dataSeries.color ? d[0].dataSeries.color : d[0].dataSeries._colorSet[f.index % d[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : d[0].dataPoint.color ? d[0].dataPoint.color : d[0].dataSeries.color ? d[0].dataSeries.color : d[0].dataSeries._colorSet[d[0].index % d[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + \"px\" : \"2px\", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + \"px\" : \"5px\", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + \"px\" : \"14px\", this.contentDiv.style.color = this.fontColor ? this.fontColor : \"#000000\", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : \"Calibri, Arial, Georgia, serif;\", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : \"normal\", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : v ? \"italic\" : \"normal\";\n              } catch (l) {}\n\n              \"pie\" === d[0].dataSeries.type || \"doughnut\" === d[0].dataSeries.type || \"funnel\" === d[0].dataSeries.type || \"pyramid\" === d[0].dataSeries.type || \"bar\" === d[0].dataSeries.type || \"rangeBar\" === d[0].dataSeries.type || \"stackedBar\" === d[0].dataSeries.type || \"stackedBar100\" === d[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = d[0].dataSeries.axisX.convertValueToPixel(d[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);\n              0 > a && (a += this.container.clientWidth + 20);\n              a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));\n              e = 1 !== d.length || this.shared || \"line\" !== d[0].dataSeries.type && \"stepLine\" !== d[0].dataSeries.type && \"spline\" !== d[0].dataSeries.type && \"area\" !== d[0].dataSeries.type && \"stepArea\" !== d[0].dataSeries.type && \"splineArea\" !== d[0].dataSeries.type ? \"bar\" === d[0].dataSeries.type || \"rangeBar\" === d[0].dataSeries.type || \"stackedBar\" === d[0].dataSeries.type || \"stackedBar100\" === d[0].dataSeries.type ? d[0].dataSeries.axisX.convertValueToPixel(d[0].dataPoint.x) : e : d[0].dataSeries.axisY.convertValueToPixel(d[0].dataPoint.y);\n              e = -e + 10;\n              0 < e + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0);\n              this.fixMozTransitionDelay(a, e);\n              !this.animationEnabled || r ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);\n              this.positionLeft = a;\n              this.positionBottom = e;\n              this.container.style.left = a + \"px\";\n              this.container.style.bottom = e + \"px\";\n            } else this.hide(!1), this.enabled && this.dispatchEvent(\"hidden\", {\n              chart: this.chart,\n              toolTip: this\n            }, this);\n\n            e = [];\n\n            for (b = 0; b < d.length; b++) e.push({\n              xValue: d[b].dataPoint.x,\n              dataPoint: d[b].dataPoint,\n              dataSeries: d[b].dataSeries,\n              dataPointIndex: d[b].index,\n              dataSeriesIndex: d[b].dataSeries._index\n            });\n\n            this._updatedEventParameters = {\n              chart: this.chart,\n              toolTip: this.options,\n              content: c,\n              entries: e\n            };\n            this._entries = d;\n          }\n        } else this.hide(), this.enabled && this.dispatchEvent(\"hidden\", {\n          chart: this.chart,\n          toolTip: this\n        }, this);\n\n        this._dataSeriesIndex = this._xValue = null;\n      }\n    };\n\n    na.prototype.highlightObjects = function (a) {\n      var e = this.chart.overlaidCanvasCtx;\n      n(this.chart.clearedOverlayedCanvas) || \"toolTip\" === this.chart.clearedOverlayedCanvas ? (this.chart.resetOverlayedCanvas(), e.clearRect(0, 0, this.chart.width, this.chart.height), this.chart.clearedOverlayedCanvas = \"toolTip\") : this.chart.clearedOverlayedCanvas = null;\n      e.save();\n      var c = this.chart.plotArea,\n          b = 0;\n      e.beginPath();\n      e.rect(c.x1, c.y1, c.x2 - c.x1, c.y2 - c.y1);\n      e.clip();\n\n      for (c = 0; c < a.length; c++) {\n        var f = a[c];\n\n        if ((f = this.chart._eventManager.objectMap[f.dataSeries.dataPointIds[f.index]]) && f.objectType && \"dataPoint\" === f.objectType) {\n          var b = this.chart.data[f.dataSeriesIndex],\n              d = b.dataPoints[f.dataPointIndex],\n              m = f.dataPointIndex;\n          !1 === d.highlightEnabled || !0 !== b.highlightEnabled && !0 !== d.highlightEnabled || (\"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"scatter\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type ? (d = b.getMarkerProperties(m, f.x1, f.y1, this.chart.overlaidCanvasCtx), d.size = Math.max(1.5 * d.size << 0, 10), d.borderColor = d.borderColor || \"#FFFFFF\", d.borderThickness = d.borderThickness || Math.ceil(0.1 * d.size), V.drawMarkers([d]), \"undefined\" !== typeof f.y2 && (d = b.getMarkerProperties(m, f.x1, f.y2, this.chart.overlaidCanvasCtx), d.size = Math.max(1.5 * d.size << 0, 10), d.borderColor = d.borderColor || \"#FFFFFF\", d.borderThickness = d.borderThickness || Math.ceil(0.1 * d.size), V.drawMarkers([d]))) : \"bubble\" === b.type ? (d = b.getMarkerProperties(m, f.x1, f.y1, this.chart.overlaidCanvasCtx), d.size = f.size, d.color = \"white\", d.borderColor = \"white\", e.globalAlpha = 0.3, V.drawMarkers([d]), e.globalAlpha = 1) : \"column\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"bar\" === b.type || \"rangeBar\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"rangeColumn\" === b.type || \"waterfall\" === b.type ? aa(e, f.x1, f.y1, f.x2, f.y2, \"white\", 0, null, !1, !1, !1, !1, 0.3) : \"pie\" === b.type || \"doughnut\" === b.type ? ia(e, f.center, f.radius, \"white\", b.type, f.startAngle, f.endAngle, 0.3, f.percentInnerRadius) : \"funnel\" === b.type || \"pyramid\" === b.type ? qa(e, f.funnelSection, 0.3, \"white\") : \"candlestick\" === b.type ? (e.globalAlpha = 1, e.strokeStyle = f.color, e.lineWidth = 2 * f.borderThickness, b = 0 === e.lineWidth % 2 ? 0 : 0.5, e.beginPath(), e.moveTo(f.x3 - b, Math.min(f.y2, f.y3)), e.lineTo(f.x3 - b, Math.min(f.y1, f.y4)), e.stroke(), e.beginPath(), e.moveTo(f.x3 - b, Math.max(f.y1, f.y4)), e.lineTo(f.x3 - b, Math.max(f.y2, f.y3)), e.stroke(), aa(e, f.x1, Math.min(f.y1, f.y4), f.x2, Math.max(f.y1, f.y4), \"transparent\", 2 * f.borderThickness, f.color, !1, !1, !1, !1), e.globalAlpha = 1) : \"ohlc\" === b.type ? (e.globalAlpha = 1, e.strokeStyle = f.color, e.lineWidth = 2 * f.borderThickness, b = 0 === e.lineWidth % 2 ? 0 : 0.5, e.beginPath(), e.moveTo(f.x3 - b, f.y2), e.lineTo(f.x3 - b, f.y3), e.stroke(), e.beginPath(), e.moveTo(f.x3, f.y1), e.lineTo(f.x1, f.y1), e.stroke(), e.beginPath(), e.moveTo(f.x3, f.y4), e.lineTo(f.x2, f.y4), e.stroke(), e.globalAlpha = 1) : \"boxAndWhisker\" === b.type ? (e.save(), e.globalAlpha = 1, e.strokeStyle = f.stemColor, e.lineWidth = 2 * f.stemThickness, 0 < f.stemThickness && (e.beginPath(), e.moveTo(f.x3, f.y2 + f.borderThickness / 2), e.lineTo(f.x3, f.y1 + f.whiskerThickness / 2), e.stroke(), e.beginPath(), e.moveTo(f.x3, f.y4 - f.whiskerThickness / 2), e.lineTo(f.x3, f.y3 - f.borderThickness / 2), e.stroke()), e.beginPath(), aa(e, f.x1, Math.max(f.y2, f.y3), f.x2, Math.min(f.y2, f.y3), \"transparent\", 2 * f.borderThickness, f.color, !1, !1, !1, !1), e.globalAlpha = 1, e.strokeStyle = f.whiskerColor, e.lineWidth = 2 * f.whiskerThickness, 0 < f.whiskerThickness && (e.beginPath(), e.moveTo(Math.floor(f.x3 - f.whiskerLength / 2), f.y4), e.lineTo(Math.ceil(f.x3 + f.whiskerLength / 2), f.y4), e.stroke(), e.beginPath(), e.moveTo(Math.floor(f.x3 - f.whiskerLength / 2), f.y1), e.lineTo(Math.ceil(f.x3 + f.whiskerLength / 2), f.y1), e.stroke()), e.globalAlpha = 1, e.strokeStyle = f.lineColor, e.lineWidth = 2 * f.lineThickness, 0 < f.lineThickness && (e.beginPath(), e.moveTo(f.x1, f.y5), e.lineTo(f.x2, f.y5), e.stroke()), e.restore(), e.globalAlpha = 1) : \"error\" === b.type && A(e, f.x1, f.y1, f.x2, f.y2, \"white\", f.whiskerProperties, f.stemProperties, f.isXYSwapped, 0.3));\n        }\n      }\n\n      e.restore();\n      e.globalAlpha = 1;\n      e.beginPath();\n    };\n\n    na.prototype.getToolTipInnerHTML = function (a) {\n      a = a.entries;\n      var e = null,\n          c = null,\n          b = null,\n          f = 0,\n          d = \"\";\n      this.isToolTipDefinedInData = !0;\n\n      for (var n = 0; n < a.length; n++) if (a[n].dataSeries.toolTipContent || a[n].dataPoint.toolTipContent) {\n        this.isToolTipDefinedInData = !1;\n        break;\n      }\n\n      if (this.isToolTipDefinedInData && (this.content && \"function\" === typeof this.content || this.contentFormatter)) a = {\n        chart: this.chart,\n        toolTip: this.options,\n        entries: a\n      }, e = this.contentFormatter ? this.contentFormatter(a) : this.content(a);else if (this.shared && \"none\" !== this.chart.plotInfo.axisPlacement) {\n        for (var m = null, t = \"\", n = 0; n < a.length; n++) {\n          c = a[n].dataSeries;\n          b = a[n].dataPoint;\n          f = a[n].index;\n          d = \"\";\n\n          if (0 === n && this.isToolTipDefinedInData && !this.content) {\n            this.chart.axisX && 0 < this.chart.axisX.length ? t += \"undefined\" !== typeof this.chart.axisX[0].labels[b.x] ? this.chart.axisX[0].labels[b.x] : \"{x}\" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (t += \"undefined\" !== typeof this.chart.axisX2[0].labels[b.x] ? this.chart.axisX2[0].labels[b.x] : \"{x}\");\n            t += \"</br>\";\n            if (!c.visible) continue;\n            t = this.chart.replaceKeywordsWithValue(t, b, c, f);\n          }\n\n          null === b.toolTipContent || \"undefined\" === typeof b.toolTipContent && null === c.options.toolTipContent || (\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"column\" === c.type || \"bar\" === c.type || \"scatter\" === c.type || \"stackedColumn\" === c.type || \"stackedColumn100\" === c.type || \"stackedBar\" === c.type || \"stackedBar100\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"waterfall\" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (d += m != c.axisXIndex ? c.axisX.title ? c.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), d += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}\", m = c.axisXIndex) : \"bubble\" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (d += m != c.axisXIndex ? c.axisX.title ? c.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), d += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\") : \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"error\" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (d += m != c.axisXIndex ? c.axisX.title ? c.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), d += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}\") : \"candlestick\" === c.type || \"ohlc\" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (d += m != c.axisXIndex ? c.axisX.title ? c.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), d += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\") : \"boxAndWhisker\" === c.type && (this.chart.axisX && 1 < this.chart.axisX.length && (d += m != c.axisXIndex ? c.axisX.title ? c.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), d += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>{name}:</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\"), null === e && (e = \"\"), c.visible && (!0 === this.reversed ? (e = this.chart.replaceKeywordsWithValue(d, b, c, f) + e, n < a.length - 1 && (e = \"</br>\" + e)) : (e += this.chart.replaceKeywordsWithValue(d, b, c, f), n < a.length - 1 && (e += \"</br>\"))));\n        }\n\n        null !== e && (e = t + e);\n      } else {\n        c = a[0].dataSeries;\n        b = a[0].dataPoint;\n        f = a[0].index;\n        if (null === b.toolTipContent || \"undefined\" === typeof b.toolTipContent && null === c.options.toolTipContent) return null;\n        \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"column\" === c.type || \"bar\" === c.type || \"scatter\" === c.type || \"stackedColumn\" === c.type || \"stackedColumn100\" === c.type || \"stackedBar\" === c.type || \"stackedBar100\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"waterfall\" === c.type ? d = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>\" + (b.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}\" : \"bubble\" === c.type ? d = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>\" + (b.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\" : \"pie\" === c.type || \"doughnut\" === c.type || \"funnel\" === c.type || \"pyramid\" === c.type ? d = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>\" + (b.name ? \"{name}:</span>&nbsp;&nbsp;\" : b.label ? \"{label}:</span>&nbsp;&nbsp;\" : \"</span>\") + \"{y}\" : \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"error\" === c.type ? d = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>\" + (b.label ? \"{label}\" : \"{x}\") + \" :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}\" : \"candlestick\" === c.type || \"ohlc\" === c.type ? d = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>\" + (b.label ? \"{label}\" : \"{x}\") + \"</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\" : \"boxAndWhisker\" === c.type && (d = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span data-color='\\\"\" + (this.options.fontColor ? \"\" : \"'{color}'\") + \"\\\"'>\" + (b.label ? \"{label}\" : \"{x}\") + \"</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\");\n        null === e && (e = \"\");\n        e += this.chart.replaceKeywordsWithValue(d, b, c, f);\n      }\n      return e;\n    };\n\n    na.prototype.enableAnimation = function () {\n      if (!this.container.style.WebkitTransition) {\n        var a = this.getContainerTransition(this.containerTransitionDuration);\n        this.container.style.WebkitTransition = a;\n        this.container.style.MsTransition = a;\n        this.container.style.transition = a;\n        this.container.style.MozTransition = this.mozContainerTransition;\n      }\n    };\n\n    na.prototype.disableAnimation = function () {\n      this.container.style.WebkitTransition && (this.container.style.WebkitTransition = \"\", this.container.style.MozTransition = \"\", this.container.style.MsTransition = \"\", this.container.style.transition = \"\");\n    };\n\n    na.prototype.hide = function (a) {\n      this.container && (this.container.style.display = \"none\", this.currentSeriesIndex = -1, this._entries = this._dataSeriesIndex = this._xValue = null, this._prevY = this._prevX = NaN, this._updatedEventParameters = null, (\"undefined\" === typeof a || a) && this.chart.resetOverlayedCanvas());\n    };\n\n    na.prototype.show = function (a, e, c) {\n      this._updateToolTip(a, e, \"undefined\" === typeof c ? !1 : c);\n    };\n\n    na.prototype.showAtIndex = function (a, e) {};\n\n    na.prototype.showAtX = function (a, e) {\n      if (!this.enabled) return !1;\n      this.chart.clearedOverlayedCanvas = null;\n\n      this._updateOptions();\n\n      var c,\n          b,\n          d,\n          h = [];\n      d = !1;\n      e = !n(e) && 0 <= e && e < this.chart.data.length ? e : 0;\n      if (this.shared) for (var m = 0; m < this.chart.data.length; m++) c = this.chart.data[m], (b = c.getDataPointAtX(a, !1)) && b.dataPoint && !n(b.dataPoint.y) && c.visible && (b.dataSeries = c, this.chart.data[e].axisX.convertValueToPixel(a) === c.axisX.convertValueToPixel(b.dataPoint.x) && h.push(b));else c = this.chart.data[e], (b = c.getDataPointAtX(a, !1)) && b.dataPoint && !n(b.dataPoint.y) && c.visible && (b.dataSeries = c, h.push(b));\n\n      if (0 < h.length) {\n        for (m = 0; m < h.length; m++) if (b = h[m], (this.shared || 0 <= b.dataSeries.type.indexOf(\"100\")) && b.dataPoint.x >= b.dataSeries.axisX.viewportMinimum && b.dataPoint.x <= b.dataSeries.axisX.viewportMaximum) {\n          d = !1;\n          break;\n        } else if (b.dataPoint.x < b.dataSeries.axisX.viewportMinimum || b.dataPoint.x > b.dataSeries.axisX.viewportMaximum || b.dataPoint.y < b.dataSeries.axisY.viewportMinimum || b.dataPoint.y > b.dataSeries.axisY.viewportMaximum) d = !0;else {\n          d = !1;\n          break;\n        }\n\n        if (d) return this.hide(), !1;\n        this.highlightObjects(h);\n        this._entries = h;\n        m = \"\";\n        m = this.getToolTipInnerHTML({\n          entries: h\n        });\n\n        if (null !== m) {\n          this.contentDiv.innerHTML = m;\n          if (this.isToolTipDefinedInData && n(this.options.content) && n(this.options.contentFormatter)) for (b = this.contentDiv.getElementsByTagName(\"span\"), m = 0; m < b.length; m++) b[m] && (b[m].style.color = b[m].getAttribute(\"data-color\"));\n          m = !1;\n          \"none\" === this.container.style.display && (m = !0, this.container.style.display = \"block\");\n\n          try {\n            this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", this.borderColor = \"waterfall\" === h[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : h[0].dataPoint.color ? h[0].dataPoint.color : 0 < h[0].dataPoint.y ? h[0].dataSeries.risingColor : h[0].dataSeries.fallingColor : \"error\" === h[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : h[0].dataSeries.color ? h[0].dataSeries.color : h[0].dataSeries._colorSet[c.index % h[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : h[0].dataPoint.color ? h[0].dataPoint.color : h[0].dataSeries.color ? h[0].dataSeries.color : h[0].dataSeries._colorSet[h[0].index % h[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + \"px\" : \"2px\", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + \"px\" : \"5px\", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + \"px\" : \"14px\", this.contentDiv.style.color = this.fontColor ? this.fontColor : \"#000000\", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : \"Calibri, Arial, Georgia, serif;\", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : \"normal\", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : v ? \"italic\" : \"normal\";\n          } catch (t) {}\n\n          \"pie\" === h[0].dataSeries.type || \"doughnut\" === h[0].dataSeries.type || \"funnel\" === h[0].dataSeries.type || \"pyramid\" === h[0].dataSeries.type ? c = mouseX - 10 - this.container.clientWidth : (c = \"bar\" === h[0].dataSeries.type || \"rangeBar\" === h[0].dataSeries.type || \"stackedBar\" === h[0].dataSeries.type || \"stackedBar100\" === h[0].dataSeries.type ? h[0].dataSeries.axisY.convertValueToPixel(h[0].dataPoint.y) - this.container.clientWidth << 0 : h[0].dataSeries.axisX.convertValueToPixel(h[0].dataPoint.x) - this.container.clientWidth << 0, c -= 10);\n          0 > c && (c += this.container.clientWidth + 20);\n          c + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (c = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));\n          h = 1 !== h.length || this.shared || \"line\" !== h[0].dataSeries.type && \"stepLine\" !== h[0].dataSeries.type && \"spline\" !== h[0].dataSeries.type && \"area\" !== h[0].dataSeries.type && \"stepArea\" !== h[0].dataSeries.type && \"splineArea\" !== h[0].dataSeries.type ? \"bar\" === h[0].dataSeries.type || \"rangeBar\" === h[0].dataSeries.type || \"stackedBar\" === h[0].dataSeries.type || \"stackedBar100\" === h[0].dataSeries.type ? h[0].dataSeries.axisX.convertValueToPixel(h[0].dataPoint.x) : h[0].dataSeries.axisY.convertValueToPixel(h[0].dataPoint.y) : h[0].dataSeries.axisY.convertValueToPixel(h[0].dataPoint.y);\n          h = -h + 10;\n          0 < h + this.container.clientHeight + 5 && (h -= h + this.container.clientHeight + 5 - 0);\n          this.fixMozTransitionDelay(c, h);\n          !this.animationEnabled || m ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);\n          this.container.style.left = c + \"px\";\n          this.container.style.bottom = h + \"px\";\n        } else return this.hide(!1), !1;\n      } else return this.hide(), !1;\n\n      this._xValue = a;\n      this._dataSeriesIndex = e;\n      this._prevY = this._prevX = NaN;\n      return !0;\n    };\n\n    na.prototype.fixMozTransitionDelay = function (a, e) {\n      if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0);else {\n        var c = parseFloat(this.container.style.left),\n            c = isNaN(c) ? 0 : c,\n            b = parseFloat(this.container.style.bottom),\n            b = isNaN(b) ? 0 : b;\n        10 < Math.sqrt(Math.pow(c - a, 2) + Math.pow(b - e, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);\n      }\n    };\n\n    na.prototype.getContainerTransition = function (a) {\n      return \"left \" + a + \"s ease-out 0s, bottom \" + a + \"s ease-out 0s\";\n    };\n\n    ha.prototype.reset = function () {\n      this.lastObjectId = 0;\n      this.objectMap = [];\n      this.rectangularRegionEventSubscriptions = [];\n      this.previousDataPointEventObject = null;\n      this.eventObjects = [];\n      v && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());\n    };\n\n    ha.prototype.getNewObjectTrackingId = function () {\n      return ++this.lastObjectId;\n    };\n\n    ha.prototype.mouseEventHandler = function (a) {\n      if (\"mousemove\" === a.type || \"click\" === a.type) {\n        var e = [],\n            c = Pa(a),\n            b = null;\n        if ((b = this.chart.getObjectAtXY(c.x, c.y, !1)) && \"undefined\" !== typeof this.objectMap[b]) if (b = this.objectMap[b], \"dataPoint\" === b.objectType) {\n          var d = this.chart.data[b.dataSeriesIndex],\n              h = d.dataPoints[b.dataPointIndex],\n              m = b.dataPointIndex;\n          b.eventParameter = {\n            x: c.x,\n            y: c.y,\n            dataPoint: h,\n            dataSeries: d.options,\n            dataPointIndex: m,\n            dataSeriesIndex: d.index,\n            chart: this.chart\n          };\n          b.eventContext = {\n            context: h,\n            userContext: h,\n            mouseover: \"mouseover\",\n            mousemove: \"mousemove\",\n            mouseout: \"mouseout\",\n            click: \"click\"\n          };\n          e.push(b);\n          b = this.objectMap[d.id];\n          b.eventParameter = {\n            x: c.x,\n            y: c.y,\n            dataPoint: h,\n            dataSeries: d.options,\n            dataPointIndex: m,\n            dataSeriesIndex: d.index,\n            chart: this.chart\n          };\n          b.eventContext = {\n            context: d,\n            userContext: d.options,\n            mouseover: \"mouseover\",\n            mousemove: \"mousemove\",\n            mouseout: \"mouseout\",\n            click: \"click\"\n          };\n          e.push(this.objectMap[d.id]);\n        } else \"legendItem\" === b.objectType && (d = this.chart.data[b.dataSeriesIndex], h = null !== b.dataPointIndex ? d.dataPoints[b.dataPointIndex] : null, b.eventParameter = {\n          x: c.x,\n          y: c.y,\n          dataSeries: d.options,\n          dataPoint: h,\n          dataPointIndex: b.dataPointIndex,\n          dataSeriesIndex: b.dataSeriesIndex,\n          chart: this.chart\n        }, b.eventContext = {\n          context: this.chart.legend,\n          userContext: this.chart.legend.options,\n          mouseover: \"itemmouseover\",\n          mousemove: \"itemmousemove\",\n          mouseout: \"itemmouseout\",\n          click: \"itemclick\"\n        }, e.push(b));\n        d = [];\n\n        for (c = 0; c < this.mouseoveredObjectMaps.length; c++) {\n          h = !0;\n\n          for (b = 0; b < e.length; b++) if (e[b].id === this.mouseoveredObjectMaps[c].id) {\n            h = !1;\n            break;\n          }\n\n          h ? this.fireEvent(this.mouseoveredObjectMaps[c], \"mouseout\", a) : d.push(this.mouseoveredObjectMaps[c]);\n        }\n\n        this.mouseoveredObjectMaps = d;\n\n        for (c = 0; c < e.length; c++) {\n          d = !1;\n\n          for (b = 0; b < this.mouseoveredObjectMaps.length; b++) if (e[c].id === this.mouseoveredObjectMaps[b].id) {\n            d = !0;\n            break;\n          }\n\n          d || (this.fireEvent(e[c], \"mouseover\", a), this.mouseoveredObjectMaps.push(e[c]));\n          \"click\" === a.type ? this.fireEvent(e[c], \"click\", a) : \"mousemove\" === a.type && this.fireEvent(e[c], \"mousemove\", a);\n        }\n      }\n    };\n\n    ha.prototype.fireEvent = function (a, d, c) {\n      if (a && d) {\n        var b = a.eventParameter,\n            f = a.eventContext,\n            h = a.eventContext.userContext;\n        h && f && h[f[d]] && h[f[d]].call(h, b);\n        \"mouseout\" !== d ? h.cursor && h.cursor !== c.target.style.cursor && (c.target.style.cursor = h.cursor) : (c.target.style.cursor = this.chart.panEnabled ? \"itemmouseout\" !== f.mouseout || h.dockInsidePlotArea ? \"move\" : this.chart._defaultCursor : this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);\n        \"click\" === d && \"dataPoint\" === a.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], b);\n        \"click\" === d && \"dataPoint\" === a.objectType && this.chart.funnelPyramidClickHandler && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], b);\n      }\n    };\n\n    $.prototype.animate = function (a, d, c, b, f) {\n      var h = this;\n      this.chart.isAnimating = !0;\n      f = f || K.easing.linear;\n      c && this.animations.push({\n        startTime: new Date().getTime() + (a ? a : 0),\n        duration: d,\n        animationCallback: c,\n        onComplete: b\n      });\n\n      for (a = []; 0 < this.animations.length;) if (d = this.animations.shift(), c = new Date().getTime(), b = 0, d.startTime <= c && (b = f(Math.min(c - d.startTime, d.duration), 0, 1, d.duration), b = Math.min(b, 1), isNaN(b) || !isFinite(b)) && (b = 1), 1 > b && a.push(d), d.animationCallback(b), 1 <= b && d.onComplete) d.onComplete();\n\n      this.animations = a;\n      0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () {\n        h.animate.call(h);\n      }) : this.chart.isAnimating = !1;\n    };\n\n    $.prototype.cancelAllAnimations = function () {\n      this.animations = [];\n      this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);\n      this.animationRequestId = null;\n      this.chart.isAnimating = !1;\n    };\n\n    var K = {\n      yScaleAnimation: function (a, d) {\n        if (0 !== a) {\n          var c = d.dest,\n              b = d.source.canvas,\n              f = d.animationBase;\n          c.drawImage(b, 0, 0, b.width, b.height, 0, f - f * a, c.canvas.width / la, a * c.canvas.height / la);\n        }\n      },\n      xScaleAnimation: function (a, d) {\n        if (0 !== a) {\n          var c = d.dest,\n              b = d.source.canvas,\n              f = d.animationBase;\n          c.drawImage(b, 0, 0, b.width, b.height, f - f * a, 0, a * c.canvas.width / la, c.canvas.height / la);\n        }\n      },\n      xClipAnimation: function (a, d) {\n        if (0 !== a) {\n          var c = d.dest,\n              b = d.source.canvas;\n          c.save();\n          0 < a && c.drawImage(b, 0, 0, b.width * a, b.height, 0, 0, b.width * a / la, b.height / la);\n          c.restore();\n        }\n      },\n      fadeInAnimation: function (a, d) {\n        if (0 !== a) {\n          var c = d.dest,\n              b = d.source.canvas;\n          c.save();\n          c.globalAlpha = a;\n          c.drawImage(b, 0, 0, b.width, b.height, 0, 0, c.canvas.width / la, c.canvas.height / la);\n          c.restore();\n        }\n      },\n      easing: {\n        linear: function (a, d, c, b) {\n          return c * a / b + d;\n        },\n        easeOutQuad: function (a, d, c, b) {\n          return -c * (a /= b) * (a - 2) + d;\n        },\n        easeOutQuart: function (a, d, c, b) {\n          return -c * ((a = a / b - 1) * a * a * a - 1) + d;\n        },\n        easeInQuad: function (a, d, c, b) {\n          return c * (a /= b) * a + d;\n        },\n        easeInQuart: function (a, d, c, b) {\n          return c * (a /= b) * a * a * a + d;\n        }\n      }\n    },\n        V = {\n      drawMarker: function (a, d, c, b, f, h, m, n) {\n        if (c) {\n          var t = 1;\n          c.fillStyle = h ? h : \"#000000\";\n          c.strokeStyle = m ? m : \"#000000\";\n          c.lineWidth = n ? n : 0;\n          c.setLineDash && c.setLineDash(G(\"solid\", n));\n          \"circle\" === b ? (c.moveTo(a, d), c.beginPath(), c.arc(a, d, f / 2, 0, 2 * Math.PI, !1), h && c.fill(), n && (m ? c.stroke() : (t = c.globalAlpha, c.globalAlpha = 0.15, c.strokeStyle = \"black\", c.stroke(), c.globalAlpha = t))) : \"square\" === b ? (c.beginPath(), c.rect(a - f / 2, d - f / 2, f, f), h && c.fill(), n && (m ? c.stroke() : (t = c.globalAlpha, c.globalAlpha = 0.15, c.strokeStyle = \"black\", c.stroke(), c.globalAlpha = t))) : \"triangle\" === b ? (c.beginPath(), c.moveTo(a - f / 2, d + f / 2), c.lineTo(a + f / 2, d + f / 2), c.lineTo(a, d - f / 2), c.closePath(), h && c.fill(), n && (m ? c.stroke() : (t = c.globalAlpha, c.globalAlpha = 0.15, c.strokeStyle = \"black\", c.stroke(), c.globalAlpha = t)), c.beginPath()) : \"cross\" === b && (c.strokeStyle = h, c.lineWidth = f / 4, c.beginPath(), c.moveTo(a - f / 2, d - f / 2), c.lineTo(a + f / 2, d + f / 2), c.stroke(), c.moveTo(a + f / 2, d - f / 2), c.lineTo(a - f / 2, d + f / 2), c.stroke());\n        }\n      },\n      drawMarkers: function (a) {\n        for (var d = 0; d < a.length; d++) {\n          var c = a[d];\n          V.drawMarker(c.x, c.y, c.ctx, c.type, c.size, c.color, c.borderColor, c.borderThickness);\n        }\n      }\n    };\n    return m;\n  }();\n\n  t.version = \"v3.9.0 GA\";\n  window.CanvasJS && t && !window.CanvasJS.Chart && (window.CanvasJS.Chart = t);\n})();\n/*\n  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.\n\n  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/\n  Licensed under the Apache License, Version 2.0\n*/\n\n\ndocument.createElement(\"canvas\").getContext || function () {\n  function V() {\n    return this.context_ || (this.context_ = new C(this));\n  }\n\n  function W(a, b, c) {\n    var g = M.call(arguments, 2);\n    return function () {\n      return a.apply(b, g.concat(M.call(arguments)));\n    };\n  }\n\n  function N(a) {\n    return String(a).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\");\n  }\n\n  function O(a) {\n    a.namespaces.g_vml_ || a.namespaces.add(\"g_vml_\", \"urn:schemas-microsoft-com:vml\", \"#default#VML\");\n    a.namespaces.g_o_ || a.namespaces.add(\"g_o_\", \"urn:schemas-microsoft-com:office:office\", \"#default#VML\");\n    a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = \"ex_canvas_\", a.cssText = \"canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}\");\n  }\n\n  function X(a) {\n    var b = a.srcElement;\n\n    switch (a.propertyName) {\n      case \"width\":\n        b.getContext().clearRect();\n        b.style.width = b.attributes.width.nodeValue + \"px\";\n        b.firstChild.style.width = b.clientWidth + \"px\";\n        break;\n\n      case \"height\":\n        b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + \"px\", b.firstChild.style.height = b.clientHeight + \"px\";\n    }\n  }\n\n  function Y(a) {\n    a = a.srcElement;\n    a.firstChild && (a.firstChild.style.width = a.clientWidth + \"px\", a.firstChild.style.height = a.clientHeight + \"px\");\n  }\n\n  function D() {\n    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n  }\n\n  function t(a, b) {\n    for (var c = D(), g = 0; 3 > g; g++) for (var e = 0; 3 > e; e++) {\n      for (var f = 0, d = 0; 3 > d; d++) f += a[g][d] * b[d][e];\n\n      c[g][e] = f;\n    }\n\n    return c;\n  }\n\n  function P(a, b) {\n    b.fillStyle = a.fillStyle;\n    b.lineCap = a.lineCap;\n    b.lineJoin = a.lineJoin;\n    b.lineWidth = a.lineWidth;\n    b.miterLimit = a.miterLimit;\n    b.shadowBlur = a.shadowBlur;\n    b.shadowColor = a.shadowColor;\n    b.shadowOffsetX = a.shadowOffsetX;\n    b.shadowOffsetY = a.shadowOffsetY;\n    b.strokeStyle = a.strokeStyle;\n    b.globalAlpha = a.globalAlpha;\n    b.font = a.font;\n    b.textAlign = a.textAlign;\n    b.textBaseline = a.textBaseline;\n    b.arcScaleX_ = a.arcScaleX_;\n    b.arcScaleY_ = a.arcScaleY_;\n    b.lineScale_ = a.lineScale_;\n  }\n\n  function Q(a) {\n    var b = a.indexOf(\"(\", 3),\n        c = a.indexOf(\")\", b + 1),\n        b = a.substring(b + 1, c).split(\",\");\n    if (4 != b.length || \"a\" != a.charAt(3)) b[3] = 1;\n    return b;\n  }\n\n  function E(a, b, c) {\n    return Math.min(c, Math.max(b, a));\n  }\n\n  function F(a, b, c) {\n    0 > c && c++;\n    1 < c && c--;\n    return 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;\n  }\n\n  function G(a) {\n    if (a in H) return H[a];\n    var b,\n        c = 1;\n    a = String(a);\n    if (\"#\" == a.charAt(0)) b = a;else if (/^rgb/.test(a)) {\n      c = Q(a);\n      b = \"#\";\n\n      for (var g, e = 0; 3 > e; e++) g = -1 != c[e].indexOf(\"%\") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];\n\n      c = +c[3];\n    } else if (/^hsl/.test(a)) {\n      e = c = Q(a);\n      b = parseFloat(e[0]) / 360 % 360;\n      0 > b && b++;\n      g = E(parseFloat(e[1]) / 100, 0, 1);\n      e = E(parseFloat(e[2]) / 100, 0, 1);\n      if (0 == g) g = e = b = e;else {\n        var f = 0.5 > e ? e * (1 + g) : e + g - e * g,\n            d = 2 * e - f;\n        g = F(d, f, b + 1 / 3);\n        e = F(d, f, b);\n        b = F(d, f, b - 1 / 3);\n      }\n      b = \"#\" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];\n      c = c[3];\n    } else b = Z[a] || a;\n    return H[a] = {\n      color: b,\n      alpha: c\n    };\n  }\n\n  function C(a) {\n    this.m_ = D();\n    this.mStack_ = [];\n    this.aStack_ = [];\n    this.currentPath_ = [];\n    this.fillStyle = this.strokeStyle = \"#000\";\n    this.lineWidth = 1;\n    this.lineJoin = \"miter\";\n    this.lineCap = \"butt\";\n    this.miterLimit = 1 * q;\n    this.globalAlpha = 1;\n    this.font = \"10px sans-serif\";\n    this.textAlign = \"left\";\n    this.textBaseline = \"alphabetic\";\n    this.canvas = a;\n    var b = \"width:\" + a.clientWidth + \"px;height:\" + a.clientHeight + \"px;overflow:hidden;position:absolute\",\n        c = a.ownerDocument.createElement(\"div\");\n    c.style.cssText = b;\n    a.appendChild(c);\n    b = c.cloneNode(!1);\n    b.style.backgroundColor = \"red\";\n    b.style.filter = \"alpha(opacity=0)\";\n    a.appendChild(b);\n    this.element_ = c;\n    this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;\n  }\n\n  function R(a, b, c, g) {\n    a.currentPath_.push({\n      type: \"bezierCurveTo\",\n      cp1x: b.x,\n      cp1y: b.y,\n      cp2x: c.x,\n      cp2y: c.y,\n      x: g.x,\n      y: g.y\n    });\n    a.currentX_ = g.x;\n    a.currentY_ = g.y;\n  }\n\n  function S(a, b) {\n    var c = G(a.strokeStyle),\n        g = c.color,\n        c = c.alpha * a.globalAlpha,\n        e = a.lineScale_ * a.lineWidth;\n    1 > e && (c *= e);\n    b.push(\"<g_vml_:stroke\", ' opacity=\"', c, '\"', ' joinstyle=\"', a.lineJoin, '\"', ' miterlimit=\"', a.miterLimit, '\"', ' endcap=\"', $[a.lineCap] || \"square\", '\"', ' weight=\"', e, 'px\"', ' color=\"', g, '\" />');\n  }\n\n  function T(a, b, c, g) {\n    var e = a.fillStyle,\n        f = a.arcScaleX_,\n        d = a.arcScaleY_,\n        k = g.x - c.x,\n        n = g.y - c.y;\n\n    if (e instanceof w) {\n      var h = 0,\n          l = g = 0,\n          u = 0,\n          m = 1;\n\n      if (\"gradient\" == e.type_) {\n        h = e.x1_ / f;\n        c = e.y1_ / d;\n        var p = s(a, e.x0_ / f, e.y0_ / d),\n            h = s(a, h, c),\n            h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;\n        0 > h && (h += 360);\n        1E-6 > h && (h = 0);\n      } else p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q, n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;\n\n      f = e.colors_;\n      f.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n      d = f.length;\n      p = f[0].color;\n      c = f[d - 1].color;\n      k = f[0].alpha * a.globalAlpha;\n      a = f[d - 1].alpha * a.globalAlpha;\n\n      for (var n = [], r = 0; r < d; r++) {\n        var t = f[r];\n        n.push(t.offset * m + u + \" \" + t.color);\n      }\n\n      b.push('<g_vml_:fill type=\"', e.type_, '\"', ' method=\"none\" focus=\"100%\"', ' color=\"', p, '\"', ' color2=\"', c, '\"', ' colors=\"', n.join(\",\"), '\"', ' opacity=\"', a, '\"', ' g_o_:opacity2=\"', k, '\"', ' angle=\"', h, '\"', ' focusposition=\"', g, \",\", l, '\" />');\n    } else e instanceof I ? k && n && b.push(\"<g_vml_:fill\", ' position=\"', -c.x / k * f * f, \",\", -c.y / n * d * d, '\"', ' type=\"tile\"', ' src=\"', e.src_, '\" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color=\"', e.color, '\" opacity=\"', e.alpha * a.globalAlpha, '\" />'));\n  }\n\n  function s(a, b, c) {\n    a = a.m_;\n    return {\n      x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r,\n      y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r\n    };\n  }\n\n  function z(a, b, c) {\n    isFinite(b[0][0]) && isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1]) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));\n  }\n\n  function w(a) {\n    this.type_ = a;\n    this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;\n    this.colors_ = [];\n  }\n\n  function I(a, b) {\n    if (!a || 1 != a.nodeType || \"IMG\" != a.tagName) throw new A(\"TYPE_MISMATCH_ERR\");\n    if (\"complete\" != a.readyState) throw new A(\"INVALID_STATE_ERR\");\n\n    switch (b) {\n      case \"repeat\":\n      case null:\n      case \"\":\n        this.repetition_ = \"repeat\";\n        break;\n\n      case \"repeat-x\":\n      case \"repeat-y\":\n      case \"no-repeat\":\n        this.repetition_ = b;\n        break;\n\n      default:\n        throw new A(\"SYNTAX_ERR\");\n    }\n\n    this.src_ = a.src;\n    this.width_ = a.width;\n    this.height_ = a.height;\n  }\n\n  function A(a) {\n    this.code = this[a];\n    this.message = a + \": DOM Exception \" + this.code;\n  }\n\n  var x = Math,\n      k = x.round,\n      J = x.sin,\n      K = x.cos,\n      ba = x.abs,\n      aa = x.sqrt,\n      q = 10,\n      r = q / 2;\n  navigator.userAgent.match(/MSIE ([\\d.]+)?/);\n  var M = Array.prototype.slice;\n  O(document);\n  var U = {\n    init: function (a) {\n      a = a || document;\n      a.createElement(\"canvas\");\n      a.attachEvent(\"onreadystatechange\", W(this.init_, this, a));\n    },\n    init_: function (a) {\n      a = a.getElementsByTagName(\"canvas\");\n\n      for (var b = 0; b < a.length; b++) this.initElement(a[b]);\n    },\n    initElement: function (a) {\n      if (!a.getContext) {\n        a.getContext = V;\n        O(a.ownerDocument);\n        a.innerHTML = \"\";\n        a.attachEvent(\"onpropertychange\", X);\n        a.attachEvent(\"onresize\", Y);\n        var b = a.attributes;\n        b.width && b.width.specified ? a.style.width = b.width.nodeValue + \"px\" : a.width = a.clientWidth;\n        b.height && b.height.specified ? a.style.height = b.height.nodeValue + \"px\" : a.height = a.clientHeight;\n      }\n\n      return a;\n    }\n  };\n  U.init();\n\n  for (var v = [], d = 0; 16 > d; d++) for (var B = 0; 16 > B; B++) v[16 * d + B] = d.toString(16) + B.toString(16);\n\n  var Z = {\n    aliceblue: \"#F0F8FF\",\n    antiquewhite: \"#FAEBD7\",\n    aquamarine: \"#7FFFD4\",\n    azure: \"#F0FFFF\",\n    beige: \"#F5F5DC\",\n    bisque: \"#FFE4C4\",\n    black: \"#000000\",\n    blanchedalmond: \"#FFEBCD\",\n    blueviolet: \"#8A2BE2\",\n    brown: \"#A52A2A\",\n    burlywood: \"#DEB887\",\n    cadetblue: \"#5F9EA0\",\n    chartreuse: \"#7FFF00\",\n    chocolate: \"#D2691E\",\n    coral: \"#FF7F50\",\n    cornflowerblue: \"#6495ED\",\n    cornsilk: \"#FFF8DC\",\n    crimson: \"#DC143C\",\n    cyan: \"#00FFFF\",\n    darkblue: \"#00008B\",\n    darkcyan: \"#008B8B\",\n    darkgoldenrod: \"#B8860B\",\n    darkgray: \"#A9A9A9\",\n    darkgreen: \"#006400\",\n    darkgrey: \"#A9A9A9\",\n    darkkhaki: \"#BDB76B\",\n    darkmagenta: \"#8B008B\",\n    darkolivegreen: \"#556B2F\",\n    darkorange: \"#FF8C00\",\n    darkorchid: \"#9932CC\",\n    darkred: \"#8B0000\",\n    darksalmon: \"#E9967A\",\n    darkseagreen: \"#8FBC8F\",\n    darkslateblue: \"#483D8B\",\n    darkslategray: \"#2F4F4F\",\n    darkslategrey: \"#2F4F4F\",\n    darkturquoise: \"#00CED1\",\n    darkviolet: \"#9400D3\",\n    deeppink: \"#FF1493\",\n    deepskyblue: \"#00BFFF\",\n    dimgray: \"#696969\",\n    dimgrey: \"#696969\",\n    dodgerblue: \"#1E90FF\",\n    firebrick: \"#B22222\",\n    floralwhite: \"#FFFAF0\",\n    forestgreen: \"#228B22\",\n    gainsboro: \"#DCDCDC\",\n    ghostwhite: \"#F8F8FF\",\n    gold: \"#FFD700\",\n    goldenrod: \"#DAA520\",\n    grey: \"#808080\",\n    greenyellow: \"#ADFF2F\",\n    honeydew: \"#F0FFF0\",\n    hotpink: \"#FF69B4\",\n    indianred: \"#CD5C5C\",\n    indigo: \"#4B0082\",\n    ivory: \"#FFFFF0\",\n    khaki: \"#F0E68C\",\n    lavender: \"#E6E6FA\",\n    lavenderblush: \"#FFF0F5\",\n    lawngreen: \"#7CFC00\",\n    lemonchiffon: \"#FFFACD\",\n    lightblue: \"#ADD8E6\",\n    lightcoral: \"#F08080\",\n    lightcyan: \"#E0FFFF\",\n    lightgoldenrodyellow: \"#FAFAD2\",\n    lightgreen: \"#90EE90\",\n    lightgrey: \"#D3D3D3\",\n    lightpink: \"#FFB6C1\",\n    lightsalmon: \"#FFA07A\",\n    lightseagreen: \"#20B2AA\",\n    lightskyblue: \"#87CEFA\",\n    lightslategray: \"#778899\",\n    lightslategrey: \"#778899\",\n    lightsteelblue: \"#B0C4DE\",\n    lightyellow: \"#FFFFE0\",\n    limegreen: \"#32CD32\",\n    linen: \"#FAF0E6\",\n    magenta: \"#FF00FF\",\n    mediumaquamarine: \"#66CDAA\",\n    mediumblue: \"#0000CD\",\n    mediumorchid: \"#BA55D3\",\n    mediumpurple: \"#9370DB\",\n    mediumseagreen: \"#3CB371\",\n    mediumslateblue: \"#7B68EE\",\n    mediumspringgreen: \"#00FA9A\",\n    mediumturquoise: \"#48D1CC\",\n    mediumvioletred: \"#C71585\",\n    midnightblue: \"#191970\",\n    mintcream: \"#F5FFFA\",\n    mistyrose: \"#FFE4E1\",\n    moccasin: \"#FFE4B5\",\n    navajowhite: \"#FFDEAD\",\n    oldlace: \"#FDF5E6\",\n    olivedrab: \"#6B8E23\",\n    orange: \"#FFA500\",\n    orangered: \"#FF4500\",\n    orchid: \"#DA70D6\",\n    palegoldenrod: \"#EEE8AA\",\n    palegreen: \"#98FB98\",\n    paleturquoise: \"#AFEEEE\",\n    palevioletred: \"#DB7093\",\n    papayawhip: \"#FFEFD5\",\n    peachpuff: \"#FFDAB9\",\n    peru: \"#CD853F\",\n    pink: \"#FFC0CB\",\n    plum: \"#DDA0DD\",\n    powderblue: \"#B0E0E6\",\n    rosybrown: \"#BC8F8F\",\n    royalblue: \"#4169E1\",\n    saddlebrown: \"#8B4513\",\n    salmon: \"#FA8072\",\n    sandybrown: \"#F4A460\",\n    seagreen: \"#2E8B57\",\n    seashell: \"#FFF5EE\",\n    sienna: \"#A0522D\",\n    skyblue: \"#87CEEB\",\n    slateblue: \"#6A5ACD\",\n    slategray: \"#708090\",\n    slategrey: \"#708090\",\n    snow: \"#FFFAFA\",\n    springgreen: \"#00FF7F\",\n    steelblue: \"#4682B4\",\n    tan: \"#D2B48C\",\n    thistle: \"#D8BFD8\",\n    tomato: \"#FF6347\",\n    turquoise: \"#40E0D0\",\n    violet: \"#EE82EE\",\n    wheat: \"#F5DEB3\",\n    whitesmoke: \"#F5F5F5\",\n    yellowgreen: \"#9ACD32\"\n  },\n      H = {},\n      L = {},\n      $ = {\n    butt: \"flat\",\n    round: \"round\"\n  },\n      d = C.prototype;\n\n  d.clearRect = function () {\n    this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null);\n    this.element_.innerHTML = \"\";\n  };\n\n  d.beginPath = function () {\n    this.currentPath_ = [];\n  };\n\n  d.moveTo = function (a, b) {\n    var c = s(this, a, b);\n    this.currentPath_.push({\n      type: \"moveTo\",\n      x: c.x,\n      y: c.y\n    });\n    this.currentX_ = c.x;\n    this.currentY_ = c.y;\n  };\n\n  d.lineTo = function (a, b) {\n    var c = s(this, a, b);\n    this.currentPath_.push({\n      type: \"lineTo\",\n      x: c.x,\n      y: c.y\n    });\n    this.currentX_ = c.x;\n    this.currentY_ = c.y;\n  };\n\n  d.bezierCurveTo = function (a, b, c, g, e, f) {\n    e = s(this, e, f);\n    a = s(this, a, b);\n    c = s(this, c, g);\n    R(this, a, c, e);\n  };\n\n  d.quadraticCurveTo = function (a, b, c, g) {\n    a = s(this, a, b);\n    c = s(this, c, g);\n    g = {\n      x: this.currentX_ + 2 / 3 * (a.x - this.currentX_),\n      y: this.currentY_ + 2 / 3 * (a.y - this.currentY_)\n    };\n    R(this, g, {\n      x: g.x + (c.x - this.currentX_) / 3,\n      y: g.y + (c.y - this.currentY_) / 3\n    }, c);\n  };\n\n  d.arc = function (a, b, c, g, e, f) {\n    c *= q;\n    var d = f ? \"at\" : \"wa\",\n        k = a + K(g) * c - r,\n        n = b + J(g) * c - r;\n    g = a + K(e) * c - r;\n    e = b + J(e) * c - r;\n    k != g || f || (k += 0.125);\n    a = s(this, a, b);\n    k = s(this, k, n);\n    g = s(this, g, e);\n    this.currentPath_.push({\n      type: d,\n      x: a.x,\n      y: a.y,\n      radius: c,\n      xStart: k.x,\n      yStart: k.y,\n      xEnd: g.x,\n      yEnd: g.y\n    });\n  };\n\n  d.rect = function (a, b, c, g) {\n    this.moveTo(a, b);\n    this.lineTo(a + c, b);\n    this.lineTo(a + c, b + g);\n    this.lineTo(a, b + g);\n    this.closePath();\n  };\n\n  d.strokeRect = function (a, b, c, g) {\n    var e = this.currentPath_;\n    this.beginPath();\n    this.moveTo(a, b);\n    this.lineTo(a + c, b);\n    this.lineTo(a + c, b + g);\n    this.lineTo(a, b + g);\n    this.closePath();\n    this.stroke();\n    this.currentPath_ = e;\n  };\n\n  d.fillRect = function (a, b, c, g) {\n    var e = this.currentPath_;\n    this.beginPath();\n    this.moveTo(a, b);\n    this.lineTo(a + c, b);\n    this.lineTo(a + c, b + g);\n    this.lineTo(a, b + g);\n    this.closePath();\n    this.fill();\n    this.currentPath_ = e;\n  };\n\n  d.createLinearGradient = function (a, b, c, g) {\n    var e = new w(\"gradient\");\n    e.x0_ = a;\n    e.y0_ = b;\n    e.x1_ = c;\n    e.y1_ = g;\n    return e;\n  };\n\n  d.createRadialGradient = function (a, b, c, g, e, f) {\n    var d = new w(\"gradientradial\");\n    d.x0_ = a;\n    d.y0_ = b;\n    d.r0_ = c;\n    d.x1_ = g;\n    d.y1_ = e;\n    d.r1_ = f;\n    return d;\n  };\n\n  d.drawImage = function (a, b) {\n    var c, g, e, d, r, y, n, h;\n    e = a.runtimeStyle.width;\n    d = a.runtimeStyle.height;\n    a.runtimeStyle.width = \"auto\";\n    a.runtimeStyle.height = \"auto\";\n    var l = a.width,\n        u = a.height;\n    a.runtimeStyle.width = e;\n    a.runtimeStyle.height = d;\n    if (3 == arguments.length) c = arguments[1], g = arguments[2], r = y = 0, n = e = l, h = d = u;else if (5 == arguments.length) c = arguments[1], g = arguments[2], e = arguments[3], d = arguments[4], r = y = 0, n = l, h = u;else if (9 == arguments.length) r = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d = arguments[8];else throw Error(\"Invalid number of arguments\");\n    var m = s(this, c, g),\n        p = [];\n    p.push(\" <g_vml_:group\", ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' coordorigin=\"0,0\"', ' style=\"width:', 10, \"px;height:\", 10, \"px;position:absolute;\");\n\n    if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {\n      var t = [];\n      t.push(\"M11=\", this.m_[0][0], \",\", \"M12=\", this.m_[1][0], \",\", \"M21=\", this.m_[0][1], \",\", \"M22=\", this.m_[1][1], \",\", \"Dx=\", k(m.x / q), \",\", \"Dy=\", k(m.y / q), \"\");\n      var v = s(this, c + e, g),\n          w = s(this, c, g + d);\n      c = s(this, c + e, g + d);\n      m.x = x.max(m.x, v.x, w.x, c.x);\n      m.y = x.max(m.y, v.y, w.y, c.y);\n      p.push(\"padding:0 \", k(m.x / q), \"px \", k(m.y / q), \"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(\", t.join(\"\"), \", sizingmethod='clip');\");\n    } else p.push(\"top:\", k(m.y / q), \"px;left:\", k(m.x / q), \"px;\");\n\n    p.push(' \">', '<g_vml_:image src=\"', a.src, '\"', ' style=\"width:', q * e, \"px;\", \" height:\", q * d, 'px\"', ' cropleft=\"', r / l, '\"', ' croptop=\"', y / u, '\"', ' cropright=\"', (l - r - n) / l, '\"', ' cropbottom=\"', (u - y - h) / u, '\"', \" />\", \"</g_vml_:group>\");\n    this.element_.insertAdjacentHTML(\"BeforeEnd\", p.join(\"\"));\n  };\n\n  d.stroke = function (a) {\n    var b = [];\n    b.push(\"<g_vml_:shape\", ' filled=\"', !!a, '\"', ' style=\"position:absolute;width:', 10, \"px;height:\", 10, 'px;\"', ' coordorigin=\"0,0\"', ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' stroked=\"', !a, '\"', ' path=\"');\n\n    for (var c = {\n      x: null,\n      y: null\n    }, d = {\n      x: null,\n      y: null\n    }, e = 0; e < this.currentPath_.length; e++) {\n      var f = this.currentPath_[e];\n\n      switch (f.type) {\n        case \"moveTo\":\n          b.push(\" m \", k(f.x), \",\", k(f.y));\n          break;\n\n        case \"lineTo\":\n          b.push(\" l \", k(f.x), \",\", k(f.y));\n          break;\n\n        case \"close\":\n          b.push(\" x \");\n          f = null;\n          break;\n\n        case \"bezierCurveTo\":\n          b.push(\" c \", k(f.cp1x), \",\", k(f.cp1y), \",\", k(f.cp2x), \",\", k(f.cp2y), \",\", k(f.x), \",\", k(f.y));\n          break;\n\n        case \"at\":\n        case \"wa\":\n          b.push(\" \", f.type, \" \", k(f.x - this.arcScaleX_ * f.radius), \",\", k(f.y - this.arcScaleY_ * f.radius), \" \", k(f.x + this.arcScaleX_ * f.radius), \",\", k(f.y + this.arcScaleY_ * f.radius), \" \", k(f.xStart), \",\", k(f.yStart), \" \", k(f.xEnd), \",\", k(f.yEnd));\n      }\n\n      if (f) {\n        if (null == c.x || f.x < c.x) c.x = f.x;\n        if (null == d.x || f.x > d.x) d.x = f.x;\n        if (null == c.y || f.y < c.y) c.y = f.y;\n        if (null == d.y || f.y > d.y) d.y = f.y;\n      }\n    }\n\n    b.push(' \">');\n    a ? T(this, b, c, d) : S(this, b);\n    b.push(\"</g_vml_:shape>\");\n    this.element_.insertAdjacentHTML(\"beforeEnd\", b.join(\"\"));\n  };\n\n  d.fill = function () {\n    this.stroke(!0);\n  };\n\n  d.closePath = function () {\n    this.currentPath_.push({\n      type: \"close\"\n    });\n  };\n\n  d.save = function () {\n    var a = {};\n    P(this, a);\n    this.aStack_.push(a);\n    this.mStack_.push(this.m_);\n    this.m_ = t(D(), this.m_);\n  };\n\n  d.restore = function () {\n    this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());\n  };\n\n  d.translate = function (a, b) {\n    z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1);\n  };\n\n  d.rotate = function (a) {\n    var b = K(a);\n    a = J(a);\n    z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1);\n  };\n\n  d.scale = function (a, b) {\n    this.arcScaleX_ *= a;\n    this.arcScaleY_ *= b;\n    z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0);\n  };\n\n  d.transform = function (a, b, c, d, e, f) {\n    z(this, t([[a, b, 0], [c, d, 0], [e, f, 1]], this.m_), !0);\n  };\n\n  d.setTransform = function (a, b, c, d, e, f) {\n    z(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0);\n  };\n\n  d.drawText_ = function (a, b, c, d, e) {\n    var f = this.m_;\n    d = 0;\n    var r = 1E3,\n        t = 0,\n        n = [],\n        h;\n    h = this.font;\n    if (L[h]) h = L[h];else {\n      var l = document.createElement(\"div\").style;\n\n      try {\n        l.font = h;\n      } catch (u) {}\n\n      h = L[h] = {\n        style: l.fontStyle || \"normal\",\n        variant: l.fontVariant || \"normal\",\n        weight: l.fontWeight || \"normal\",\n        size: l.fontSize || 10,\n        family: l.fontFamily || \"sans-serif\"\n      };\n    }\n    var l = h,\n        m = this.element_;\n    h = {};\n\n    for (var p in l) h[p] = l[p];\n\n    p = parseFloat(m.currentStyle.fontSize);\n    m = parseFloat(l.size);\n    \"number\" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf(\"px\") ? h.size = m : -1 != l.size.indexOf(\"em\") ? h.size = p * m : -1 != l.size.indexOf(\"%\") ? h.size = p / 100 * m : -1 != l.size.indexOf(\"pt\") ? h.size = m / 0.75 : h.size = p;\n    h.size *= 0.981;\n    p = h.style + \" \" + h.variant + \" \" + h.weight + \" \" + h.size + \"px \" + h.family;\n    m = this.element_.currentStyle;\n    l = this.textAlign.toLowerCase();\n\n    switch (l) {\n      case \"left\":\n      case \"center\":\n      case \"right\":\n        break;\n\n      case \"end\":\n        l = \"ltr\" == m.direction ? \"right\" : \"left\";\n        break;\n\n      case \"start\":\n        l = \"rtl\" == m.direction ? \"right\" : \"left\";\n        break;\n\n      default:\n        l = \"left\";\n    }\n\n    switch (this.textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        t = h.size / 1.75;\n        break;\n\n      case \"middle\":\n        break;\n\n      default:\n      case null:\n      case \"alphabetic\":\n      case \"ideographic\":\n      case \"bottom\":\n        t = -h.size / 2.25;\n    }\n\n    switch (l) {\n      case \"right\":\n        d = 1E3;\n        r = 0.05;\n        break;\n\n      case \"center\":\n        d = r = 500;\n    }\n\n    b = s(this, b + 0, c + t);\n    n.push('<g_vml_:line from=\"', -d, ' 0\" to=\"', r, ' 0.05\" ', ' coordsize=\"100 100\" coordorigin=\"0 0\"', ' filled=\"', !e, '\" stroked=\"', !!e, '\" style=\"position:absolute;width:1px;height:1px;\">');\n    e ? S(this, n) : T(this, n, {\n      x: -d,\n      y: 0\n    }, {\n      x: r,\n      y: h.size\n    });\n    e = f[0][0].toFixed(3) + \",\" + f[1][0].toFixed(3) + \",\" + f[0][1].toFixed(3) + \",\" + f[1][1].toFixed(3) + \",0,0\";\n    b = k(b.x / q) + \",\" + k(b.y / q);\n    n.push('<g_vml_:skew on=\"t\" matrix=\"', e, '\" ', ' offset=\"', b, '\" origin=\"', d, ' 0\" />', '<g_vml_:path textpathok=\"true\" />', '<g_vml_:textpath on=\"true\" string=\"', N(a), '\" style=\"v-text-align:', l, \";font:\", N(p), '\" /></g_vml_:line>');\n    this.element_.insertAdjacentHTML(\"beforeEnd\", n.join(\"\"));\n  };\n\n  d.fillText = function (a, b, c, d) {\n    this.drawText_(a, b, c, d, !1);\n  };\n\n  d.strokeText = function (a, b, c, d) {\n    this.drawText_(a, b, c, d, !0);\n  };\n\n  d.measureText = function (a) {\n    this.textMeasureEl_ || (this.element_.insertAdjacentHTML(\"beforeEnd\", '<span style=\"position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;\"></span>'), this.textMeasureEl_ = this.element_.lastChild);\n    var b = this.element_.ownerDocument;\n    this.textMeasureEl_.innerHTML = \"\";\n    this.textMeasureEl_.style.font = this.font;\n    this.textMeasureEl_.appendChild(b.createTextNode(a));\n    return {\n      width: this.textMeasureEl_.offsetWidth\n    };\n  };\n\n  d.clip = function () {};\n\n  d.arcTo = function () {};\n\n  d.createPattern = function (a, b) {\n    return new I(a, b);\n  };\n\n  w.prototype.addColorStop = function (a, b) {\n    b = G(b);\n    this.colors_.push({\n      offset: a,\n      color: b.color,\n      alpha: b.alpha\n    });\n  };\n\n  d = A.prototype = Error();\n  d.INDEX_SIZE_ERR = 1;\n  d.DOMSTRING_SIZE_ERR = 2;\n  d.HIERARCHY_REQUEST_ERR = 3;\n  d.WRONG_DOCUMENT_ERR = 4;\n  d.INVALID_CHARACTER_ERR = 5;\n  d.NO_DATA_ALLOWED_ERR = 6;\n  d.NO_MODIFICATION_ALLOWED_ERR = 7;\n  d.NOT_FOUND_ERR = 8;\n  d.NOT_SUPPORTED_ERR = 9;\n  d.INUSE_ATTRIBUTE_ERR = 10;\n  d.INVALID_STATE_ERR = 11;\n  d.SYNTAX_ERR = 12;\n  d.INVALID_MODIFICATION_ERR = 13;\n  d.NAMESPACE_ERR = 14;\n  d.INVALID_ACCESS_ERR = 15;\n  d.VALIDATION_ERR = 16;\n  d.TYPE_MISMATCH_ERR = 17;\n  G_vmlCanvasManager = U;\n  CanvasRenderingContext2D = C;\n  CanvasGradient = w;\n  CanvasPattern = I;\n  DOMException = A;\n}();\n/*tslint:enable*/\n\n/*eslint-enable*/\n\n/*jshint ignore:end*/","map":null,"metadata":{},"sourceType":"script"}